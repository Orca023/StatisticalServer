# module Interface
# Main.Interface
Base.push!(LOAD_PATH, ".")  # 增加當前目錄為導入擴展包時候的搜索路徑之一，用於導入當前目錄下自定義的模組（Julia代碼文檔 .jl）;
# Base.MainInclude.include(Base.filter(Base.contains(r".*\.jl$"), Base.Filesystem.readdir()));  # 在 Jupyterlab 中實現加載 Base.MainInclude.include("*.jl") 文檔，其中 r".*\.jl$" 為解析脚本文檔名的正則表達式;


#################################################################################;

# Title: Julia server v20161211
# Explain: Julia file server, Julia http server, Julia http client
# Author: 趙健
# E-mail: 283640621@qq.com
# Telephont number: +86 18604537694
# E-mail: chinaorcaz@gmail.com
# Date: 歲在丙申
# Operating system: Windows10 x86_64 Inter(R)-Core(TM)-m3-6Y30
# Interpreter: julia-1.9.3-win64.exe
# Interpreter: julia-1.10.3-linux-x86_64.tar.gz
# Operating system: google-pixel-2 android-11 termux-0.118 ubuntu-22.04-LTS-rootfs arm64-aarch64 MSM8998-Snapdragon835-Qualcomm®-Kryo™-280
# Interpreter: julia-1.10.3-linux-aarch64.tar.gz

# 使用説明：
# 使用 Base.MainInclude.include() 函數可導入本地 Julia 脚本文檔到當前位置執行;
# Base.MainInclude.include("/home/Criss/jl/Interface.jl");
# Base.MainInclude.include("C:/Criss/jl/Interface.jl");
# Base.MainInclude.include("./Interface.jl");

# 控制臺命令列運行指令：
# C:\> C:/Criss/Julia/Julia-1.9.3/bin/julia.exe -p 4 --project=C:/Criss/jl/ C:/Criss/jl/Interface.jl configFile=C:/Criss/config.txt webPath=C:/Criss/html/ host=::0 port=10001 key=username:password number_Worker_threads=1 isConcurrencyHierarchy=Tasks is_monitor=false time_sleep=0.02 monitor_dir=C:/Criss/Intermediary/ monitor_file=C:/Criss/Intermediary/intermediary_write_C.txt output_dir=C:/Criss/Intermediary/ output_file=C:/Criss/Intermediary/intermediary_write_Julia.txt temp_cache_IO_data_dir=C:/Criss/temp/
# root@localhost:~# /usr/julia/julia-1.10.3/bin/julia -p 4 --project=/home/Criss/jl/ /home/Criss/jl/Interface.jl configFile=/home/Criss/config.txt webPath=/home/Criss/html/ host=::0 port=10001 key=username:password number_Worker_threads=1 isConcurrencyHierarchy=Tasks is_monitor=false time_sleep=0.02 monitor_dir=/home/Criss/Intermediary/ monitor_file=/home/Criss/Intermediary/intermediary_write_C.txt output_dir=/home/Criss/Intermediary/ output_file=/home/Criss/Intermediary/intermediary_write_Julia.txt temp_cache_IO_data_dir=/home/Criss/temp/

#################################################################################;

#################################################################################;

# monitor_file_do_Function() 函數的遺留問題：
# 1、在正常使用 root@localhost:~# ./julia.exe ./test.jl 啓動的脚本，如何在代碼中，啓動 Julia 的多綫程模式（export JULIA_NUM_THREADS=4）？
# 從而避免當 isMonitorThreadsOrProcesses = "Multi-Threading" 或 isDoTasksOrThreads = "Tasks" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
# 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
# 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
# println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
# println(Base.Threads.threadid()); # 查看當前綫程 ID 號;


# 2、在多進程（using Distributed;Distributed.@everywhere using Distributed;Distributed.addprocs(1);）時，如何將主進程中的函數，作爲參數，複製到子進程中可見可執行？
# main-process function f1
# main-process function f2(f1) -> worker-process function f3(f1) -> worker-process function f1
# 1)、向主进程中函数 f2 传入参数 ~ 函数 f1，执行 f2。
# 2)、主进程中函数 f2 创建子进程，并将参数（函数 f1）传递到子进程中可用，在子进程中声明函数 f3，使用 f3 调用参数（函数 f1）运行。
# 3)、最终形成，在子进程中执行，传入的参数（函数 f1）的效果。
# using Distributed;
# Distributed.@everywhere using Distributed;
# function f1(Str::Core.String)::Core.String
#     Str = Str * " worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task()));
#     return Str;
# end
# function f2(a::Core.String, f1Var)
#     println(a);
#     Distributed.addprocs(1);
#     function func_wp2(b::Core.String, wp2f1Var)
#         println(b);
#         function f3(c::Core.String, wp2f3Var)
#             println(c);
#             println(wp2f3Var("f3 -> f1"));
#         end
#         f3("f3 -> f1 run", wp2f1Var);
#     end
#     Distributed.remotecall(
#         func_wp2,
#         2,
#         "f2 remotecall",
#         f1Var
#     );
# end
# f2("mainProc-f2 run", f1);


# TCP_Server() 函數的遺留問題：
# 1、在正常使用 root@localhost:~# ./julia.exe ./test.jl 啓動的脚本，如何在代碼中，啓動 Julia 的多綫程模式（export JULIA_NUM_THREADS=4）？
# 從而避免當 isMonitorThreadsOrProcesses = "Multi-Threading" 或 isConcurrencyHierarchy = "Tasks" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
# 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
# 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
# println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
# println(Base.Threads.threadid()); # 查看當前綫程 ID 號;


# 2、在多進程（using Distributed;Distributed.@everywhere using Distributed;Distributed.addprocs(1);）時，如何將主進程中的函數，作爲參數，複製到子進程中可見可執行？
# main-process function f1
# main-process function f2(f1) -> worker-process function f3(f1) -> worker-process function f1
# 1)、向主进程中函数 f2 传入参数 ~ 函数 f1，执行 f2。
# 2)、主进程中函数 f2 创建子进程，并将参数（函数 f1）传递到子进程中可用，在子进程中声明函数 f3，使用 f3 调用参数（函数 f1）运行。
# 3)、最终形成，在子进程中执行，传入的参数（函数 f1）的效果。
# using Distributed;
# Distributed.@everywhere using Distributed;
# function f1(Str::Core.String)::Core.String
#     Str = Str * " worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task()));
#     return Str;
# end
# function f2(a::Core.String, f1Var)
#     println(a);
#     Distributed.addprocs(1);
#     function func_wp2(b::Core.String, wp2f1Var)
#         println(b);
#         function f3(c::Core.String, wp2f3Var)
#             println(c);
#             println(wp2f3Var("f3 -> f1"));
#         end
#         f3("f3 -> f1 run", wp2f1Var);
#     end
#     Distributed.remotecall(
#         func_wp2,
#         2,
#         "f2 remotecall",
#         f1Var
#     );
#     # # Base.Threads.@spawn
#     # # Create and run a Task on any available thread. To wait for the task to finish, call wait on the result of this macro, or call fetch to wait and then obtain its return value.
#     # # Values can be interpolated into @spawn via $, which copies the value directly into the constructed underlying closure. This allows you to insert the value of a variable, isolating the asynchronous code from changes to the variable's value in the current task.
#     # # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
#     # wp = Base.Threads.@spawn func_wp2(
#     #     "f2 remotecall",
#     #     f1Var
#     # );
# end
# f2("mainProc-f2 run", f1);

#################################################################################;


using Dates;  # 導入 Julia 的原生標準模組「Dates」，用於處理時間和日期數據，也可以用全名 Main.Dates. 訪問模組内的方法（函數）;
using Distributed;  # 導入 Julia 的原生標準模組「Distributed」，用於提供并行化和分佈式功能;
using Sockets;  # 導入 Julia 的原生標準模組「Sockets」，用於創建 TCP server 服務器;
using Base64;  # 導入 Julia 的原生標準模組「Base64」，用於按照 Base64 方式編解碼字符串;
# using SharedArrays;

Distributed.@everywhere using Dates, Distributed, Sockets, Base64;  # SharedArrays;  # 使用廣播關鍵字 Distributed.@everywhere 在所有子進程中加載指定模組或函數或變量;

# https://discourse.juliacn.com/t/topic/2969
# 如果想臨時更換pkg工具下載鏡像源，在julia解釋器環境命令行輸入命令：
# julia> ENV["JULIA_PKG_SERVER"]="https://mirrors.bfsu.edu.cn/julia/static"
# 或者：
# Windows Powershell: $env:JULIA_PKG_SERVER = 'https://pkg.julialang.org'
# Linux/macOS Bash: export JULIA_PKG_SERVER="https://pkg.julialang.org"
using HTTP;  # 導入第三方擴展包「HTTP」，用於創建 HTTP server 服務器，需要在控制臺先安裝第三方擴展包「HTTP」：julia> using Pkg; Pkg.add("HTTP"); using HTTP; 成功之後才能使用;
# https://github.com/JuliaWeb/HTTP.jl
# https://juliaweb.github.io/HTTP.jl/stable/
# https://juliaweb.github.io/HTTP.jl/stable/server/
# https://juliaweb.github.io/HTTP.jl/stable/client/
# https://juliaweb.github.io/HTTP.jl/stable/reference/
# https://juliaweb.github.io/HTTP.jl/stable/examples/

using JSON;  # 導入第三方擴展包「JSON」，用於轉換JSON字符串為字典 Base.Dict 對象，需要在控制臺先安裝第三方擴展包「JSON」：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
# https://github.com/JuliaIO/JSON.jl
# JSON.parse - string or stream to Julia data structures
# s = "{\"a_number\" : 5.0, \"an_array\" : [\"string\", 9]}"
# j = JSON.parse(s)
# Dict{AbstractString,Any} with 2 entries:
#     "an_array" => {"string",9}
#     "a_number" => 5.0
# JSON.json - Julia data structures to a string
# JSON.json([2,3])
# "[2,3]"
# JSON.json(j)
# "{\"an_array\":[\"string\",9],\"a_number\":5.0}"

# using JSON3;  # 導入第三方擴展包「JSON3」，用於轉換JSON字符串為字典 Base.Dict 對象，需要在控制臺先安裝第三方擴展包「JSON3」：julia> using Pkg; Pkg.add("JSON3") 成功之後才能使用;
# # https://github.com/quinnj/JSON3.jl
# # read from file
# # json_string = Base.read("./my.json", String)
# # JSON3.read(json_string)
# # JSON3.read(json_string, T; kw...)
# # x = T()
# # JSON3.read!(json_string, x; kw...)
# # JSON3.write(x)
# # write to file
# # Base.open("./my.json", "w") do f
# #     JSON3.write(f, x)
# #     println(f)
# # end
# # write a pretty file
# # open("my.json", "w") do f
# #     JSON3.pretty(f, JSON3.write(x))
# #     println(f)
# # end

# using StructTypes  # 導入第三方擴展包「StructTypes」，需要在控制臺先安裝第三方擴展包「StructTypes」：julia> using Pkg; Pkg.add("StructTypes") 成功之後才能使用;

# # 導入第三方擴展包;
# using Regex;  # 正則表達式包;



# 同步遞歸刪除非空文件夾，首先獲取到該資料夾裡面所有的資訊，遍歷裡面的資訊，判斷是文檔還是資料夾，如果是文檔直接刪除，如果是資料夾，進入資料夾，遞歸重複上述過程;
function cleanUpDir(absolute_path_String::Core.String)

    if !Base.Filesystem.ispath(absolute_path_String)
        println("the path [ $absolute_path_String ] not existence.");
    elseif  Base.Filesystem.isfile(absolute_path_String)
        Base.Filesystem.rm(absolute_path_String; force=false, recursive=false);
    elseif  Base.Filesystem.isdir(absolute_path_String)
        fileArray = Base.Filesystem.readdir(absolute_path_String);
        num = Base.length(Base.Filesystem.readdir(absolute_path_String));
        if Base.length(Base.Filesystem.readdir(absolute_path_String)) > 0

            # println("Clean up the directory [ $absolute_path_String ].");
            
            # # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
            # # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
            # Base.Filesystem.rm(absolute_path_String; force=false, recursive=true);  # 參數 force=true 表示如果路徑不存在也不會被視爲錯誤，。參數 recursive=true 且如果路徑為目錄，則遞歸刪除目錄下所有内容;
            # Base.Filesystem.mkpath(absolute_path_String, mode=0o777);  # 同步遞歸創建目錄，返回值(return) path;

            for f in Base.Filesystem.readdir(absolute_path_String)
                # println(Base.Filesystem.joinpath(absolute_path_String, f));

                # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                Base.Filesystem.rm(Base.Filesystem.joinpath(absolute_path_String, f); force=false, recursive=true);
            end

            return num;
        else
            # println("the directory [ $absolute_path_String ] empty.");
        end
    else
        println("the path [ $absolute_path_String ] type not recognition.");
    end
end
# export cleanUpDir;

# 自定義函數，用於判斷一個字符串是否只由阿拉伯數字 0 ~ 9 的字符組成;
function CheckString(letters::Core.String, fork::Core.String)::Core.Bool
    discrimination = true;

    # 判別 [0-9] 的阿拉伯數字字符;
    if fork === "arabic_numerals"

        # 使用 ismatch 函數正則表達式檢查;
        # m = ismatch(r"^[0-9]+$", letters, 1);  # 使用正則表達式檢查是否全部由阿拉伯數字[0-9]構成的字符串;
        # if m === true
        #     discrimination = true;
        # else
        #     discrimination = false;
        # end

        # 使用 match() 函數正則表達式檢查;
        # m = match(r"^[0-9]+$", letters, 1);  # 使正則表達式用檢查是否全部由阿拉伯數字[0-9]構成的字符串;
        # # RegexMatch("1")
        # if m === Core.nothing
        #     discrimination = false;
        # else
        #     discrimination = true;
        # end

        # 使用 for 循環逐個字符檢查;
        for c in letters
            if !Base.Unicode.isdigit(c)
                discrimination = false;
                break;
            end
        end
        # for i = 1:endof(letters)
        #     try
        #         # println(letters[i])
        #         # println(isdigit(letters[i]))
        #         # println(isnumeric(letters[i]))
        #         if !isdigit(letters[i])
        #             discrimination = false;
        #             break;
        #         end
        #     catch
        #         # ignore the index error
        #     end
        # end

        return discrimination;
    end

    # # 判別非負整數(正整數 + 0);
    # if fork === "non_negative_integer"
    #     # m = ismatch(r"^\\d+$", letters, 1);  # 使用正則表達式檢查是否由非負整數(正整數 + 0)構成的字符串;
    #     # if m === true
    #     #     discrimination = true;
    #     # else
    #     #     discrimination = false;
    #     # end
    #     return discrimination;
    # end

    # # 判別正整數;
    # if fork === "positive_integer"
    #     # m = ismatch(r"^[0-9]*[1-9][0-9]*$", letters, 1);  # 使用正則表達式檢查是否由正整數構成的字符串;
    #     # if m === true
    #     #     discrimination = true;
    #     # else
    #     #     discrimination = false;
    #     # end
    #     return discrimination;
    # end

    # # 判別非正整數(負整數 + 0);
    # if fork === "non_positive_integer"
    #     # m = ismatch(r"^((-\\d+)|(0+))$", letters, 1);  # 使用正則表達式檢查是否由非正整數(負整數 + 0)構成的字符串;
    #     # if m === true
    #     #     discrimination = true;
    #     # else
    #     #     discrimination = false;
    #     # end
    #     return discrimination;
    # end

    # # 判別負整數;
    # if fork === "negative_integer"
    #     # m = ismatch(r"^-[0-9]*[1-9][0-9]*$", letters, 1);  # 使用正則表達式檢查是否由負整數構成的字符串;
    #     # if m === true
    #     #     discrimination = true;
    #     # else
    #     #     discrimination = false;
    #     # end
    #     return discrimination;
    # end

    # # 判別整數;
    # if fork === "integer"
    #     # m = ismatch(r"^-?\\d+$", letters, 1);  # 使用正則表達式檢查是否由整數構成的字符串;
    #     # if m === true
    #     #     discrimination = true;
    #     # else
    #     #     discrimination = false;
    #     # end
    #     return discrimination;
    # end

    # # 判別非負浮點數(正浮點數 + 0);
    # if fork === "non_negative_float"
    #     # m = ismatch(r"^\\d+(", letters, 1);  # 使用正則表達式檢查是否由非負浮點數(正浮點數 + 0)構成的字符串;
    #     # if m === true
    #     #     discrimination = true;
    #     # else
    #     #     discrimination = false;
    #     # end
    #     return discrimination;
    # end

    # # 判別正浮點數;
    # if fork === "positive_float"
    #     # m = ismatch(r"^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$", letters, 1);  # 使用正則表達式檢查是否由正浮點數構成的字符串;
    #     # if m === true
    #     #     discrimination = true;
    #     # else
    #     #     discrimination = false;
    #     # end
    #     return discrimination;
    # end

    # # 判別非正浮點數(負浮點數 + 0);
    # if fork === "non_positive_float"
    #     # m = ismatch(r"^((-\\d+(", letters, 1);  # 使用正則表達式檢查是否由非正浮點數(負浮點數 + 0)構成的字符串;
    #     # if m === true
    #     #     discrimination = true;
    #     # else
    #     #     discrimination = false;
    #     # end
    #     return discrimination;
    # end

    # # 判別負浮點數;
    # if fork === "negative_float"
    #     # m = ismatch(r"^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$", letters, 1);  # 使用正則表達式檢查是否由負浮點數構成的字符串;
    #     # if m === true
    #     #     discrimination = true;
    #     # else
    #     #     discrimination = false;
    #     # end
    #     return discrimination;
    # end

    # # 判別浮點數;
    # if fork === "float"
    #     # m = ismatch(r"^(-?\\d+)(", letters, 1);  # 使用正則表達式檢查是否由浮點數構成的字符串;
    #     # if m === true
    #     #     discrimination = true;
    #     # else
    #     #     discrimination = false;
    #     # end
    #     return discrimination;
    # end
end
# export CheckString;

# # 自定義函數，用於判斷一個字符串是否符合 IPv6 格式規則，或是符合 IPv4 格式規則;
# function CheckIP(address::Core.String)::Core.Union{Core.String, Core.Bool}
#     # using Regex;
#     IPv6_pattern = r"^(::)?([a-fA-F\d]{1,4}:){7}[a-fA-F\d]{1,4}(:[a-fA-F\d]{1,4}){0,3}$|^(?:(?!.*::.*::)(?:(?!.*::$)|(?!.*:$))(?:\w+:{1,3}\w*)+)$";
#     IPv4_pattern = r"^((25[0-5]|2[0-4][0-9]|1[0-9]{3}|[1-9][0-9]{0,1})(\.(25[0-5]|2[0-4][0-9]|1[0-9]{3}|[1-9][0-9]{0,1})){3})$";

#     if match(IPv6_pattern, address) !== Core.nothing
#         return "IPv6";
#     elseif match(IPv4_pattern, address) !== Core.nothing
#         return "IPv4";
#     else
#         return false;
#     end
# end
# # export CheckIP;

# 自定義封裝的函數IsStringJSON(str)判斷一個字符串是否爲 JSON 格式的字符串;
function IsStringJSON(str::Core.String)::Core.Bool
    # # 首先判斷傳入參數 str 是否為一個字符串 Base.typeof (str) === 'string'，如果不是字符串直接返回錯誤;
    # if (Object.prototype.toString.call(str).toLowerCase() === '[object string]') {
    #     try {
    #         let Obj = JSON.parse(str);
    #         # 使用語句 if (Base.typeof (Obj) === 'object' && Object.prototype.toString.call(Obj).toLowerCase() === '[object object]' && !(Obj.length)) 判斷 Obj 是否為一個 JSON 對象;
    #         if (Base.typeof (Obj) === 'object' && Object.prototype.toString.call(Obj).toLowerCase() === '[object object]' && !(Obj.length)) {
    #             return true;
    #         } else {
    #             return false;
    #         };
    #     } catch (error) {
    #         // console.log(error);
    #         return false;
    #     } finally {
    #         // ;
    #     };
    # } else {
    #     // console.log("It is not a String!");
    #     return false;
    # };
end
# export IsStringJSON;  # 使用「export」接口對象，用來導出模塊中的成員;

# 自定義封裝的函數 JSONstring(Dict_Array) 將 Julia 字典（Dict）或一維數組（Array）對象轉換爲一個 JSON 格式的字符串;
# 注意，最多只能有 5 級字典（Dict）或一維數組（Array）對象嵌套，例如可以接受：{{{{}}}} 或者 [[[[]]]] 或者 {[{[]}]}  或者 [{[{}]}] 格式都可以轉換;
function JSONstring(Dict_Array::Core.Union{Base.Dict{Core.String, Core.Any}, Core.Array{Core.Any, 1}, Base.Vector{Core.Any}})::Core.String
    # 將 Julia 字典（Dict）對象轉換為 JSON 字符串;
    # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象;
    # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;

    # 拼接字符串;
    JSON_string::Core.String = "";  # 函數返回值;
    JSON_string = JSON.json(Dict_Array);

    # # 如果字符串長度太大，可以使用反斜杠 \ 來拆分跨行表示，例如 " a \ b" 這樣 a、b 可寫在兩行裏邊;
    # # 使用星號（*）拼接字符串;
    # # response_body_String = "{" * "\"" * "Target" * "\"" * ":" * "\"" * Base.string(response_body_Dict["request_Url"]) * "\"" * "," * "\"" * "request_Path" * "\"" * ":" * "\"" * Base.string(response_body_Dict["request_Path"]) * "\"" * "," * "\"" * "request_Url_Query_String" * "\"" * ":" * "\"" * Base.string(response_body_Dict["request_Url_Query_String"]) * "\"" * "," * "\"" * "request_POST" * "\"" * ":" * "\"" * Base.string(response_body_Dict["request_POST"]) * "\"" * "," * "\"" * "request_Authorization" * "\"" * ":" * "\"" * Base.string(response_body_Dict["request_Authorization"]) * "\"" * "," * "\"" * "request_Cookie" * "\"" * ":" * "\"" * Base.string(response_body_Dict["request_Cookie"]) * "\"" * "," * "\"" * "request_Nikename" * "\"" * ":" * "\"" * Base.string(response_body_Dict["request_Nikename"]) * "\"" * "," * "\"" * "request_Password" * "\"" * ":" * "\"" * Base.string(response_body_Dict["request_Password"]) * "\"" * "," * "\"" * "Server_Authorization" * "\"" * ":" * "\"" * Base.string(response_body_Dict["Server_Authorization"]) * "\"" * "," * "\"" * "Server_say" * "\"" * ":" * "\"" * Base.string(response_body_Dict["Server_say"]) * "\"" * "," * "\"" * "error" * "\"" * ":" * "\"" * Base.string(response_body_Dict["error"]) * "\"" * "," * "\"" * "time" * "\"" * ":" * "\"" * Base.string(response_body_Dict["time"]) * "\"" * "}";  # 使用星號*拼接字符串;
    # # 使用 Base.string() 函數拼接字符串;
    # response_body_String = Base.string(
    #     "{",
    #     "\"",
    #     "Target",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["request_Url"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "request_Path",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["request_Path"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "request_Url_Query_String",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["request_Url_Query_String"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "request_POST",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["request_POST"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "request_Authorization",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["request_Authorization"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "request_Cookie",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["request_Cookie"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "request_Nikename",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["request_Nikename"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "request_Password",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["request_Password"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "Server_Authorization",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["Server_Authorization"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "Server_say",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["Server_say"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "error",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["error"]),
    #     "\"",
    #     ",",
    #     "\"",
    #     "time",
    #     "\"",
    #     ":",
    #     "\"",
    #     Base.string(response_body_Dict["time"]),
    #     "\"",
    #     "}"
    # );
    # # println(response_body_String);

    return JSON_string;
end
# export JSONstring;  # 使用「export」接口對象，用來導出模塊中的成員;

# 自定義封裝的函數 JSONparse(JSON_string) 將 JSON 格式的字符串轉換爲一個 Julia 字典（Dict）或一維數組（Array）對象;
# 注意，字符串中不能有 JSON 對象 {} 的嵌套，例如，不可以傳入 {{}} 格式的字符串，可以有 2 級一維數組對象 [] 的嵌套，例如，可以傳入 [[]] 格式的字符串，還可以傳入 {[[]]} 或者 [[[]]]  或者 [{[[]]}] 格式都可以轉換;
function JSONparse(JSON_string::Core.String)::Core.Union{Base.Dict{Core.String, Core.Any}, Core.Array{Core.Any, 1}, Base.Vector{Core.Any}}
    # 將 Julia 字典（Dict）對象轉換為 JSON 字符串;
    # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象;
    # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;

    JSON_dict = Core.nothing;
    JSON_dict = JSON.parse(JSON_string);

    return JSON_dict;
end
# export JSONparse;  # 使用「export」接口對象，用來導出模塊中的成員;



# # 示例函數，處理從硬盤文檔讀取到的JSON對象數據，然後返回處理之後的結果JSON對象，使用雙冒號::固定變量允許類型;
# function do_data(data_Str::Core.String)::Core.String
#     println(data_Str);

#     request_form_value::Core.String = data_Str;  # 函數接收到的參數值;

#     response_data_Dict = Base.Dict{Core.String, Core.Any}();  # 函數返回值，聲明一個空字典;
#     response_data_String::Core.String = "";

#     # require_data_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Int64}()聲明一個空字典並指定數據類型;
#     require_data_Dict = Base.Dict();  # 聲明一個空字典，函數接收到的參數;
#     # # 使用自定義函數isStringJSON(request_form_value)判斷讀取到的請求體表單"form"數據 request_form_value 是否為JSON格式的字符串;
#     # if isStringJSON(request_form_value)
#         require_data_Dict = JSONparse(request_form_value);  # 使用自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
#         # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象;
#         # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
#     # else
#     #     require_data_Dict["Client_say"] = data_Str;  # Base.Dict(data_Str);  # Base.Dict("aa" => 1, "bb" => 2, "cc" => 3);
#     # end
#     println(require_data_Dict);

#     return_file_creat_time = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
#     # println(Base.string(Dates.now()))

#     response_data_Dict["Server_say"] = Base.string(request_form_value);  # Base.Dict("Julia_say" => Base.string(request_form_value));
#     response_data_Dict["time"] = Base.string(return_file_creat_time);  # Base.Dict("Julia_say" => Base.string(request_form_value), "time" => string(return_file_creat_time));
#     println(response_data_Dict);

#     response_data_String = "{\"Server_say\":\"" * Base.string(request_form_value) * "\",\"time\":\"" * Base.string(return_file_creat_time) * "\"}";  # 使用星號*拼接字符串;
#     # response_data_String = JSONstring(response_data_Dict);  # 使用自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
#     # response_data_String = JSON.json(response_data_Dict);  # 使用第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
#     println(response_data_String);

#     return response_data_String;
# end


# # 函數 monitor_file_do_Function() ;
# is_monitor = "";  # true, Boolean，用於判別是執行一次，還是啓動監聽服務，持續監聽目標文檔，false 值表示只執行一次，true 值表示啓動監聽服務器看守進程持續監聽;
# monitor_dir = "";  # 上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__，用於輸入傳值的媒介目錄 "../Intermediary/";
# monitor_file = "";  # 上一層路徑下的temp路徑 Base.Filesystem.joinpath(monitor_dir, "intermediary_write_NodeJS.txt")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於接收傳值的媒介文檔 "../Intermediary/intermediary_write_NodeJS.txt";
# output_dir = "";  # 上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__，用於輸出傳值的媒介目錄 "../Intermediary/";
# output_file = "";  # 上一層路徑下的temp路徑 Base.Filesystem.joinpath(output_dir, "intermediary_write_Julia.txt")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介文檔 "../Intermediary/intermediary_write_Julia.txt";
# temp_cache_IO_data_dir = "";  # 上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__，一個唯一的用於暫存傳入傳出數據的臨時媒介文件夾 "C:\Users\china\AppData\Local\Temp\temp_cache_IO_data_dir\";
# do_Function = Core.nothing;  # (argument) -> begin argument; end; 匿名函數對象，用於接收執行數據處理功能的函數 "do_data";
# to_executable = "";  # 上一層路徑下的Node.JS解釋器可執行檔路徑C:\nodejs\node.exe：Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node,exe")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的解釋器可執行文件 "..\\NodeJS\\node.exe"，Julia 解釋器可執行檔全名 println(Base.Sys.BINDIR)：C:\Julia 1.5.1\bin，;
# to_script = "";  # 上一層路徑下的 JavaScript 脚本路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的被調用的脚本文檔 "../js/Ruuter.js";
# time_sleep = "";  # Core.Float64(0.02)，監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒，自定義函數檢查輸入合規性 CheckString(delay, 'positive_integer');
# number_Worker_threads = "";  # Core.UInt8(1)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
# isMonitorThreadsOrProcesses = "";  # 0 || "0" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
# isDoTasksOrThreads = "";  # "Tasks" || "Multi-Threading"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;

# configFile::Core.String = Base.string(Base.Filesystem.joinpath(Base.string(Base.dirname(Base.dirname(Base.@__FILE__))), "config.txt"));  # "C:/Criss/jl/config.txt" # "/home/Criss/jl/config.txt";
# # configFile = Base.string(Base.replace(Base.string(Base.Filesystem.joinpath(Base.string(Base.dirname(Base.dirname(Base.@__FILE__))), "config.txt")), "\\" => "/"));  # "C:/Criss/jl/config.txt" # "/home/Criss/jl/config.txt";
# # configFile = Base.string(Base.Filesystem.joinpath(Base.string(Base.Filesystem.abspath("..")), "config.txt"));  # "C:/Criss/jl/config.txt" # "/home/Criss/jl/config.txt";
# # configFile = Base.string(Base.replace(Base.string(Base.Filesystem.joinpath(Base.string(Base.Filesystem.abspath("..")), "config.txt")), "\\" => "/"));  # "C:/Criss/jl/config.txt" # "/home/Criss/jl/config.txt";
# # print(configFile, "\n");
# # 控制臺傳參，通過 Base.ARGS 數組獲取從控制臺傳入的參數;
# # println(Base.typeof(Base.ARGS));
# # println(Base.ARGS);
# # println(Base.PROGRAM_FILE);  # 通過命令行啓動的，當前正在執行的 Julia 脚本文檔路徑;
# # 使用 Base.typeof("abcd") == String 方法判斷對象是否是一個字符串;
# # for X in Base.ARGS
# #     println(X)
# # end
# # for X ∈ Base.ARGS
# #     println(X)
# # end
# if Base.length(Base.ARGS) > 0
#     for i = 1:Base.length(Base.ARGS)
#         # println("Base.ARGS" * Base.string(i) * ": " * Base.string(Base.ARGS[i]));  # 通過 Base.ARGS 數組獲取從控制臺傳入的參數;
#         # 使用 Core.isa(Base.ARGS[i], Core.String) 函數判断「元素(变量实例)」是否属于「集合(变量类型集)」之间的关系，使用 Base.typeof(Base.ARGS[i]) <: Core.String 方法判断「集合」是否包含于「集合」之间的关系，或 Base.typeof(Base.ARGS[i]) === Core.String 方法判斷傳入的參數是否為 String 字符串類型;
#         if Core.isa(Base.ARGS[i], Core.String) && Base.ARGS[i] !== "" && Base.occursin("=", Base.ARGS[i])

#             ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();  # 聲明一個聯合類型的空1維數組;
#             # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
#             # 函數 Base.split(Base.ARGS[i], '=') 表示用等號字符'='分割字符串為數組;
#             for x in Base.split(Base.ARGS[i], '=')
#                 x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
#                 Base.push!(ARGSIArray, x);  # 使用 push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
#             end

#             if Base.length(ARGSIArray) > 1

#                 ARGSValue = "";
#                 # ARGSValue = join(Base.deleteat!(Base.deepcopy(ARGSIArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
#                 for j = 2:Base.length(ARGSIArray)
#                     if j === 2
#                         ARGSValue = ARGSValue * ARGSIArray[j];  # 使用星號*拼接字符串;
#                     else
#                         ARGSValue = ARGSValue * "=" * ARGSIArray[j];
#                     end
#                 end

#                 # try
#                 #     g = Base.Meta.parse(Base.string(ARGSIArray[1]) * "=" * Base.string(ARGSValue));  # 先使用 Base.Meta.parse() 函數解析字符串為代碼;
#                 #     Base.MainInclude.eval(g);  # 然後再使用 Base.MainInclude.eval() 函數執行字符串代碼語句;
#                 #     println(Base.string(ARGSIArray[1]) * " = " * "\$" * Base.string(ARGSIArray[1]));
#                 # catch err
#                 #     println(err);
#                 # end

#                 # if ARGSValue !== ""

#                     if ARGSIArray[1] === "configFile"
#                         if ARGSValue !== ""
#                             global configFile = ARGSValue;  # 指定的配置文檔（config.txt）保存路徑全名："C:/Criss/jl/config.txt" # "/home/Criss/jl/config.txt";
#                         else
#                             global configFile = "";
#                         end
#                         # print("Config file: ", configFile, "\n");
#                         break;
#                     end
#                 # end
#             end
#         end
#     end
# end

# # 讀取配置文檔（config.txt）裏的參數;
# # "/home/Criss/jl/config.txt"
# # "C:/Criss/jl/config.txt"
# if Core.isa(configFile, Core.String) && configFile !== ""

#     # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介文檔是否存在，如果不存在，則中止函數退出，如果存在則判斷操作權限，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
#     # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isfile(configFile) 方法判斷是否為文檔;
#     if !(Base.Filesystem.ispath(configFile) && Base.Filesystem.isfile(configFile))
#         println("Config file = [ " * Base.string(configFile) * " ] unrecognized.");
#         # println("用於輸入運行參數的配置文檔: " * configFile * " 無法識別或不存在.");
#         # return ["error", configFile, "document [ Config file = " * Base.string(configFile) * " ] unrecognized."];
#     elseif Base.stat(configFile).mode !== Core.UInt64(33206) && Base.stat(configFile).mode !== Core.UInt64(33279)
#         # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(configFile) 函數讀取文檔信息，使用 Base.stat(configFile).mode 方法提取文檔權限碼;
#         # println("用於輸入運行參數的配置文檔 [ " * configFile * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
#         try
#             # 使用 Base.Filesystem.chmod(configFile, mode=0o777; recursive=false) 函數修改文檔操作權限;
#             # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
#             Base.Filesystem.chmod(configFile, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
#             # println("文檔: " * configFile * " 操作權限成功修改爲 mode=0o777 .");

#             # 八進制值    說明
#             # 0o400      所有者可讀
#             # 0o200      所有者可寫
#             # 0o100      所有者可執行或搜索
#             # 0o40       群組可讀
#             # 0o20       群組可寫
#             # 0o10       群組可執行或搜索
#             # 0o4        其他人可讀
#             # 0o2        其他人可寫
#             # 0o1        其他人可執行或搜索
#             # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
#             # 數字	說明
#             # 7	可讀、可寫、可執行
#             # 6	可讀、可寫
#             # 5	可讀、可執行
#             # 4	唯讀
#             # 3	可寫、可執行
#             # 2	只寫
#             # 1	只可執行
#             # 0	沒有許可權
#             # 例如，八進制值 0o765 表示：
#             # 1) 、所有者可以讀取、寫入和執行該文檔；
#             # 2) 、群組可以讀和寫入該文檔；
#             # 3) 、其他人可以讀取和執行該文檔；
#             # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
#             # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

#         catch err
#             println("Config file = [ " * Base.string(configFile) * " ] change the permissions mode=0o777 fail.");
#             # println("用於輸入運行參數的配置文檔: " * configFile * " 無法修改操作權限爲 mode=0o777 .");
#             println(err);
#             # println(Base.typeof(err));
#             # return ["error", configFile, "document [ Config file = " * Base.string(configFile) * " ] change the permissions mode=0o777 fail."];
#         end
#     else
#     end

#     # 同步讀取，讀取用於輸入運行參數的配置文檔中的數據;
#     if Base.Filesystem.ispath(configFile) && Base.Filesystem.isfile(configFile)

#         if Base.stat(configFile).mode === Core.UInt64(33206) || Base.stat(configFile).mode === Core.UInt64(33279)

#             config_file_RIO = Core.nothing;  # ::IOStream;
#             try
#                 # line = Base.Filesystem.readlink(configFile);  # 讀取文檔中的一行數據;
#                 # Base.readlines — Function
#                 # Base.readlines(io::IO=stdin; keep::Bool=false)
#                 # Base.readlines(filename::AbstractString; keep::Bool=false)
#                 # Read all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading readline repeatedly with the same arguments and saving the resulting lines as a vector of strings.
#                 # for line in eachline(configFile)
#                 #     print(line);
#                 # end
#                 # Base.displaysize([io::IO]) -> (lines, columns)
#                 # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
#                 # Base.countlines — Function
#                 # Base.countlines(io::IO; eol::AbstractChar = '\n')
#                 # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.

#                 # 在 Base.open() 函數中，還可以調用函數;
#                 # Base.open(Base.readline, "sdy.txt");
#                 # 也可以調用自定義函數;
#                 # readFunc(s::IOStream) = Base.read(s, Char);
#                 # Base.open(readFunc, "sdy.txt");
#                 # 還可以像Python中的 with open...as 的用法一樣打開文件;
#                 # Base.open("sdy.txt","r") do stream
#                 #     for line in eachline(stream)
#                 #         println(line);
#                 #     end
#                 # end
#                 # 也可以將上述程序定義成函數再用open操作;
#                 # function readFunc2(stream)
#                 #     for line in eachline(stream)
#                 #         println(line);
#                 #     end
#                 # end
#                 # Base.open(readFunc2, "sdy.txt");

#                 global config_file_RIO = Base.open(configFile, "r");
#                 # nb = countlines(config_file_RIO);  # 計算文檔中數據行數;
#                 # seekstart(config_file_RIO);  # 指針返回文檔的起始位置;

#                 # Keyword	Description				Default
#                 # read		open for reading		!write
#                 # write		open for writing		truncate | append
#                 # create	create if non-existent	!read & write | truncate | append
#                 # truncate	truncate to zero size	!read & write
#                 # append	seek to end				false

#                 # Mode	Description						Keywords
#                 # r		read							none
#                 # w		write, create, truncate			write = true
#                 # a		write, create, append			append = true
#                 # r+	read, write						read = true, write = true
#                 # w+	read, write, create, truncate	truncate = true, read = true
#                 # a+	read, write, create, append		append = true, read = true

#                 # io = IOBuffer("JuliaLang is a GitHub organization");
#                 # Base.read(io, Core.String);
#                 # "JuliaLang is a GitHub organization";
#                 # Base.read(filename::AbstractString, Core.String);
#                 # Read the entire contents of a file as a string.
#                 # Base.read(s::IOStream, nb::Integer; all=true);
#                 # Read at most nb bytes from s, returning a Vector{UInt8} of the bytes read.
#                 # If all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.
#                 # Base.read(command::Cmd)
#                 # Run command and return the resulting output as an array of bytes.
#                 # Base.read(command::Cmd, Core.String)
#                 # Run command and return the resulting output as a String.
#                 # Base.read!(stream::IO, array::Union{Array, BitArray})
#                 # Base.read!(filename::AbstractString, array::Union{Array, BitArray})
#                 # Read binary data from an I/O stream or file, filling in array.
#                 # Base.readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))
#                 # Read at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.
#                 # Base.readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)
#                 # Read at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.
#                 # If all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.

#                 # 使用 isreadable(io) 函數判斷文檔是否可讀;
#                 if Base.isreadable(config_file_RIO)
#                     println("Config file = " * Base.string(configFile));
#                     # Base.read!(filename::AbstractString, array::Union{Array, BitArray});  一次全部讀入文檔中的數據，將讀取到的數據解析為二進制數組類型;
#                     # data_Str::Core.String = "";
#                     # data_Str = Base.read(config_file_RIO, Core.String);  # Base.read(filename::AbstractString, Core.String) 一次全部讀入文檔中的數據，將讀取到的數據解析為字符串類型 "utf-8" ;

#                     # lines = String[];
#                     # lines = Base.readlines(config_file_RIO; keep=false);  # 逐橫向列讀入文檔中的數據，將讀取到的數據解析為字符串類型 "utf-8" ;  # Base.readlines(io::IO=stdin; keep::Bool=false);Base.readlines(filename::AbstractString; keep::Bool=false);
#                     # for line in lines
#                     #     println(line);
#                     # end
#                     # lines = Core.nothing;

#                     line_I::Core.UInt8 = Core.UInt8(0);
#                     # for line in eachline(configFile)
#                     for line in eachline(config_file_RIO)
#                         # println(line);

#                         line_I = line_I + Core.UInt8(1);
#                         line_Key::Core.String = "";
#                         line_Value::Core.String = "";

#                         if Core.isa(line, Core.String) && line !== ""

#                             # 判斷字符串是否包含換行符號（\r\n）;
#                             if Base.occursin("\r\n", line)
#                                 line = Base.string(Base.replace(Base.string(line), "\r\n" => ""));  # 刪除行尾的換行符（\r\n）;
#                             elseif Base.occursin("\r", line)
#                                 line = Base.string(Base.replace(Base.string(line), "\r" => ""));  # 刪除行尾的換行符（\r）;
#                             elseif Base.occursin("\n", line)
#                                 line = Base.string(Base.replace(Base.string(line), "\n" => ""));  # 刪除行尾的換行符（\n）;
#                             else
#                                 # line = Base.string(Base.strip(Base.string(line), [' ']));  # 刪除行首尾的空格字符（' '）;
#                             end

#                             line = Base.string(Base.strip(Base.string(line), [' ']));  # 刪除行首尾的空格字符（' '）;
    
#                             # 判斷字符串是否含有等號字符（=）連接符（Key=Value），若含有等號字符（=），則以等號字符（=）分割字符串;
#                             if Base.occursin("=", line)

#                                 ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();  # 聲明一個聯合類型的空1維數組;
#                                 # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
#                                 # 函數 Base.split(line, '=') 表示用等號字符'='分割字符串為數組;
#                                 for x in Base.split(line, '=')
#                                     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
#                                     Base.push!(ARGSIArray, x);  # 使用 push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
#                                 end

#                                 if Base.length(ARGSIArray) === 1
#                                     if Core.isa(ARGSIArray[1], Core.String) && ARGSIArray[1] !== ""
#                                         line_Key = Base.string(Base.strip(Base.string(ARGSIArray[1]), [' ']));
#                                     end
#                                 end

#                                 if Base.length(ARGSIArray) > 1

#                                     ARGSValue = "";
#                                     # ARGSValue = join(Base.deleteat!(Base.deepcopy(ARGSIArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
#                                     for j = 2:Base.length(ARGSIArray)
#                                         if j === 2
#                                             ARGSValue = ARGSValue * ARGSIArray[j];  # 使用星號*拼接字符串;
#                                         else
#                                             ARGSValue = ARGSValue * "=" * ARGSIArray[j];
#                                         end
#                                     end

#                                     # try
#                                     #     g = Base.Meta.parse(Base.string(ARGSIArray[1]) * "=" * Base.string(ARGSValue));  # 先使用 Base.Meta.parse() 函數解析字符串為代碼;
#                                     #     Base.MainInclude.eval(g);  # 然後再使用 Base.MainInclude.eval() 函數執行字符串代碼語句;
#                                     #     println(Base.string(ARGSIArray[1]) * " = " * "\$" * Base.string(ARGSIArray[1]));
#                                     # catch err
#                                     #     println(err);
#                                     # end

#                                     if Core.isa(ARGSIArray[1], Core.String) && ARGSIArray[1] !== ""
#                                         line_Key = Base.string(Base.strip(Base.string(ARGSIArray[1]), [' ']));  # 刪除字符串首尾的空格字符（' '）;
#                                     end

#                                     if Core.isa(ARGSValue, Core.String) && ARGSValue !== ""
#                                         line_Value = Base.string(Base.strip(Base.string(ARGSValue), [' ']));  # 刪除字符串首尾的空格字符（' '）;
#                                     end
#                                 end
#                             else
#                                 line_Value = Base.string(line);
#                             end
#                             # println(line_Key);
#                             # println(line_Value);

#                             # 接收當 interface_Function = Interface_File_Monitor 時的傳入參數值;
#                             # 用於接收執行功能的函數 do_Function = "do_data"; "do_Request";
#                             if line_Key === "interface_Function"

#                                 global interface_Function_name_str = line_Value;
#                                 # global interface_Function = Base.Meta.parse(line_Value);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;

#                                 if line_Value === "file_Monitor"
#                                     global interface_Function = monitor_file_Run;
#                                     global interface_Function_name_str = "interface_File_Monitor";
        
#                                     global do_Function_name_str_data = "do_data";
#                                     global do_Function_data = do_data;
#                                     # global do_Function = do_data;
#                                 end

#                                 if line_Value === "TCP_Server"
#                                     global interface_Function = TCP_Server_Run;
#                                     global interface_Function_name_str = "interface_TCP_Server";
        
#                                     global do_Function_name_str_Request = "do_Request";
#                                     global do_Function_Request = do_Request;
#                                     # global do_Function = do_Request;
#                                 end

#                                 if line_Value === "http_Server"
#                                     global interface_Function = http_Server_Run;
#                                     global interface_Function_name_str = "interface_http_Server";
        
#                                     global do_Function_name_str_Request = "do_Request";
#                                     global do_Function_Request = do_Request;
#                                     # global do_Function = do_Request;
#                                 end

#                                 if line_Value === "TCP_Client"
#                                     global interface_Function = TCP_Client;
#                                     global interface_Function_name_str = "interface_TCP_Client";
        
#                                     global do_Function_name_str_Response = "do_Response";
#                                     global do_Function_Response = do_Response;
#                                     # global do_Function = do_Response;
#                                 end

#                                 if line_Value === "http_Client"
#                                     global interface_Function = http_Client;
#                                     global interface_Function_name_str = "interface_http_Client";
        
#                                     global do_Function_name_str_Response = "do_Response";
#                                     global do_Function_Response = do_Response;
#                                     # global do_Function = do_Response;
#                                 end

#                                 # print("interface Function: ", interface_Function_name_str, "\n");
#                                 # print("do Function: ", do_Function_name_str_Request, "\n");
#                                 continue;
#                             end

#                             if line_Key === "is_monitor"
#                                 # global is_monitor = Base.Meta.parse(line_Value);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                                 global is_monitor = Base.parse(Bool, line_Value);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換為布爾型(Bool)的變量，用於判別執行一次還是持續監聽的開關 "true / false";
#                                 # print("is monitor: ", is_monitor, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "monitor_file"
#                                 global monitor_file = line_Value;  # 用於接收傳值的媒介文檔 "../temp/intermediary_write_Node.txt";
#                                 # print("monitor file: ", monitor_file, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "monitor_dir"
#                                 global monitor_dir = line_Value;  # 用於輸入傳值的媒介目錄 "../temp/"，當前路徑 Base.@__DIR__;
#                                 # print("monitor dir: ", monitor_dir, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "output_dir"
#                                 global output_dir = line_Value;  # 用於輸出傳值的媒介目錄 "../temp/"，當前路徑 Base.@__DIR__;
#                                 # print("output dir: ", output_dir, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "output_file"
#                                 global output_file = line_Value;  # 用於輸出傳值的媒介文檔 "../temp/intermediary_write_Julia.txt";
#                                 # print("output file: ", output_file, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "temp_cache_IO_data_dir"
#                                 global temp_cache_IO_data_dir = line_Value;  # 一個唯一的用於暫存傳入傳出數據的臨時媒介文件夾 "C:\Users\china\AppData\Local\Temp\temp_NodeJS_cache_IO_data\"，當前路徑 Base.@__DIR__;
#                                 # print("Temporary cache IO data directory: ", temp_cache_IO_data_dir, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "to_executable"
#                                 global to_executable = line_Value;  # 用於對返回數據執行功能的解釋器可執行文件 "C:\\NodeJS\\nodejs\\node.exe";
#                                 # print("to executable: ", to_executable, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "to_script"
#                                 global to_script = line_Value;  # 用於對返回數據執行功能的被調用的脚本文檔 "../js/test.js";
#                                 # print("to script: ", to_script, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "time_sleep"
#                                 # CheckString(line_Value, 'arabic_numerals');  # 自定義函數檢查輸入合規性;
#                                 # global is_monitor = Base.Meta.parse(line_Value);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                                 global time_sleep = Base.parse(Core.Float64, line_Value);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換無符號的長整型(Core.UInt64)類型的變量，監聽文檔輪詢延遲時長，單位毫秒 id = setInterval(function, delay);
#                                 # print("time sleep: ", time_sleep, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "number_Worker_threads"
#                                 # CheckString(line_Value, 'arabic_numerals');  # 自定義函數檢查輸入合規性;
#                                 # global is_monitor = Base.Meta.parse(line_Value);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                                 global number_Worker_threads = Base.parse(UInt8, line_Value);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換無符號的短整型(UInt8)類型的變量，os.cpus().length 創建子進程 worker 數目等於物理 CPU 數目，使用"os"庫的方法獲取本機 CPU 數目;
#                                 # print("number Worker threads: ", number_Worker_threads, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "isMonitorThreadsOrProcesses"
#                                 global isMonitorThreadsOrProcesses = line_Value;  # 0 || "0" || "Multi-Threading" || "Multi-Processes"; # 選擇監聽動作的函數的并發層級（多協程、多綫程、多進程）;
#                                 # print("isMonitorThreadsOrProcesses: ", isMonitorThreadsOrProcesses, "\n");
#                                 # 當 isMonitorThreadsOrProcesses = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
#                                 # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
#                                 # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
#                                 # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
#                                 # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;
#                                 continue;
#                             end
        
#                             if line_Key === "isDoTasksOrThreads"
#                                 global isDoTasksOrThreads = line_Value;  # "Tasks" || "Multi-Threading"; # 選擇具體執行功能的函數的并發層級（多協程、多綫程、多進程）;
#                                 # print("isDoTasksOrThreads: ", isDoTasksOrThreads, "\n");
#                                 # 當 isDoTasksOrThreads = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
#                                 # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
#                                 # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
#                                 continue;
#                             end
        
#                             if line_Key === "do_Function"
        
#                                 if line_Value === "do_data"
        
#                                     # 使用函數 Base.@isdefined(do_data) 判斷 do_data 變量是否已經被聲明過;
#                                     if Base.@isdefined(do_data)
#                                         # 使用 Core.isa(do_data, Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_data) <: Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_data) <: Function 方法判別 do_data 變量的類型是否包含於函數Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
#                                         # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數Function類型集:
#                                         # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
#                                         if Base.typeof(do_data) <: Function
#                                             global do_Function = do_data;
#                                         else
#                                             println("傳入的參數，指定的變量「" * line_Value * "」不是一個函數類型的變量.");
#                                             # global do_Function = Core.nothing;  # 置空;
#                                             global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                         end
#                                     else
#                                         println("傳入的參數，指定的變量「" * line_Value * "」未定義.");
#                                         # global do_Function = Core.nothing;  # 置空;
#                                         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     end
        
#                                     # try
#                                     #     if length(methods(do_data)) > 0
#                                     #         global do_Function = do_data;
#                                     #     else
#                                     #         # global do_Function = Core.nothing;  # 置空;
#                                     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     #     end
#                                     # catch err
#                                     #     # println(err);
#                                     #     # println(Base.typeof(err));
#                                     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷 err 的類型是否爲 Core.UndefVarError;
#                                     #     if Core.isa(err, Core.UndefVarError)
#                                     #         println(err.var, " not defined.");
#                                     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
#                                     #         # global do_Function = Core.nothing;  # 置空;
#                                     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     #     else
#                                     #         println(err);
#                                     #     end
#                                     # finally
#                                     #     # global do_Function = Core.nothing;  # 置空;
#                                     #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     # end
#                                 end
        
#                                 if line_Value === "do_Request"
        
#                                     # 使用函數 Base.@isdefined(do_Request) 判斷 do_Request 變量是否已經被聲明過;
#                                     if Base.@isdefined(do_Request)
#                                         # 使用 Core.isa(do_Request, Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_Request) <: Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_Request) <: Function 方法判別 do_Request 變量的類型是否包含於函數Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
#                                         # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數Function類型集:
#                                         # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
#                                         if Base.typeof(do_Request) <: Function
#                                             global do_Function = do_Request;
#                                         else
#                                             println("傳入的參數，指定的變量「" * line_Value * "」不是一個函數類型的變量.");
#                                             # global do_Function = Core.nothing;  # 置空;
#                                             global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                         end
#                                     else
#                                         println("傳入的參數，指定的變量「" * line_Value * "」未定義.");
#                                         # global do_Function = Core.nothing;  # 置空;
#                                         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     end
        
#                                     # try
#                                     #     if length(methods(do_Request)) > 0
#                                     #         global do_Function = do_Request;
#                                     #     else
#                                     #         # global do_Function = Core.nothing;  # 置空;
#                                     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     #     end
#                                     # catch err
#                                     #     # println(err);
#                                     #     # println(Base.typeof(err));
#                                     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷 err 的類型是否爲 Core.UndefVarError;
#                                     #     if Core.isa(err, Core.UndefVarError)
#                                     #         println(err.var, " not defined.");
#                                     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
#                                     #         # global do_Function = Core.nothing;  # 置空;
#                                     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     #     else
#                                     #         println(err);
#                                     #     end
#                                     # finally
#                                     #     # global do_Function = Core.nothing;  # 置空;
#                                     #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     # end
#                                 end
        
#                                 if line_Value === "do_Response"
        
#                                     # 使用函數 Base.@isdefined(do_Response) 判斷 do_Response 變量是否已經被聲明過;
#                                     if Base.@isdefined(do_Response)
#                                         # 使用 Core.isa(do_Response, Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_Response) <: Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_Response) <: Function 方法判別 do_Response 變量的類型是否包含於函數Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
#                                         # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數Function類型集:
#                                         # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
#                                         if Base.typeof(do_Response) <: Function
#                                             global do_Function = do_Response;
#                                         else
#                                             println("傳入的參數，指定的變量「" * line_Value * "」不是一個函數類型的變量.");
#                                             # global do_Function = Core.nothing;  # 置空;
#                                             global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                         end
#                                     else
#                                         println("傳入的參數，指定的變量「" * line_Value * "」未定義.");
#                                         # global do_Function = Core.nothing;  # 置空;
#                                         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     end
        
#                                     # try
#                                     #     if length(methods(do_Response)) > 0
#                                     #         global do_Function = do_Response;
#                                     #     else
#                                     #         # global do_Function = Core.nothing;  # 置空;
#                                     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     #     end
#                                     # catch err
#                                     #     # println(err);
#                                     #     # println(Base.typeof(err));
#                                     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷 err 的類型是否爲 Core.UndefVarError;
#                                     #     if Core.isa(err, Core.UndefVarError)
#                                     #         println(err.var, " not defined.");
#                                     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
#                                     #         # global do_Function = Core.nothing;  # 置空;
#                                     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     #     else
#                                     #         println(err);
#                                     #     end
#                                     # finally
#                                     #     # global do_Function = Core.nothing;  # 置空;
#                                     #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                     # end
#                                 end
        
#                                 # if line_Value !== "do_data" && line_Value !== "do_data"
#                                 #     # global do_Function = Core.nothing;  # 置空;
#                                 #     global do_Function = (argument) -> argument;  # 匿名函數，直接返回傳入參數做返回值;
#                                 # end
        
#                                 # print("do Function: ", do_Function, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "host"
#                                 global host = line_Value;  # 用於輸出傳值的媒介目錄 "../temp/";
#                                 if Base.string(host) === "::0" || Base.string(host) === "::1" || Base.string(host) === "::" || Base.string(host) === "0" || Base.string(host) === "1"
#                                     # || CheckIP(Base.string(host)) === "IPv6"
#                                     global host = Sockets.IPv6(host);  # Sockets.IPv6(0);  # ::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv6(0);  # "::0" or "::1" or "localhost"; 監聽主機域名 Host domain name;
#                                 elseif Base.string(host) === "0.0.0.0" || Base.string(host) === "127.0.0.1"
#                                     # || CheckIP(Base.string(host)) === "IPv4"
#                                     global host = Sockets.IPv4(host);  # Sockets.IPv4("0.0.0.0");  # ::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv4("0.0.0.0");  # "0.0.0.0" or "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
#                                 elseif Base.string(host) === "localhost"
#                                     global host = Sockets.IPv6(0);  # ::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv4("0.0.0.0");  # "::1";  # "0.0.0.0" or "localhost"; 監聽主機域名 Host domain name;
#                                 else
#                                     println("Error: host IP [ " * Base.string(host) * " ] unrecognized.");
#                                     # return false
#                                 end
#                                 # print("host: ", Base.string(host), "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "IPVersion"
#                                 global IPVersion = line_Value;  # "IPv6"、"IPv4";
#                                 # print("IP Version: ", IPVersion, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "port"
#                                 global port = line_Value;  # Core.UInt8(5000),  # 0 ~ 65535， 監聽埠號（端口）;
#                                 global port = Base.parse(Core.UInt64, port);
#                                 # print("port: ", Base.string(port), "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "key"
#                                 if Base.string(line_Value) === "nothing" || Base.string(line_Value) === ""
#                                     global key = "";
#                                     # global key = Core.nothing;
#                                 else
#                                     global key = Base.string(line_Value);  # 用於接收傳值的媒介文檔 "../temp/intermediary_write_Node.txt";
#                                 end
#                                 # print("key: ", key, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "session"
#                                 # global session = line_Value;  # 用於輸入傳值的媒介目錄 "../temp/";
#                                 # g = Base.Meta.parse(Base.string(line_Key) * Base.string(line_Value));
#                                 g = Base.Meta.parse("session=" * Base.string(line_Value));
#                                 Base.MainInclude.eval(g);
#                                 # print("session: ", session, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "isConcurrencyHierarchy"
#                                 global isConcurrencyHierarchy = line_Value;  # "Tasks" || "Multi-Threading" || "Multi-Processes"; # 選擇具體執行功能的函數的并發層級（多協程、多綫程、多進程）;
#                                 # print("isConcurrencyHierarchy: ", isConcurrencyHierarchy, "\n");
#                                 # 當 isConcurrencyHierarchy = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
#                                 # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
#                                 # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
#                                 # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
#                                 # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;
#                                 continue;
#                             end
        
#                             if line_Key === "Authorization"
#                                 global Authorization = line_Value;  # 客戶端發送的請求頭中的 Authorizater 參數值;
#                                 # print("Authorization: ", Authorization, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "Cookie"
#                                 global Cookie = line_Value;  # 客戶端發送的請求頭中的 Cookie 參數值;
#                                 # print("Cookie: ", Cookie, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "URL"
#                                 global URL = line_Value;
#                                 # print("URL: ", URL, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "proxy"
#                                 global proxy = line_Value;
#                                 # print("Proxy: ", proxy, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "Referrer"
#                                 global Referrer = line_Value;
#                                 # print("Referrer: ", Referrer, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "query"
#                                 # https://github.com/JuliaIO/JSON.jl
#                                 # 導入第三方擴展包「JSON」，用於轉換JSON字符串為字典 Base.Dict 對象，需要在控制臺先安裝第三方擴展包「JSON」：julia> using Pkg; Pkg.add("JSON") 成功之後才能使用;
#                                 # s = "{\"a_number\" : 5.0, \"an_array\" : [\"string\", 9]}"
#                                 # j = JSON.parse(s)
#                                 # Dict{AbstractString,Any} with 2 entries:
#                                 #     "an_array" => {"string",9}
#                                 #     "a_number" => 5.0
#                                 global query = JSON.parse(line_Value);
#                                 # print("query: ", line_Value, "\n");
#                                 # print("query: ", "\n");
#                                 # print(query);
#                                 continue;
#                             end
        
#                             if line_Key === "readtimeout"
#                                 # CheckString(line_Value, 'arabic_numerals');  # 自定義函數檢查輸入合規性;
#                                 # global is_monitor = Base.Meta.parse(line_Value);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                                 global readtimeout = Base.parse(Core.Int, line_Value);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換無符號的短整型(Int)類型的變量，os.cpus().length 創建子進程 worker 數目等於物理 CPU 數目，使用"os"庫的方法獲取本機 CPU 數目;
#                                 # print("Read Timeout: ", readtimeout, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "connecttimeout"
#                                 # CheckString(line_Value, 'arabic_numerals');  # 自定義函數檢查輸入合規性;
#                                 # global is_monitor = Base.Meta.parse(line_Value);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                                 global connect_timeout = Base.parse(Core.Int, line_Value);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換無符號的短整型(Int)類型的變量，os.cpus().length 創建子進程 worker 數目等於物理 CPU 數目，使用"os"庫的方法獲取本機 CPU 數目;
#                                 # print("Connect Timeout: ", connect_timeout, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "verbose"
#                                 # global verbose = Base.Meta.parse(line_Value);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                                 global verbose = Base.parse(Core.Bool, line_Value);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換為布爾型(Bool)的變量，用於判別執行一次還是持續監聽的開關 "true / false";
#                                 # print("verbose: ", verbose, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "requestFrom"
#                                 global requestFrom = line_Value;  # 客戶端發送的請求頭中的 From 參數值;
#                                 # print("requestFrom: ", requestFrom, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "requestPath"
#                                 global requestPath = line_Value;
#                                 # print("requestPath: ", requestPath, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "requestMethod"
#                                 global requestMethod = line_Value;
#                                 # print("requestMethod: ", requestMethod, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "requestProtocol"
#                                 global requestProtocol = line_Value;
#                                 # print("requestProtocol: ", requestProtocol, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "postData"
#                                 # global postData = line_Value;  # 用於輸入傳值的媒介目錄 "../temp/";
#                                 # g = Base.Meta.parse(Base.string(line_Key) * Base.string(line_Value));
#                                 g = Base.Meta.parse("postData=" * Base.string(line_Value));
#                                 Base.MainInclude.eval(g);
#                                 # print("postData: ", postData, "\n");
#                                 continue;
#                             end
        
#                             if line_Key === "webPath"
#                                 global webPath = line_Value;  # 用於輸入服務器的根目錄 "../";
#                                 # print("webPath: ", webPath, "\n");
#                                 continue;
#                             end
#                         end
#                     end
#                 end

#                 # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
#                 # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
#                 # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
#                 # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
#                 # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
#                 # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
#                 # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
#                 # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
#                 # Base.ismarked(io);  # Return true if stream s is marked;
#                 # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
#                 # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
#                 # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
#                 # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
#                 # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
#                 # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
#                 # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
#                 # Base.close(io);  # 關閉緩衝區;
#                 # println(a)
#                 # Base.redirect_stdout — Function
#                 # redirect_stdout([stream]) -> (rd, wr)
#                 # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
#                 # If called with the optional stream argument, then returns stream itself.
#                 # Base.redirect_stdout — Method
#                 # redirect_stdout(f::Function, stream)
#                 # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
#                 # Base.redirect_stderr — Function
#                 # redirect_stderr([stream]) -> (rd, wr)
#                 # Like redirect_stdout, but for stderr.
#                 # Base.redirect_stderr — Method
#                 # redirect_stderr(f::Function, stream)
#                 # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
#                 # Base.redirect_stdin — Function
#                 # redirect_stdin([stream]) -> (rd, wr)
#                 # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
#                 # Base.redirect_stdin — Method
#                 # redirect_stdin(f::Function, stream)
#                 # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

#             catch err

#                 if Core.isa(err, Core.InterruptException)

#                     print("\n");
#                     # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
#                     # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
#                     println("[ Ctrl ] + [ c ] received, will be return Function.");

#                     # println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
#                     # println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

#                     # Base.exit(0);
#                     return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, will be return Function."];

#                 else

#                     println("Config file = [ " * Base.string(configFile) * " ] not read.");
#                     # println("從用於輸入運行參數的配置文檔: " * configFile * " 中讀取數據發生錯誤.");
#                     println(err);
#                     # println(err.msg);
#                     # println(Base.typeof(err));
#                     # return ["error", configFile, "document [ Config file = " * Base.string(configFile) * " ] not read."];
#                 end

#             finally
#                 Base.close(config_file_RIO);
#             end

#             config_file_RIO = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
#             # Base.GC.gc();  # 内存回收函數 gc();
#         end

#         # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
#         # Base.sleep(seconds)  Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of 0.001.

#         # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
#         # println(Base.string(nowTime));
#     end
# end

# # 控制臺傳參，通過 Base.ARGS 數組獲取從控制臺傳入的參數;
# # println(Base.PROGRAM_FILE);  # 通過命令行啓動的，當前正在執行的 Julia 脚本文檔路徑;
# # for X in Base.ARGS
# #     println(X)
# # end
# # for X ∈ Base.ARGS
# #     println(X)
# # end
# if Base.length(Base.ARGS) > 0
#     for i = 1:Base.length(Base.ARGS)
#         # println("Base.ARGS" * Base.string(i) * ": " * Base.string(Base.ARGS[i]));  # 通過 Base.ARGS 數組獲取從控制臺傳入的參數;
#         # 使用 Core.isa(Base.ARGS[i], Core.String) 函數判断「元素(变量实例)」是否属于「集合(变量类型集)」之间的关系，使用 Base.typeof(Base.ARGS[i]) <: Core.String 方法判断「集合」是否包含于「集合」之间的关系，或 Base.typeof(Base.ARGS[i]) === Core.String 方法判斷傳入的參數是否為 String 字符串類型;
#         if Core.isa(Base.ARGS[i], Core.String) && Base.ARGS[i] !== "" && Base.occursin("=", Base.ARGS[i])

#             ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();  # 聲明一個聯合類型的空1維數組;
#             # 函數 Base.split(Base.ARGS[i], '=') 表示用等號字符'='分割字符串為數組;
#             for x in Base.split(Base.ARGS[i], '=')
#                 x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
#                 Base.push!(ARGSIArray, x);  # 使用 push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
#             end

#             if Base.length(ARGSIArray) > 1

#                 ARGSValue = "";
#                 # ARGSValue = join(Base.deleteat!(Base.deepcopy(ARGSIArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
#                 for j = 2:Base.length(ARGSIArray)
#                     if j === 2
#                         ARGSValue = ARGSValue * ARGSIArray[j];  # 使用星號*拼接字符串;
#                     else
#                         ARGSValue = ARGSValue * "=" * ARGSIArray[j];
#                     end
#                 end

#                 # try
#                 #     g = Base.Meta.parse(Base.string(ARGSIArray[1]) * "=" * Base.string(ARGSValue));  # 先使用 Base.Meta.parse() 函數解析字符串為代碼;
#                 #     Base.MainInclude.eval(g);  # 然後再使用 Base.MainInclude.eval() 函數執行字符串代碼語句;
#                 #     println(Base.string(ARGSIArray[1]) * " = " * "\$" * Base.string(ARGSIArray[1]));
#                 # catch err
#                 #     println(err);
#                 # end

#                 if ARGSValue !== ""

#                     if ARGSIArray[1] === "is_monitor"
#                         # global is_monitor = Base.Meta.parse(ARGSValue);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                         global is_monitor = Base.parse(Core.Bool, ARGSValue);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換為布爾型(Bool)的變量，用於判別執行一次還是持續監聽的開關 "true / false";
#                         # print("is monitor: ", is_monitor, "\n");
#                     end

#                     if ARGSIArray[1] === "monitor_file"
#                         global monitor_file = ARGSValue;  # 用於接收傳值的媒介文檔 "../temp/intermediary_write_Node.txt";
#                         # print("monitor file: ", monitor_file, "\n");
#                     end

#                     if ARGSIArray[1] === "monitor_dir"
#                         global monitor_dir = ARGSValue;  # 用於輸入傳值的媒介目錄 "../temp/"，當前路徑 Base.@__DIR__;
#                         # print("monitor dir: ", monitor_dir, "\n");
#                     end

#                     if ARGSIArray[1] === "output_dir"
#                         global output_dir = ARGSValue;  # 用於輸出傳值的媒介目錄 "../temp/"，當前路徑 Base.@__DIR__;
#                         # print("output dir: ", output_dir, "\n");
#                     end

#                     if ARGSIArray[1] === "output_file"
#                         global output_file = ARGSValue;  # 用於輸出傳值的媒介文檔 "../temp/intermediary_write_Julia.txt";
#                         # print("output file: ", output_file, "\n");
#                     end

#                     if ARGSIArray[1] === "temp_cache_IO_data_dir"
#                         global temp_cache_IO_data_dir = ARGSValue;  # 一個唯一的用於暫存傳入傳出數據的臨時媒介文件夾 "C:\Users\china\AppData\Local\Temp\temp_NodeJS_cache_IO_data\"，當前路徑 Base.@__DIR__;
#                         # print("Temporary cache IO data directory: ", temp_cache_IO_data_dir, "\n");
#                     end

#                     if ARGSIArray[1] === "to_executable"
#                         global to_executable = ARGSValue;  # 用於對返回數據執行功能的解釋器可執行文件 "C:\\NodeJS\\nodejs\\node.exe";
#                         # print("to executable: ", to_executable, "\n");
#                     end

#                     if ARGSIArray[1] === "to_script"
#                         global to_script = ARGSValue;  # 用於對返回數據執行功能的被調用的脚本文檔 "../js/test.js";
#                         # print("to script: ", to_script, "\n");
#                     end

#                     if ARGSIArray[1] === "time_sleep"
#                         # CheckString(ARGSValue, 'arabic_numerals');  # 自定義函數檢查輸入合規性;
#                         # global is_monitor = Base.Meta.parse(ARGSValue);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                         global time_sleep = Base.parse(Core.Float64, ARGSValue);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換無符號的長整型(Core.UInt64)類型的變量，監聽文檔輪詢延遲時長，單位毫秒 id = setInterval(function, delay);
#                         # print("time sleep: ", time_sleep, "\n");
#                     end

#                     if ARGSIArray[1] === "number_Worker_threads"
#                         # CheckString(ARGSValue, 'arabic_numerals');  # 自定義函數檢查輸入合規性;
#                         # global is_monitor = Base.Meta.parse(ARGSValue);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                         global number_Worker_threads = Base.parse(UInt8, ARGSValue);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換無符號的短整型(UInt8)類型的變量，os.cpus().length 創建子進程 worker 數目等於物理 CPU 數目，使用"os"庫的方法獲取本機 CPU 數目;
#                         # print("number Worker threads: ", number_Worker_threads, "\n");
#                     end

#                     if ARGSIArray[1] === "do_Function"

#                         if ARGSValue === "do_data"

#                             # 使用函數 Base.@isdefined(do_data) 判斷 do_data 變量是否已經被聲明過;
#                             if Base.@isdefined(do_data)
#                                 # 使用 Core.isa(do_data, Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_data) <: Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_data) <: Function 方法判別 do_data 變量的類型是否包含於函數Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
#                                 # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數Function類型集:
#                                 # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
#                                 if Base.typeof(do_data) <: Function
#                                     global do_Function = do_data;
#                                 else
#                                     println("傳入的參數，指定的變量「" * ARGSValue * "」不是一個函數類型的變量.");
#                                     # global do_Function = Core.nothing;  # 置空;
#                                     global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                 end
#                             else
#                                 println("傳入的參數，指定的變量「" * ARGSValue * "」未定義.");
#                                 # global do_Function = Core.nothing;  # 置空;
#                                 global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             end

#                             # try
#                             #     if length(methods(do_data)) > 0
#                             #         global do_Function = do_data;
#                             #     else
#                             #         # global do_Function = Core.nothing;  # 置空;
#                             #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             #     end
#                             # catch err
#                             #     # println(err);
#                             #     # println(Base.typeof(err));
#                             #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷 err 的類型是否爲 Core.UndefVarError;
#                             #     if Core.isa(err, Core.UndefVarError)
#                             #         println(err.var, " not defined.");
#                             #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
#                             #         # global do_Function = Core.nothing;  # 置空;
#                             #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             #     else
#                             #         println(err);
#                             #     end
#                             # finally
#                             #     # global do_Function = Core.nothing;  # 置空;
#                             #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             # end
#                         end

#                         # if ARGSValue !== "do_data" && ARGSValue !== "do_data"
#                         #     # global do_Function = Core.nothing;  # 置空;
#                         #     global do_Function = (argument) -> argument;  # 匿名函數，直接返回傳入參數做返回值;
#                         # end

#                         # print("do Function: ", do_Function, "\n");
#                     end

#                     if ARGSIArray[1] === "isMonitorThreadsOrProcesses"
#                         global isMonitorThreadsOrProcesses = ARGSValue;  # 0 || "0" || "Multi-Threading" || "Multi-Processes"; # 選擇監聽動作的函數的并發層級（多協程、多綫程、多進程）;
#                         # print("isMonitorThreadsOrProcesses: ", isMonitorThreadsOrProcesses, "\n");
#                         # 當 isMonitorThreadsOrProcesses = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
#                         # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
#                         # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
#                         # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
#                         # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;
#                     end

#                     if ARGSIArray[1] === "isDoTasksOrThreads"
#                         global isDoTasksOrThreads = ARGSValue;  # "Tasks" || "Multi-Threading"; # 選擇具體執行功能的函數的并發層級（多協程、多綫程、多進程）;
#                         # print("isDoTasksOrThreads: ", isDoTasksOrThreads, "\n");
#                         # 當 isDoTasksOrThreads = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
#                         # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
#                         # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
#                     end
#                 end
#             end
#         end
#     end
# end

# 從指定的硬盤文檔讀取數據字符串，並調用相應的數據處理函數處理數據，然後將處理得到的結果再寫入指定的硬盤文檔;
function read_file_do_Function(
    monitor_file::Core.String,
    monitor_dir::Core.String,
    do_Function,
    output_dir::Core.String,
    output_file::Core.String,
    to_executable::Core.String,
    to_script::Core.String,
    time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8}
) ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}

    # # print("當前協程 task: ", Base.current_task(), "\n");
    # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
    # print("當前綫程 thread 的 PID: ", Base.Threads.threadid(), "\n");
    # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
    # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
    # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
    # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
    # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
    # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
    # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
    # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
    # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
    # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
    # # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
    # # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
    # # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

    # println(Base.Sys.CPU_THREADS)  # 4 可用 CPU 數;
    # println(Base.Filesystem.ispath(Base.Filesystem.pwd()))  # true 判斷目錄是否存在;
    # println(Base.Sys.BINDIR)  # C:\Program Files\Julia 1.5.1\bin;
    # println(Base.PROGRAM_FILE)  # c:\Users\china\Documents\Node.js\Criss\jl\tempCodeRunnerFile.jl;
    # println(Base.Filesystem.basename(Base.Filesystem.pwd()))  # Criss;
    # # "File_Directory_and_Path";
    # println(Base.Filesystem.homedir())  # C:\Users\china;
    # println(Base.Filesystem.pwd())  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath("."))  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js\Criss;
    # # 获取路径的目录;
    # println(Base.Filesystem.dirname(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js;
    # # "/Users/juliauser/Functions_Scripts_Codes_Pipelines/Julia_Codes";
    # # 路径的末端分割;
    # println(Base.Filesystem.splitdir(Base.Filesystem.pwd()));
    # # ("c:\\Users\\china\\Documents\\Node.js", "Criss");
    # # 路径的合成;
    # println(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "temp", "intermediary_write_NodeJS.txt"));  # c:\Users\china\Documents\Node.js\temp\intermediary_write_NodeJS.txt;
    # # Base.Filesystem.cd()  # 更換工作目錄;
    # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl"))
    # # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl").mode) # 返回值為 Core.UInt64 類型數值，例如 Core.UInt64(33206);


    # 判斷傳入的參數用於傳入數據的媒介文檔路徑全名 monitor_file 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(monitor_file) 判斷 monitor_file 變量是否已經被定義過;
    if !Base.@isdefined(monitor_file) || monitor_file === "" || monitor_file === Core.nothing
        # local monitor_file = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary", "intermediary_write_NodeJS.txt"));  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(monitor_dir, "Intermediary", "intermediary_write_NodeJS.txt")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於接收傳值的媒介文檔 "../Intermediary/intermediary_write_NodeJS.txt";
        # local monitor_file = Core.nothing;  # 置空;
        println("用於傳入數據的媒介文檔路徑全名「monitor_file ∈ ", Base.typeof(monitor_file), "」不能被識別.");
        return ["error", monitor_file, "argument [ monitor_file = " * Base.string(monitor_file) * " ] typeof error, no defined."];  # "用於傳入數據的媒介文檔路徑全名「monitor_file = " * Base.string(Base.typeof(monitor_file)) * "」不能被識別.";
    elseif !Core.isa(monitor_file, Core.String)
        # 使用 Core.isa(monitor_file, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(monitor_file) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(monitor_file) === Core.String 方法判別 monitor_file 變量的類型是否為字符串 Core.String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於傳入數據的媒介文檔路徑全名「monitor_file ∈ ", Base.typeof(monitor_file), "」不合法，只接受輸入文檔路徑全名字符串.");
        return ["error", monitor_file, "argument [ monitor_file = " * Base.string(monitor_file) * " ] typeof error, not String."];  # ["error", monitor_file, "用於傳入數據的媒介文檔路徑全名「monitor_file = " * Base.string(Base.typeof(monitor_file)) * "」不合法，只接受輸入文檔路徑全名字符串."];
    end

    # 判斷傳入的參數用於傳出數據的媒介文檔路徑全名 output_file 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(output_file) 判斷 output_file 變量是否已經被定義過;
    if !Base.@isdefined(output_file) || output_file === "" || output_file === Core.nothing
        # local output_file = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary", "intermediary_write_Julia.txt"));  # Core.String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(output_dir, "Intermediary", "intermediary_write_Julia.txt")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介文檔 "../Intermediary/intermediary_write_Julia.txt";
        # local output_file = Core.nothing;  # 置空;
        println("用於傳出數據的媒介文檔路徑全名「output_file ∈ ", Base.typeof(output_file), "」不能被識別.");
        return ["error", output_file, "argument [ output_file = " * Base.string(output_file) * " ] typeof error, no defined."];  # "用於傳出數據的媒介文檔路徑全名「output_file = " * Base.string(Base.typeof(output_file)) * "」不能被識別.";
    elseif !Core.isa(output_file, Core.String)
        # 使用 Core.isa(output_file, String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(output_file) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(output_file) === Core.String 方法判別 output_file 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於傳出數據的媒介文檔路徑全名「output_file ∈ ", Base.typeof(output_file), "」不合法，只接受輸入文檔路徑全名字符串.");
        return ["error", output_file, "argument [ output_file = " * Base.string(output_file) * " ] typeof error, not String."];  # ["error", output_file, "用於傳出數據的媒介文檔路徑全名「output_file = " * Base.string(Base.typeof(output_file)) * "」不合法，只接受輸入文檔路徑全名字符串."];
    end

    # 判斷傳入的參數用於傳入數據的媒介目錄（文件夾）monitor_dir 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(monitor_dir) 判斷 monitor_dir 變量是否已經被定義過;
    if !Base.@isdefined(monitor_dir) || monitor_dir === "" || monitor_dir === Core.nothing
        # local monitor_dir = Base.string(Base.Filesystem.splitdir(monitor_file)[1]);  # Core.String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸入傳值的媒介目錄 "../Intermediary/";
        monitor_dir = Base.string(Base.Filesystem.splitdir(monitor_file)[1]);  # Core.String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸入傳值的媒介目錄 "../Intermediary/";
        # Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組;
        # local monitor_dir = Core.nothing;  # 置空;
        println("用於傳入數據的媒介目錄（文件夾）「monitor_dir ∈ ", Base.typeof(monitor_dir), "」不能被識別.");
        # return ["error", monitor_dir, "argument [ monitor_dir = " * Base.string(monitor_dir) * " ] typeof error, no defined."];  # "用於傳入數據的媒介目錄（文件夾）「monitor_dir = " * Base.string(Base.typeof(monitor_dir)) * "」不能被識別.";
    elseif !Core.isa(monitor_dir, Core.String)
        # 使用 Core.isa(monitor_dir, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(monitor_dir) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(monitor_dir) === Core.String 方法判別 monitor_dir 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於傳入數據的媒介目錄（文件夾）「monitor_dir ∈ ", Base.typeof(monitor_dir), "」不合法，只接受輸入文檔路徑全名字符串.");
        return ["error", monitor_dir, "argument [ monitor_dir = " * Base.string(monitor_dir) * " ] typeof error, not String."];  # "用於傳入數據的媒介目錄（文件夾）「monitor_dir = " * Base.string(Base.typeof(monitor_dir)) * "」不合法，只接受輸入目錄（文件夾）全名字符串.";
    # elseif monitor_dir !== Base.string(Base.Filesystem.splitdir(monitor_file)[1])
    #     # 使用 Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組，Base.Filesystem.splitdir(monitor_file) 將 monitor_file 拆分爲 (輸入媒介目錄, 輸入媒介文檔名) 兩部分;
    #     println("用於傳入數據的媒介目錄（文件夾）「monitor_dir ∈ ", Base.typeof(monitor_dir), "」不合法，與 monitor_file 文檔所在目錄不同.");
    #     return ["error", monitor_dir, "argument [ monitor_dir = " * Base.string(monitor_dir) * " ] typeof error, not content monitor_file."];  # "用於傳入數據的媒介目錄（文件夾）「monitor_dir = " * Base.string(Base.typeof(monitor_dir)) * "」不合法，與 monitor_file 文檔所在目錄不同.";
    end

    # 判斷傳入的參數用於傳出數據的媒介目錄（文件夾）output_dir 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(output_dir) 判斷 output_dir 變量是否已經被定義過;
    if !Base.@isdefined(output_dir) || output_dir === "" || output_dir === Core.nothing
        # local output_dir = Base.string(Base.Filesystem.splitdir(output_file)[1]);  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介目錄 "../Intermediary/";
        output_dir = Base.string(Base.Filesystem.splitdir(output_file)[1]);  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介目錄 "../Intermediary/";
        # Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組;
        # local output_dir = Core.nothing;  # 置空;
        println("用於傳出數據的媒介目錄（文件夾）「output_dir ∈ ", Base.typeof(output_dir), "」不能被識別.");
        # return ["error", output_dir, "argument [ output_dir = " * Base.string(output_dir) * " ] typeof error, no defined."];  # "用於傳出數據的媒介目錄（文件夾）「output_dir = " * Base.string(Base.typeof(output_dir)) * "」不能被識別.";
    elseif !Core.isa(output_dir, Core.String)
        # 使用 Core.isa(output_dir, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(output_dir) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(output_dir) === Core.String 方法判別 output_dir 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於傳出數據的媒介目錄（文件夾）「output_dir ∈ ", Base.typeof(output_dir), "」不合法，只接受輸入文檔路徑全名字符串.");
        return ["error", output_dir, "argument [ output_dir = " * Base.string(output_dir) * " ] typeof error, not String."];  # "用於傳出數據的媒介目錄（文件夾）「output_dir = " * Base.string(Base.typeof(output_dir)) * "」不合法，只接受輸入目錄（文件夾）全名字符串.";
    # elseif output_dir !== Base.string(Base.Filesystem.splitdir(output_file)[1])
    #     # 使用 Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組，Base.Filesystem.splitdir(output_file) 將 output_file 拆分爲 (輸出媒介目錄, 輸出媒介文檔名) 兩部分;
    #     println("用於傳出數據的媒介目錄（文件夾）「output_dir ∈ ", Base.typeof(output_dir), "」不合法，與 output_file 文檔所在目錄不同.");
    #     return ["error", output_dir, "argument [ output_dir = " * Base.string(output_dir) * " ] typeof error, not content output_file."];  # "用於傳出數據的媒介目錄（文件夾）「output_dir = " * Base.string(Base.typeof(output_dir)) * "」不合法，與 output_file 文檔所在目錄不同.";
    end

    # 判斷傳入的具體執行處理數據的函數參數 do_Function 是否已定義且為函數，使用函數 Base.@isdefined(do_Function) 判斷 do_Function 變量是否已經被定義過;
    if !Base.@isdefined(do_Function) || do_Function === "" || do_Function === Core.nothing
        # local do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # local do_Function = Core.nothing;  # 置空;
        # println("傳入的參數，指定的變量「do_Function ∈ ", Base.typeof(do_Function), "」不能被識別.");
        # return "argument [ do_Function = " * Base.string(do_Function) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「do_Function = " * Base.string(Base.typeof(do_Function)) * "」不能被識別.";
    elseif !(Base.typeof(do_Function) <: Core.Function)
        # 使用 Core.isa(do_Function, Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_Function) <: Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_Function) <: Function 方法判別 do_Function 變量的類型是否包含於函數Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「do_Function ∈ ", Base.typeof(do_Function), "」不是一個函數類型的變量.");
        return "argument [ do_Function = " * Base.string(do_Function) * " ] typeof error, not Function."  # "傳入的參數，指定的變量「do_Function = " * Base.string(Base.typeof(do_Function)) * "」不是一個函數類型的變量.";

        # try
        #     if length(methods(do_Function)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end

        # Julia提供了許多類型的錯誤：
        # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
        # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
        # BoundsError：在索引陣列時嘗試訪問越界元素。
        # DivideError：這是數字除以0時的結果。
        # DomainError：有效域之外的參數。
        # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
        # InexactError：嘗試進行精確類型轉換失敗。
        # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
        # LoadError：載入檔時發生錯誤。
        # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
        # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
        # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
        # OverflowError：當操作結果太大時會發生這種情況。
        # ParseError：解析給定運算式時出現問題。
        # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
        # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
        # UndefRefError：未知引用。
        # UndefVarError：對不存在的變數進行未知引用。
        # InitError：調用模組的init方法時出現此錯誤。
        # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
        # NullException：嘗試訪問Null值
        # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

    end

    # 判斷傳入的自定義系統暫停時長參數 time_sleep 是否已定義且為數值類型 Core.Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(time_sleep) 判斷 time_sleep 變量是否已經被定義過;
    if !Base.@isdefined(time_sleep) || time_sleep === "" || time_sleep === Core.nothing
        # local time_sleep = Core.Float64(0.02);  # Core.Float64 類型變量，20 毫秒，系統暫停等待時長;
        time_sleep = Core.Float64(0.02);  # Core.Float64 類型變量，20 毫秒，系統暫停等待時長;
        # local time_sleep = Core.nothing;  # 置空;
        # println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不能被識別.");
        # return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不能被識別.";
    elseif !(Base.typeof(time_sleep) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(time_sleep, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判別 time_sleep 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不是一個數值類型的變量.");
        return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介目錄（文件夾）是否存在，如果不存在，則創建目錄，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
    # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isdir(monitor_dir) 方法判斷是否為目錄（文件夾）;
    if !(Base.Filesystem.ispath(monitor_dir) && Base.Filesystem.isdir(monitor_dir))
        # 同步創建，創建用於傳入數據的監聽媒介文件夾;
        try
            # 同步遞歸創建目錄 Base.Filesystem.mkpath(path::AbstractString; mode::Unsigned=0o777)，返回值(return) path;
            Base.Filesystem.mkpath(monitor_dir, mode=0o777);  # 同���遞歸創建目錄，返回值(return) path;
            println("目錄: " * monitor_dir * " 創建成功.");
        catch err
            println("用於輸入數據的媒介文件夾: " * monitor_dir * " 無法創建.");
            println(err);
            # println(Base.typeof(err));
            return ["error", monitor_dir, "path [ monitor_dir = " * Base.string(monitor_dir) * " ] mkpath fail."];
        end
    end

    # 判斷媒介文件夾是否創建成功;
    if !(Base.Filesystem.ispath(monitor_dir) && Base.Filesystem.isdir(monitor_dir))
        println("用於傳值的媒介文件夾 [ " * monitor_dir * " ] 無法被創建.");
        return ["error", monitor_dir, "path [ monitor_dir = " * Base.string(monitor_dir) * " ] mkpath fail."];
    elseif Base.stat(monitor_dir).mode !== Core.UInt64(16822) && Base.stat(monitor_dir).mode !== Core.UInt64(16895)
        # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(monitor_dir) 函數讀取文檔信息，使用 Base.stat(monitor_dir).mode 方法提取文檔權限碼;
        # println("用於傳值的媒介文件夾 [ " * monitor_dir * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
        try
            # 使用 Base.Filesystem.chmod(monitor_dir, mode=0o777; recursive=true) 函數修改文檔操作權限;
            # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
            Base.Filesystem.chmod(monitor_dir, mode=0o777; recursive=true);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
            # println("目錄: " * monitor_dir * " 操作權限成功修改爲 mode=0o777 .");

            # 八進制值    說明
            # 0o400      所有者可讀
            # 0o200      所有者可寫
            # 0o100      所有者可執行或搜索
            # 0o40       群組可讀
            # 0o20       群組可寫
            # 0o10       群組可執行或搜索
            # 0o4        其他人可讀
            # 0o2        其他人可寫
            # 0o1        其他人可執行或搜索
            # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
            # 數字	說明
            # 7	可讀、可寫、可執行
            # 6	可讀、可寫
            # 5	可讀、可執行
            # 4	唯讀
            # 3	可寫、可執行
            # 2	只寫
            # 1	只可執行
            # 0	沒有許可權
            # 例如，八進制值 0o765 表示：
            # 1) 、所有者可以讀取、寫入和執行該文檔；
            # 2) 、群組可以讀和寫入該文檔；
            # 3) 、其他人可以讀取和執行該文檔；
            # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
            # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

        catch err
            println("用於輸入數據的媒介文件夾: " * monitor_dir * " 無法修改操作權限爲 mode=0o777 .");
            println(err);
            # println(Base.typeof(err));
            return ["error", monitor_dir, "path [ monitor_dir = " * Base.string(monitor_dir) * " ] change the permissions mode=0o777 fail."];
        end
    end

    # # 判斷文件夾權限;
    # if !(Base.stat(monitor_dir).mode === Core.UInt64(16822) || Base.stat(monitor_dir).mode === Core.UInt64(16895))
    #     # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(monitor_dir) 函數讀取文檔信息，使用 Base.stat(monitor_dir).mode 方法提取文檔權限碼;
    #     println("用於輸入數據的媒介文件夾: " * monitor_dir * " 無法修改操作權限爲 mode=0o777 .");
    #     return ["error", monitor_dir, "path [ monitor_dir = " * Base.string(monitor_dir) * " ] change the permissions mode=0o777 fail."];
    # end

    # # 可以先改變工作目錄到 static 路徑;
    # println("Starting directory: ", Base.Filesystem.abspath(Base.Filesystem.pwd()));  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # try
    #     Base.Filesystem.cd(monitor_dir);  # 更換工作目錄;
    # catch err
    #     println(err);

    #     Julia提供了許多類型的錯誤：
    #     ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
    #     AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
    #     BoundsError：在索引陣列時嘗試訪問越界元素。
    #     DivideError：這是數字除以0時的結果。
    #     DomainError：有效域之外的參數。
    #     EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
    #     InexactError：嘗試進行精確類型轉換失敗。
    #     KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
    #     LoadError：載入檔時發生錯誤。
    #     MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
    #     OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
    #     ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
    #     OverflowError：當操作結果太大時會發生這種情況。
    #     ParseError：解析給定運算式時出現問題。
    #     StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
    #     SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
    #     UndefRefError：未知引用。
    #     UndefVarError：對不存在的變數進行未知引用。
    #     InitError：調用模組的init方法時出現此錯誤。
    #     ErrorException：發生錯誤InterruptException：計算中發生外部中斷
    #     NullException：嘗試訪問Null值
    #     ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤
    # end
    # 同步讀取指定文件夾的内容 Base.Filesystem.readdir();


    # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介文檔是否存在，如果不存在，則中止函數退出，如果存在則判斷操作權限，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
    # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isfile(monitor_file) 方法判斷是否為文檔;
    if !(Base.Filesystem.ispath(monitor_file) && Base.Filesystem.isfile(monitor_file))
        println("用於輸入數據的媒介文檔: " * monitor_file * " 無法識別或不存在.");
        return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] not recognition."];
    elseif Base.stat(monitor_file).mode !== Core.UInt64(33206) && Base.stat(monitor_file).mode !== Core.UInt64(33279)
        # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(monitor_file) 函數讀取文檔信息，使用 Base.stat(monitor_file).mode 方法提取文檔權限碼;
        # println("用於傳值的媒介文檔 [ " * monitor_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
        try
            # 使用 Base.Filesystem.chmod(monitor_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
            # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
            Base.Filesystem.chmod(monitor_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
            # println("文檔: " * monitor_file * " 操作權限成功修改爲 mode=0o777 .");

            # 八進制值    說明
            # 0o400      所有者可讀
            # 0o200      所有者可寫
            # 0o100      所有者可執行或搜索
            # 0o40       群組可讀
            # 0o20       群組可寫
            # 0o10       群組可執行或搜索
            # 0o4        其他人可讀
            # 0o2        其他人可寫
            # 0o1        其他人可執行或搜索
            # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
            # 數字	說明
            # 7	可讀、可寫、可執行
            # 6	可讀、可寫
            # 5	可讀、可執行
            # 4	唯讀
            # 3	可寫、可執行
            # 2	只寫
            # 1	只可執行
            # 0	沒有許可權
            # 例如，八進制值 0o765 表示：
            # 1) 、所有者可以讀取、寫入和執行該文檔；
            # 2) 、群組可以讀和寫入該文檔；
            # 3) 、其他人可以讀取和執行該文檔；
            # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
            # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

        catch err
            println("用於輸入數據的媒介文檔: " * monitor_file * " 無法修改操作權限爲 mode=0o777 .");
            println(err);
            # println(Base.typeof(err));
            return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] change the permissions mode=0o777 fail."];
        end
    end

    # 同步讀取，讀取用於輸入傳值的媒介文檔中的數據;
    data_Str::Core.String = "";
    if Base.Filesystem.ispath(monitor_file) && Base.Filesystem.isfile(monitor_file)

        fRIO = Core.nothing;  # ::IOStream;
        try
            # line = Base.Filesystem.readlink(monitor_file);  # 讀取文檔中的一行數據;
            # Base.readlines — Function
            # Base.readlines(io::IO=stdin; keep::Bool=false)
            # Base.readlines(filename::AbstractString; keep::Bool=false)
            # Read all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading readline repeatedly with the same arguments and saving the resulting lines as a vector of strings.
            # for line in eachline(monitor_file)
            #     print(line);
            # end
            # Base.displaysize([io::IO]) -> (lines, columns)
            # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
            # Base.countlines — Function
            # Base.countlines(io::IO; eol::AbstractChar = '\n')
            # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.

            # 在 Base.open() 函數中，還可以調用函數;
            # Base.open(Base.readline, "sdy.txt");
            # 也可以調用自定義函數;
            # readFunc(s::IOStream) = Base.read(s, Char);
            # Base.open(readFunc, "sdy.txt");
            # 還可以像Python中的 with open...as 的用法一樣打開文件;
            # Base.open("sdy.txt","r") do stream
            #     for line in eachline(stream)
            #         println(line);
            #     end
            # end
            # 也可以將上述程序定義成函數再用open操作;
            # function readFunc2(stream)
            #     for line in eachline(stream)
            #         println(line);
            #     end
            # end
            # Base.open(readFunc2, "sdy.txt");

            fRIO = Base.open(monitor_file, "r");
            # nb = countlines(fRIO);  # 計算文檔中數據行數;
            # seekstart(fRIO);  # 指針返回文檔的起始位置;

            # Keyword	Description				Default
            # read		open for reading		!write
            # write		open for writing		truncate | append
            # create	create if non-existent	!read & write | truncate | append
            # truncate	truncate to zero size	!read & write
            # append	seek to end				false

            # Mode	Description						Keywords
            # r		read							none
            # w		write, create, truncate			write = true
            # a		write, create, append			append = true
            # r+	read, write						read = true, write = true
            # w+	read, write, create, truncate	truncate = true, read = true
            # a+	read, write, create, append		append = true, read = true

            # io = IOBuffer("JuliaLang is a GitHub organization");
            # Base.read(io, Core.String);
            # "JuliaLang is a GitHub organization";
            # Base.read(filename::AbstractString, Core.String);
            # Read the entire contents of a file as a string.
            # Base.read(s::IOStream, nb::Integer; all=true);
            # Read at most nb bytes from s, returning a Vector{UInt8} of the bytes read.
            # If all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.
            # Base.read(command::Cmd)
            # Run command and return the resulting output as an array of bytes.
            # Base.read(command::Cmd, Core.String)
            # Run command and return the resulting output as a String.
            # Base.read!(stream::IO, array::Union{Array, BitArray})
            # Base.read!(filename::AbstractString, array::Union{Array, BitArray})
            # Read binary data from an I/O stream or file, filling in array.
            # Base.readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))
            # Read at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.
            # Base.readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)
            # Read at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.
            # If all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.

            # 使用 isreadable(io) 函數判斷文檔是否可讀;
            if Base.isreadable(fRIO)
                # Base.read!(filename::AbstractString, array::Union{Array, BitArray});  一次全部讀入文檔中的數據，將讀取到的數據解析為二進制數組類型;
                data_Str = Base.read(fRIO, Core.String);  # Base.read(filename::AbstractString, Core.String) 一次全部讀入文檔中的數據，將讀取到的數據解析為字符串類型 "utf-8" ;
            end

            # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
            # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
            # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
            # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
            # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
            # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
            # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
            # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
            # Base.ismarked(io);  # Return true if stream s is marked;
            # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
            # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
            # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
            # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
            # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
            # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
            # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
            # Base.close(io);  # 關閉緩衝區;
            # println(a)
            # Base.redirect_stdout — Function
            # redirect_stdout([stream]) -> (rd, wr)
            # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
            # If called with the optional stream argument, then returns stream itself.
            # Base.redirect_stdout — Method
            # redirect_stdout(f::Function, stream)
            # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
            # Base.redirect_stderr — Function
            # redirect_stderr([stream]) -> (rd, wr)
            # Like redirect_stdout, but for stderr.
            # Base.redirect_stderr — Method
            # redirect_stderr(f::Function, stream)
            # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
            # Base.redirect_stdin — Function
            # redirect_stdin([stream]) -> (rd, wr)
            # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
            # Base.redirect_stdin — Method
            # redirect_stdin(f::Function, stream)
            # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

        catch err

            if Core.isa(err, Core.InterruptException)

                print("\n");
                # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                println("[ Ctrl ] + [ c ] received, will be return Function.");
            
                # println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    
                # Base.exit(0);
                return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, will be return Function."];

            else

                println("從用於輸入數據的媒介文檔: " * monitor_file * " 中讀取數據發生錯誤.");
                println(err);
                # println(err.msg);
                # println(Base.typeof(err));
                return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] not read."];
            end

        finally
            Base.close(fRIO);
        end

        Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
        # Base.sleep(seconds)  Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of 0.001.

        # 讀取到輸入數據之後，同步刪除，用於接收傳值的媒介文檔;
        try
            # Determine whether an object - such as a stream or timer – is not yet closed. Once an object is closed, it will never produce a new event. However, since a closed stream may still have data to read in its buffer, use eof to check for the ability to read data. Use the FileWatching package to be notified when a stream might be writable or readable.
            if !Base.isopen(fRIO)
                # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                Base.Filesystem.rm(monitor_file, force=true, recursive=false);  # 刪除給定路徑下的文檔、鏈接或空目錄，如果傳遞參數 force=true 時，則不存在的路徑不被視爲錯誤，如果傳遞參數 recursive=true 并且路徑是目錄時，則遞歸刪除所有内容;
                # Base.Filesystem.rm(path::AbstractString, force::Bool=false, recursive::Bool=false)
                # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                # println("媒介文檔: " * monitor_file * " 已被刪除.");
            end

        catch err
            println("用於輸入數據的媒介文檔: " * monitor_file * " 無法刪除.");
            println(err);
            # println(err.msg);
            # println(Base.typeof(err));
            return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] not delete."];
        end

        fRIO = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        # Base.GC.gc();  # 内存回收函數 gc();

        # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

        # 判斷用於接收傳值的媒介文檔，是否已經從硬盤刪除;
        if Base.Filesystem.ispath(monitor_file) && Base.Filesystem.isfile(monitor_file)
            println("用於輸入數據的媒介文檔: " * monitor_file * " 無法刪除.");
            return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] not delete."];
        end

        nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
        # println(Base.string(nowTime));

        # request_data_Dict = Base.Dict{Core.String, Core.Any}();  # 函數返回值，聲明一個空字典;
        # # 使用自定義函數 isStringJSON(data_Str) 判斷讀取到的數據是否為 JSON 格式的字符串;
        # if isStringJSON(request_form_value)
        #     request_data_Dict = JSONparse(data_Str);  # 使用自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
        #     # request_data_Dict = JSON.parse(data_Str);  # 使用第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象;
        #     # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象;
        #     # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
        # else
        #     request_data_Dict["Client_say"]::Core.String = data_Str;  # Base.Dict("Client_say" => Base.string(request_form_value))，Base.Dict(data_Str)，Base.Dict("aa" => 1, "bb" => 2, "cc" => 3);
        #     request_data_Dict["time"] = Base.string(nowTime);  # Base.Dict("Client_say" => Base.string(request_form_value), "time" => Base.string(Dates.now()));
        #     request_data_Dict["Client_Authorization"]::Core.String = "";  # Base.Dict("Client_Authorization" => Base.string("username:password"));
        # end
        # # println(request_data_Dict);

        # if data_Str !== ""
        # end

        # response_data_Dict = Base.Dict{Core.String, Core.Any}();  # 函數返回值，聲明一個空字典;
        response_data_String::Core.String = "";
        # 判斷變量 do_Function 是否已經被定義，并且是否為函數類型;
        if Base.@isdefined(do_Function) && Base.typeof(do_Function) <: Function
            # result_do_Function = do_Function(request_data_Dict);
            # response_data_Dict["Server_say"]::Core.String = result_do_Function["Server_say"];  # Base.Dict("Julia_say" => Base.string(result_do_Function["Server_say"]))，Base.Dict(data_Str)，Base.Dict("aa" => 1, "bb" => 2, "cc" => 3);
            # response_data_Dict["time"] = Base.string(nowTime);  # Base.Dict("Julia_say" => Base.string(result_do_Function["Server_say"]), "time" => Base.string(Dates.now()));
            # response_data_Dict["Server_Authorization"]::Core.String = result_do_Function["Server_Authorization"];  # Base.Dict("Server_Authorization" => Base.string("username:password"));
            # println(response_data_Dict);
            # # response_data_String = "{\"Server_say\":\"" * Base.string(response_data_Dict["Server_say"]) * "\",\"time\":\"" * Base.string(response_data_Dict["time"]) * "\",\"Authorization\":\"" * Base.string(response_data_Dict["Server_Authorization"]) * "\"}";  # 使用星號*拼接字符串，nowTime = Dates.now();
            # response_data_String = JSONstring(response_data_Dict);  # 使用自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
            # # response_data_String = JSON.json(response_data_Dict);  # 使用第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
            # # 需要事先安裝第三方擴展包「JSON」成功：using Pkg; Pkg.add("JSON") 然後再加載第三方擴展包「JSON」成功：using JSON;
            # println(response_data_String);
            try
                response_data_String = do_Function(data_Str);
                # Base.write(Base.stdout, response_data_String);
            catch err

                if Core.isa(err, Core.InterruptException)

                    print("\n");
                    # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                    # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                    println("[ Ctrl ] + [ c ] received, will be return Function.");
                
                    # println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        
                    # Base.exit(0);
                    return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, will be return Function."];

                else

                    # Base.write(stderr, err);
                    # Base.write(Base.stdout, err, "\n");
                    println("自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                    println(err);
                    # println(err.msg);
                    # println(Base.typeof(err));
                    return ["error", Base.string(Base.typeof(do_Function)), "function [ do_Function ∈ " * Base.string(Base.typeof(do_Function)) * " ] run error."];
                end
            end
            # Julia_Dict = JSONparse(JSON_Str);  # 自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
            # # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象;
            # response_data_String = "{\"Server_say\":\"" * Base.string(response_data_String) * "\",\"time\":\"" * Base.string(nowTime) * "\",\"Authorization\":\"" * Base.string("username:password") * "\"}";  # 使用星號*拼接字符串，nowTime = Dates.now();
            # println(response_data_String);
        else
            response_data_String = data_Str;
            # response_data_String = "{\"Server_say\":\"" * Base.string(data_Str) * "\",\"time\":\"" * Base.string(nowTime) * "\",\"Authorization\":\"" * Base.string("username:password") * "\"}";  # 使用星號*拼接字符串，nowTime = Dates.now();
            # println(response_data_String);
        end

        # data_Str = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        # Base.GC.gc();  # 内存回收函數 gc();

        # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳出數據的媒介目錄（文件夾）是否存在，如果不存在，則創建目錄，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
        # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isdir(output_dir) 方法判斷是否為目錄（文件夾）;
        if !(Base.Filesystem.ispath(output_dir) && Base.Filesystem.isdir(output_dir))
            # 同步創建，創建用於傳出數據的監聽媒介文件夾;
            try
                # 同步遞歸創建目錄 Base.Filesystem.mkpath(path::AbstractString; mode::Unsigned=0o777)，返回值(return) path;
                Base.Filesystem.mkpath(output_dir, mode=0o777);  # 同步遞歸創建目錄，返回值(return) path;
                # println("目錄: " * output_dir * " 創建成功.");
            catch err
                println("用於輸出數據的媒介文件夾: " * output_dir * " 無法創建.");
                println(err);
                # println(err.msg);
                # println(Base.typeof(err));
                return ["error", output_dir, "path [ output dir = " * Base.string(output_dir) * " ] mkpath fail."];
            end
        end

        # 判斷媒介文件夾是否創建成功;
        if !(Base.Filesystem.ispath(output_dir) && Base.Filesystem.isdir(output_dir))
            println("用於傳值的媒介文件夾 [ " * output_dir * " ] 無法被創建.");
            return ["error", output_dir, "path [ output dir = " * Base.string(output_dir) * " ] mkpath fail."];
        elseif Base.stat(output_dir).mode !== Core.UInt64(16822) && Base.stat(output_dir).mode !== Core.UInt64(16895)
            # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(output_dir) 函數讀取文檔信息，使用 Base.stat(output_dir).mode 方法提取文檔權限碼;
            # println("用於傳值的媒介文件夾 [ " * output_dir * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
            try
                # 使用 Base.Filesystem.chmod(output_dir, mode=0o777; recursive=true) 函數修改文檔操作權限;
                # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                Base.Filesystem.chmod(output_dir, mode=0o777; recursive=true);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                # println("目錄: " * output_dir * " 操作權限成功修改爲 mode=0o777 .");

                # 八進制值    說明
                # 0o400      所有者可讀
                # 0o200      所有者可寫
                # 0o100      所有者可執行或搜索
                # 0o40       群組可讀
                # 0o20       群組可寫
                # 0o10       群組可執行或搜索
                # 0o4        其他人可讀
                # 0o2        其他人可寫
                # 0o1        其他人可執行或搜索
                # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                # 數字	說明
                # 7	可讀、可寫、可執行
                # 6	可讀、可寫
                # 5	可讀、可執行
                # 4	唯讀
                # 3	可寫、可執行
                # 2	只寫
                # 1	只可執行
                # 0	沒有許可權
                # 例如，八進制值 0o765 表示：
                # 1) 、所有者可以讀取、寫入和執行該文檔；
                # 2) 、群組可以讀和寫入該文檔；
                # 3) 、其他人可以讀取和執行該文檔；
                # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

            catch err
                println("用於輸出數據的媒介文件夾: " * output_dir * " 無法修改操作權限爲 mode=0o777 .");
                println(err);
                # println(err.msg);
                # println(Base.typeof(err));
                return ["error", output_dir, "path [ output dir = " * Base.string(output_dir) * " ] change the permissions mode=0o777 fail."];
            end
        else
        end

        # # 判斷文件夾權限;
        # if !(Base.stat(output_dir).mode === Core.UInt64(16822) || Base.stat(output_dir).mode === Core.UInt64(16895))
        #     # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(output_dir) 函數讀取文檔信息，使用 Base.stat(output_dir).mode 方法提取文檔權限碼;
        #     println("用於輸出數據的媒介文件夾: " * output_dir * " 無法修改操作權限爲 mode=0o777 .");
        #     return ["error", output_dir, "path [ output dir = " * Base.string(output_dir) * " ] change the permissions mode=0o777 fail."];
        # end

        # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介文檔是否存在，如果存在則判斷操作權限，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
        # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isfile(output_file) 方法判斷是否為文檔;
        if Base.Filesystem.ispath(output_file) && Base.Filesystem.isfile(output_file)

            if Base.stat(output_file).mode !== Core.UInt64(33206) && Base.stat(output_file).mode !== Core.UInt64(33279)
                # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(output_file) 函數讀取文檔信息，使用 Base.stat(output_file).mode 方法提取文檔權限碼;
                println("用於傳值的媒介文檔 [ " * output_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                try
                    # 使用 Base.Filesystem.chmod(output_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
                    # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                    Base.Filesystem.chmod(output_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                    # println("文檔: " * output_file * " 操作權限成功修改爲 mode=0o777 .");

                    # 八進制值    說明
                    # 0o400      所有者可讀
                    # 0o200      所有者可寫
                    # 0o100      所有者可執行或搜索
                    # 0o40       群組可讀
                    # 0o20       群組可寫
                    # 0o10       群組可執行或搜索
                    # 0o4        其他人可讀
                    # 0o2        其他人可寫
                    # 0o1        其他人可執行或搜索
                    # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                    # 數字	說明
                    # 7	可讀、可寫、可執行
                    # 6	可讀、可寫
                    # 5	可讀、可執行
                    # 4	唯讀
                    # 3	可寫、可執行
                    # 2	只寫
                    # 1	只可執行
                    # 0	沒有許可權
                    # 例如，八進制值 0o765 表示：
                    # 1) 、所有者可以讀取、寫入和執行該文檔；
                    # 2) 、群組可以讀和寫入該文檔；
                    # 3) 、其他人可以讀取和執行該文檔；
                    # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                    # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                catch err
                    println("用於輸出數據的媒介文檔: " * output_file * " 無法修改操作權限爲 mode=0o777 .");
                    println(err);
                    # println(err.msg);
                    # println(Base.typeof(err));
                    return ["error", output_file, "document [ output file = " * Base.string(output_file) * " ] change the permissions mode=0o777 fail."];
                end
            end

            # 同步刪除，已經存在的用於輸出數據的的媒介文檔，重新創建，以輸出數據;
            try
                # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                Base.Filesystem.rm(output_file, force=true, recursive=false);  # 刪除給定路徑下的文檔、鏈接或空目錄，如果傳遞參數 force=true 時，則不存在的路徑不被視爲錯誤，如果傳遞參數 recursive=true 并且路徑是目錄時，則遞歸刪除所有内容;
                # Base.Filesystem.rm(path::AbstractString, force::Bool=false, recursive::Bool=false)
                # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                # println("媒介文檔: " * output_file * " 已被刪除.");
            catch err
                println("用於輸出數據的媒介文檔: " * output_file * " 無法刪除.");
                println(err);
                # println(err.msg);
                # println(Base.typeof(err));
                return ["error", output_file, "document [ output file = " * Base.string(output_file) * " ] not delete."];
            end

            # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
            # # Base.sleep(seconds)  Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of 0.001.

            # 判斷用於輸出傳值的媒介文檔，是否已經從硬盤刪除;
            if Base.Filesystem.ispath(output_file) && Base.Filesystem.isfile(output_file)
                println("用於輸出數據的媒介文檔: " * output_file * " 無法刪除.");
                return ["error", output_file, "document [ output file = " * Base.string(output_file) * " ] not delete."];
            end
        end

        # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
        # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
        # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
        # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
        # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
        # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
        # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
        # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
        # Base.ismarked(io);  # Return true if stream s is marked;
        # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
        # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
        # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
        # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
        # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
        # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
        # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
        # Base.close(io);  # 關閉緩衝區;
        # println(a)
        # Base.redirect_stdout — Function
        # redirect_stdout([stream]) -> (rd, wr)
        # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
        # If called with the optional stream argument, then returns stream itself.
        # Base.redirect_stdout — Method
        # redirect_stdout(f::Function, stream)
        # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
        # Base.redirect_stderr — Function
        # redirect_stderr([stream]) -> (rd, wr)
        # Like redirect_stdout, but for stderr.
        # Base.redirect_stderr — Method
        # redirect_stderr(f::Function, stream)
        # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
        # Base.redirect_stdin — Function
        # redirect_stdin([stream]) -> (rd, wr)
        # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
        # Base.redirect_stdin — Method
        # redirect_stdin(f::Function, stream)
        # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

        # 同步寫入，用於傳出數據的媒介文檔中的數據;
        # Base.Filesystem.touch — Function
        # touch(path::AbstractString)
        # Update the last-modified timestamp on a file to the current time. Return path.
        output_file_path = Base.Filesystem.touch(output_file);  # 創建一個空文檔;
        if !(Base.Filesystem.ispath(output_file) && Base.Filesystem.isfile(output_file))
            println("用於輸出數據的媒介文檔: " * output_file * " 無法創建.");
            return ["error", output_file, "document [ output file = " * Base.string(output_file) * " ] not create."];
        elseif Base.stat(output_file).mode !== Core.UInt64(33206) && Base.stat(output_file).mode !== Core.UInt64(33279)
            # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(output_file) 函數讀取文檔信息，使用 Base.stat(output_file).mode 方法提取文檔權限碼;
            println("用於傳值的媒介文檔 [ " * output_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
            try
                # 使用 Base.Filesystem.chmod(output_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
                # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                Base.Filesystem.chmod(output_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                # println("文檔: " * output_file * " 操作權限成功修改爲 mode=0o777 .");

                # 八進制值    說明
                # 0o400      所有者可讀
                # 0o200      所有者可寫
                # 0o100      所有者可執行或搜索
                # 0o40       群組可讀
                # 0o20       群組可寫
                # 0o10       群組可執行或搜索
                # 0o4        其他人可讀
                # 0o2        其他人可寫
                # 0o1        其他人可執行或搜索
                # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                # 數字	說明
                # 7	可讀、可寫、可執行
                # 6	可讀、可寫
                # 5	可讀、可執行
                # 4	唯讀
                # 3	可寫、可執行
                # 2	只寫
                # 1	只可執行
                # 0	沒有許可權
                # 例如，八進制值 0o765 表示：
                # 1) 、所有者可以讀取、寫入和執行該文檔；
                # 2) 、群組可以讀和寫入該文檔；
                # 3) 、其他人可以讀取和執行該文檔；
                # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

            catch err
                println("用於輸出數據的媒介文檔: " * output_file * " 無法修改操作權限爲 mode=0o777 .");
                println(err);
                # println(err.msg);
                # println(Base.typeof(err));
                return ["error", output_file, "document [ output file = " * Base.string(output_file) * " ] change the permissions mode=0o777 fail."];
            end
        else
        end

        # 同步寫入，用於輸出傳值的媒介文檔中的數據;
        fWIO = Core.nothing;  # ::IOStream;
        try
            # numBytes = write(output_file, response_data_String);  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
            # # write(filename::AbstractString, x)
            # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
            # # You can write multiple values with the same write call. i.e. the following are equivalent:
            # println(numBytes);
            # println(Base.stat(output_file).size);
            # println(Base.stat(output_file).mtime);
            # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            # println(Base.stat(output_file).ctime);
            # # Base.displaysize([io::IO]) -> (lines, columns)
            # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
            # # Base.countlines — Function
            # # Base.countlines(io::IO; eol::AbstractChar = '\n')
            # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
            # println(Base.countlines(output_file, eol='\\n'));


            # 在 Base.open() 函數中，還可以調用函數;
            # Base.open(Base.readline, "sdy.txt");
            # 也可以調用自定義函數;
            # readFunc(s::IOStream) = Base.read(s, Char);
            # Base.open(readFunc, "sdy.txt");
            # 還可以像Python中的 with open...as 的用法一樣打開文件;
            # Base.open("sdy.txt","r") do stream
            #     for line in eachline(stream)
            #         println(line);
            #     end
            # end
            # 也可以將上述程序定義成函數再用open操作;
            # function readFunc2(stream)
            #     for line in eachline(stream)
            #         println(line);
            #     end
            # end
            # Base.open(readFunc2, "sdy.txt");

            fWIO = Base.open(output_file, "w");
            # nb = countlines(fWIO);  # 計算文檔中數據行數;
            # seekstart(fWIO);  # 指針返回文檔的起始位置;

            # Keyword	Description				Default
            # read		open for reading		!write
            # write		open for writing		truncate | append
            # create	create if non-existent	!read & write | truncate | append
            # truncate	truncate to zero size	!read & write
            # append	seek to end				false

            # Mode	Description						Keywords
            # r		read							none
            # w		write, create, truncate			write = true
            # a		write, create, append			append = true
            # r+	read, write						read = true, write = true
            # w+	read, write, create, truncate	truncate = true, read = true
            # a+	read, write, create, append		append = true, read = true

            # io = IOBuffer("JuliaLang is a GitHub organization");
            # Base.IOStream();  # 包裝 OS 文檔描述符的緩衝 I/O 流。主要用於表示 open 返回的文檔;
            # A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by open.
            # Base.write — Function
            # write(io::IO, x)
            # write(filename::AbstractString, x)
            # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
            # You can write multiple values with the same write call. i.e. the following are equivalent:
            # write(io, x, y...)
            # write(io, x) + write(io, y...)

            # 使用 iswritable(io) 函數判斷文檔是否可寫;
            if Base.iswritable(fWIO)
                numBytes = Base.write(fWIO, response_data_String);  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                # println(numBytes);
                # println(Base.stat(output_file).size);
                # println(Base.stat(output_file).mtime);
                # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # println(Base.stat(output_file).ctime);
                # Base.displaysize([io::IO]) -> (lines, columns)
                # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                # Base.countlines — Function
                # Base.countlines(io::IO; eol::AbstractChar = '\n')
                # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                # println(Base.countlines(output_file, eol='\n'));
            end

            # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
            # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
            # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
            # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
            # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
            # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
            # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
            # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
            # Base.ismarked(io);  # Return true if stream s is marked;
            # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
            # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
            # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
            # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
            # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
            # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
            # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
            # Base.close(io);  # 關閉緩衝區;
            # println(a)
            # Base.redirect_stdout — Function
            # redirect_stdout([stream]) -> (rd, wr)
            # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
            # If called with the optional stream argument, then returns stream itself.
            # Base.redirect_stdout — Method
            # redirect_stdout(f::Function, stream)
            # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
            # Base.redirect_stderr — Function
            # redirect_stderr([stream]) -> (rd, wr)
            # Like redirect_stdout, but for stderr.
            # Base.redirect_stderr — Method
            # redirect_stderr(f::Function, stream)
            # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
            # Base.redirect_stdin — Function
            # redirect_stdin([stream]) -> (rd, wr)
            # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
            # Base.redirect_stdin — Method
            # redirect_stdin(f::Function, stream)
            # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

        catch err

            if Core.isa(err, Core.InterruptException)

                print("\n");
                # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                println("[ Ctrl ] + [ c ] received, will be return Function.");
            
                # println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    
                # Base.exit(0);
                return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, will be return Function."];

            else

                println("往用於輸出數據的媒介文檔: " * output_file * " 中寫入數據發生錯誤.");
                println(err);
                # println(err.msg);
                # println(Base.typeof(err));
                return ["error", output_file, "document [ output file = " * Base.string(output_file) * " ] not write."];
            end

        finally
            # Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
            # # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
            # if Base.eof(fWIO)
            #     Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
            # end
            Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
        end

        # response_data_String = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        fWIO = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        # Base.GC.gc();  # 内存回收函數 gc();
    end

    # 修改文檔權限;
    if Base.Filesystem.ispath(output_file) && Base.Filesystem.isfile(output_file)
        if Base.stat(output_file).mode !== Core.UInt64(33206) && Base.stat(output_file).mode !== Core.UInt64(33279)
            # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(output_file) 函數讀取文檔信息，使用 Base.stat(output_file).mode 方法提取文檔權限碼;
            println("用於傳值的媒介文檔 [ " * output_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
            try
                # 使用 Base.Filesystem.chmod(output_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
                # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                Base.Filesystem.chmod(output_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                # println("文檔: " * output_file * " 操作權限成功修改爲 mode=0o777 .");

                # 八進制值    說明
                # 0o400      所有者可讀
                # 0o200      所有者可寫
                # 0o100      所有者可執行或搜索
                # 0o40       群組可讀
                # 0o20       群組可寫
                # 0o10       群組可執行或搜索
                # 0o4        其他人可讀
                # 0o2        其他人可寫
                # 0o1        其他人可執行或搜索
                # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                # 數字	說明
                # 7	可讀、可寫、可執行
                # 6	可讀、可寫
                # 5	可讀、可執行
                # 4	唯讀
                # 3	可寫、可執行
                # 2	只寫
                # 1	只可執行
                # 0	沒有許可權
                # 例如，八進制值 0o765 表示：
                # 1) 、所有者可以讀取、寫入和執行該文檔；
                # 2) 、群組可以讀和寫入該文檔；
                # 3) 、其他人可以讀取和執行該文檔；
                # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

            catch err
                println("用於輸出數據的媒介文檔: " * output_file * " 無法修改操作權限爲 mode=0o777 .");
                println(err);
                # println(err.msg);
                # println(Base.typeof(err));
                return ["error", output_file, "document [ output file = " * Base.string(output_file) * " ] change the permissions mode=0o777 fail."];
            end
        end
    end

    Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
    # Base.sleep(seconds)  Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of 0.001.

    # 使用 a = Base.read(`bash -c C:/node.exe C:/Cross/test.js a=5 b=6`, Core.String) 調用 shell 語句反饋，運算處理完之後，給調用語言的回復，然後再獲取返回值;
    if Base.Filesystem.ispath(output_file) && Base.Filesystem.isfile(output_file)

        # # 判斷變量 to_executable 已被定義且類型取值合法，Core.isa(to_executable, Core.String) 與 Base.typeof(to_executable) === Core.String 等效;
        # # local to_executable = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe"));  # String 類型變量，上一層路徑下的Node.JS解釋器可執行檔路徑C:\nodejs\node.exe：Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的解釋器可執行文件 "..\\NodeJS\\node.exe"，Julia 解釋器可執行檔全名 println(Base.Sys.BINDIR)：C:\Julia 1.5.1\bin，;
        # # local to_executable = Core.nothing;  # 置空;
        # if Base.@isdefined(to_executable) && to_executable !== Core.nothing && Core.isa(to_executable, Core.String) && to_executable !== ""

        #     # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否存在;
        #     if Base.Filesystem.ispath(to_executable) && Base.Filesystem.isfile(to_executable)

        #         # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
        #         if Base.stat(to_executable).mode !== Core.UInt64(33206) && Base.stat(to_executable).mode !== Core.UInt64(33279)
        #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
        #             println("回調程序二進制可執行檔 [ " * to_executable * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
        #             try
        #                 # 使用 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false) 函數修改文檔操作權限;
        #                 # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
        #                 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
        #                 # println("回調程序二進制可執行檔: " * to_executable * " 操作權限成功修改爲 mode=0o777 .");

        #                 # 八進制值    說明
        #                 # 0o400      所有者可讀
        #                 # 0o200      所有者可寫
        #                 # 0o100      所有者可執行或搜索
        #                 # 0o40       群組可讀
        #                 # 0o20       群組可寫
        #                 # 0o10       群組可執行或搜索
        #                 # 0o4        其他人可讀
        #                 # 0o2        其他人可寫
        #                 # 0o1        其他人可執行或搜索
        #                 # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
        #                 # 數字	說明
        #                 # 7	可讀、可寫、可執行
        #                 # 6	可讀、可寫
        #                 # 5	可讀、可執行
        #                 # 4	唯讀
        #                 # 3	可寫、可執行
        #                 # 2	只寫
        #                 # 1	只可執行
        #                 # 0	沒有許可權
        #                 # 例如，八進制值 0o765 表示：
        #                 # 1) 、所有者可以讀取、寫入和執行該文檔；
        #                 # 2) 、群組可以讀和寫入該文檔；
        #                 # 3) 、其他人可以讀取和執行該文檔；
        #                 # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
        #                 # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

        #             catch err
        #                 println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
        #                 println(err);
        #                 # println(err.msg);
        #                 # println(Base.typeof(err));
        #                 return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
        #             end
        #         end

        #         # # 判斷可執行檔 to_executable 權限是否修改成功;
        #         # if !(Base.stat(to_executable).mode === Core.UInt64(33206) || Base.stat(to_executable).mode === Core.UInt64(33279))
        #         #     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
        #         #     println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
        #         #     return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
        #         # end

        #         # 判斷變量 to_script 已被定義且類型取值合法，Core.isa(to_script, Core.String) 與 Base.typeof(to_script) === Core.String 等效;
        #         # local to_script = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js"));  # String 類型變量，上一層路徑下的 JavaScript 脚本路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的被調用的脚本文檔 "../js/Ruuter.js";
        #         # local to_script = Core.nothing;  # 置空;
        #         if Base.@isdefined(to_script) && to_script !== Core.nothing && Core.isa(to_script, Core.String) && to_script !== ""
        #             # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否存在;
        #             if Base.Filesystem.ispath(to_script) && Base.Filesystem.isfile(to_script)
        #                 # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
        #                 if Base.stat(to_script).mode !== Core.UInt64(33206) && Base.stat(to_script).mode !== Core.UInt64(33279)
        #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
        #                     println("回調程序二進制可執行檔調用的脚本文檔 [ " * to_script * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
        #                     try
        #                         # 使用 Base.Filesystem.chmod(to_script, mode=0o777; recursive=false) 函數修改文檔操作權限;
        #                         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
        #                         Base.Filesystem.chmod(to_script, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
        #                         # println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 操作權限成功修改爲 mode=0o777 .");

        #                         # 八進制值    說明
        #                         # 0o400      所有者可讀
        #                         # 0o200      所有者可寫
        #                         # 0o100      所有者可執行或搜索
        #                         # 0o40       群組可讀
        #                         # 0o20       群組可寫
        #                         # 0o10       群組可執行或搜索
        #                         # 0o4        其他人可讀
        #                         # 0o2        其他人可寫
        #                         # 0o1        其他人可執行或搜索
        #                         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
        #                         # 數字	說明
        #                         # 7	可讀、可寫、可執行
        #                         # 6	可讀、可寫
        #                         # 5	可讀、可執行
        #                         # 4	唯讀
        #                         # 3	可寫、可執行
        #                         # 2	只寫
        #                         # 1	只可執行
        #                         # 0	沒有許可權
        #                         # 例如，八進制值 0o765 表示：
        #                         # 1) 、所有者可以讀取、寫入和執行該文檔；
        #                         # 2) 、群組可以讀和寫入該文檔；
        #                         # 3) 、其他人可以讀取和執行該文檔；
        #                         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
        #                         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

        #                     catch err
        #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
        #                         println(err);
        #                         # println(err.msg);
        #                         # println(Base.typeof(err));
        #                         return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
        #                     end
        #                 end

        #                 # # 判斷代碼脚本文檔 to_script 權限是否修改成功;
        #                 # if !(Base.stat(to_script).mode === Core.UInt64(33206) || Base.stat(to_script).mode === Core.UInt64(33279))
        #                 #     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
        #                 #     println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
        #                 #     return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
        #                 # end
        #             else
        #                 println("回調程序二進制可執行檔調用的脚本文檔路徑全名「to_script = " * Base.string(to_script) * "」不能被識別.");
        #                 return ["error", to_script, "Callback script code document [ to_script = " * Base.string(to_script) * " ] error, no recognition."];
        #             end

        #             textCommand = "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
        #             # Command = `bash -c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
        #             # Command = `cmd /c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
        #             Command = `bash -c $textCommand`;

        #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
        #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
        #             # println(Base.typeof(resultBack));
        #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
        #             println(resultBack);
        #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
        #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
        #             # for x in Base.split(resultBack, "\n")
        #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
        #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
        #             # end
        #             # println(backArray);

        #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        #             # Base.GC.gc();  # 内存回收函數 gc();

        #         else
        #             textCommand = "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
        #             # Command = `bash -c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
        #             # Command = `cmd /c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
        #             Command = `bash -c $textCommand`;

        #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
        #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
        #             # println(Base.typeof(resultBack));
        #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
        #             println(resultBack);
        #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
        #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
        #             # for x in Base.split(resultBack, "\n")
        #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
        #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
        #             # end
        #             # println(backArray);

        #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        #             # Base.GC.gc();  # 内存回收函數 gc();
        #         end
        #     else
        #         println("回調程序二進制可執行檔路徑全名「to_executable = " * Base.string(to_executable) * "」不能被識別.");
        #         return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] error, no recognition."];
        #     end
        # end


        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
        # println(Base.string(nowTime));
        # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * monitor_file * " ] -> [ " * output_file * " ].";
        # print(log_text * "\n");
        # log_file = "";  # 日志文檔;
        # # 同步寫入用於記錄過程的日志文檔;
        # try
        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
        #     # # write(filename::AbstractString, x)
        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
        #     # println(numBytes);
        #     # println(Base.stat(log_file).size);
        #     # println(Base.stat(log_file).mtime);
        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
        #     # println(Base.stat(log_file).ctime);
        #     # # Base.displaysize([io::IO]) -> (lines, columns)
        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
        #     # # Base.countlines — Function
        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
        #     # println(Base.countlines(log_file, eol='\\n'));

        #     fWIO = Base.open(log_file, "a+");
        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

        #     # Keyword	Description				Default
        #     # read		open for reading		!write
        #     # write		open for writing		truncate | append
        #     # create	create if non-existent	!read & write | truncate | append
        #     # truncate	truncate to zero size	!read & write
        #     # append	seek to end				false

        #     # Mode	Description						Keywords
        #     # r		read							none
        #     # w		write, create, truncate			write = true
        #     # a		write, create, append			append = true
        #     # r+	read, write						read = true, write = true
        #     # w+	read, write, create, truncate	truncate = true, read = true
        #     # a+	read, write, create, append		append = true, read = true

        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
        #     if Base.iswritable(fWIO)
        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
        #         println(numBytes);
        #         println(Base.stat(log_file).size);
        #         println(Base.stat(log_file).mtime);
        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
        #         println(Base.stat(log_file).ctime);
        #         # Base.displaysize([io::IO]) -> (lines, columns)
        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
        #         # Base.countlines — Function
        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
        #         println(Base.countlines(log_file, eol='\\n'));
        #     end

        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
        #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
        #     # Base.ismarked(io);  # Return true if stream s is marked;
        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
        #     # Base.close(io);  # 關閉緩衝區;
        #     # println(a)
        #     # Base.redirect_stdout — Function
        #     # redirect_stdout([stream]) -> (rd, wr)
        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
        #     # If called with the optional stream argument, then returns stream itself.
        #     # Base.redirect_stdout — Method
        #     # redirect_stdout(f::Function, stream)
        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
        #     # Base.redirect_stderr — Function
        #     # redirect_stderr([stream]) -> (rd, wr)
        #     # Like redirect_stdout, but for stderr.
        #     # Base.redirect_stderr — Method
        #     # redirect_stderr(f::Function, stream)
        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
        #     # Base.redirect_stdin — Function
        #     # redirect_stdin([stream]) -> (rd, wr)
        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
        #     # Base.redirect_stdin — Method
        #     # redirect_stdin(f::Function, stream)
        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

        # catch err
        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
        #     println(err);
        #     # println(Base.typeof(err));
        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

        # finally
        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
        #     if Base.eof(fWIO)
        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
        #     end
        # end

        # nowTime = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        # log_text = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
        # Base.GC.gc();  # 内存回收函數 gc();

        # return ["success", response_data_String, output_file, monitor_file];
        return [response_data_String, output_file, monitor_file];
    else
        println("用於輸出數據的媒介文檔: " * output_file * " 無法被創建.");
        return ["error", output_file, "document [ output file = " * Base.string(output_file) * " ] not create."];
    end
end

# monitor_file_do_Function() 函數的遺留問題：
# 1、在正常使用 root@localhost:~# ./julia.exe ./test.jl 啓動的脚本，如何在代碼中，啓動 Julia 的多綫程模式（export JULIA_NUM_THREADS=4）？
# 從而避免當 isMonitorThreadsOrProcesses = "Multi-Threading" 或 isDoTasksOrThreads = "Tasks" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
# 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
# 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
# println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
# println(Base.Threads.threadid()); # 查看當前綫程 ID 號;

# 2、在多進程（using Distributed;Distributed.@everywhere using Distributed;Distributed.addprocs(1);）時，如何將主進程中的函數，作爲參數，複製到子進程中可見可執行？
# main-process function f1
# main-process function f2(f1) -> worker-process function f3(f1) -> worker-process function f1
# 1)、向主进程中函数 f2 传入参数 ~ 函数 f1，执行 f2。
# 2)、主进程中函数 f2 创建子进程，并将参数（函数 f1）传递到子进程中可用，在子进程中声明函数 f3，使用 f3 调用参数（函数 f1）运行。
# 3)、最终形成，在子进程中执行，传入的参数（函数 f1）的效果。
# using Distributed;
# Distributed.@everywhere using Distributed;
# function f1(Str::Core.String)::Core.String
#     Str = Str * " worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task()));
#     return Str;
# end
# function f2(a::Core.String, f1Var)
#     println(a);
#     Distributed.addprocs(1);
#     function func_wp2(b::Core.String, wp2f1Var)
#         println(b);
#         function f3(c::Core.String, wp2f3Var)
#             println(c);
#             println(wp2f3Var("f3 -> f1"));
#         end
#         f3("f3 -> f1 run", wp2f1Var);
#     end
#     Distributed.remotecall(
#         func_wp2,
#         2,
#         "f2 remotecall",
#         f1Var
#     );
# end
# f2("mainProc-f2 run", f1);

# 自動監聽指定的硬盤文檔，當硬盤指定目錄出現指定監聽的文檔時，就調用讀文檔處理數據函數;
function monitor_file_do_Function(
    monitor_file::Core.String,
    monitor_dir::Core.String,
    do_Function,
    output_dir::Core.String,
    output_file::Core.String,
    to_executable::Core.String,
    to_script::Core.String,
    temp_cache_IO_data_dir::Core.String,
    number_Worker_threads::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
    time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
    read_file_do_Function;
    isMonitorThreadsOrProcesses::Core.Union{Core.String, Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = "0",  # 0 || "0" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
    isDoTasksOrThreads::Core.String = "Tasks",  # "Tasks" || "Multi-Threading"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
    worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
    total_worker_called_number::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
) ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}

    # # print("當前協程 task: ", Base.current_task(), "\n");
    # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
    # print("當前綫程 thread 的 ID: ", Base.Threads.threadid(), "\n");
    # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
    # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
    # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
    # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
    # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
    # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
    # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
    # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
    # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
    # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
    # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
    # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
    # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

    # println(Base.Sys.CPU_THREADS)  # 4 可用 CPU 數;
    # println(Base.Filesystem.ispath(Base.Filesystem.pwd()))  # true 判斷目錄是否存在;
    # println(Base.Filesystem.isfile(Base.Filesystem.pwd()))  # true 判斷是否為文檔;
    # println(Base.Filesystem.isdir(Base.Filesystem.pwd()))  # true 判斷是否為文件夾;
    # println(Base.Sys.BINDIR)  # C:\Program Files\Julia 1.5.1\bin;
    # println(Base.PROGRAM_FILE)  # c:\Users\china\Documents\Node.js\Criss\jl\tempCodeRunnerFile.jl;
    # println(Base.Filesystem.basename(Base.Filesystem.pwd()))  # Criss;
    # # "File_Directory_and_Path";
    # println(Base.Filesystem.homedir())  # C:\Users\china;
    # println(Base.Filesystem.pwd())  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath("."))  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js\Criss;
    # # 获取路径的目录;
    # println(Base.Filesystem.dirname(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js;
    # # "/Users/juliauser/Functions_Scripts_Codes_Pipelines/Julia_Codes";
    # # 路径的末端分割;
    # println(Base.Filesystem.splitdir(Base.Filesystem.pwd()));
    # # ("c:\\Users\\china\\Documents\\Node.js", "Criss");
    # # 路径的合成;
    # println(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "temp", "intermediary_write_NodeJS.txt"));  # c:\Users\china\Documents\Node.js\temp\intermediary_write_NodeJS.txt;
    # # Base.Filesystem.cd()  # 更換工作目錄;
    # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl"))
    # # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl").mode) # 返回值為 Core.UInt64 類型數值，例如 Core.UInt64(33206);


    # 判斷傳入的參數用於傳入數據的媒介文檔路徑全名 monitor_file 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(monitor_file) 判斷 monitor_file 變量是否已經被定義過;
    if !Base.@isdefined(monitor_file) || monitor_file === "" || monitor_file === Core.nothing
        # local monitor_file = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary", "intermediary_write_NodeJS.txt"));  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(monitor_dir, "Intermediary", "intermediary_write_NodeJS.txt")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於接收傳值的媒介文檔 "../Intermediary/intermediary_write_NodeJS.txt";
        # local monitor_file = Core.nothing;  # 置空;
        println("用於傳入數據的媒介文檔路徑全名「monitor_file ∈ ", Base.typeof(monitor_file), "」不能被識別.");
        return ["error", monitor_file, "argument [ monitor_file = " * Base.string(monitor_file) * " ] typeof error, no defined."];  # "用於傳入數據的媒介文檔路徑全名「monitor_file = " * Base.string(Base.typeof(monitor_file)) * "」不能被識別.";
    elseif !Core.isa(monitor_file, Core.String)
        # 使用 Core.isa(monitor_file, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(monitor_file) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(monitor_file) === Core.String 方法判別 monitor_file 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於傳入數據的媒介文檔路徑全名「monitor_file ∈ ", Base.typeof(monitor_file), "」不合法，只接受輸入文檔路徑全名字符串.");
        return ["error", monitor_file, "argument [ monitor_file = " * Base.string(monitor_file) * " ] typeof error, not String."];  # ["error", monitor_file, "用於傳入數據的媒介文檔路徑全名「monitor_file = " * Base.string(Base.typeof(monitor_file)) * "」不合法，只接受輸入文檔路徑全名字符串."];
    end

    # 判斷傳入的參數用於傳出數據的媒介文檔路徑全名 output_file 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(output_file) 判斷 output_file 變量是否已經被定義過;
    if !Base.@isdefined(output_file) || output_file === "" || output_file === Core.nothing
        # local output_file = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary", "intermediary_write_Julia.txt"));  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(output_dir, "Intermediary", "intermediary_write_Julia.txt")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介文檔 "../Intermediary/intermediary_write_Julia.txt";
        # local output_file = Core.nothing;  # 置空;
        println("用於傳出數據的媒介文檔路徑全名「output_file ∈ ", Base.typeof(output_file), "」不能被識別.");
        return ["error", output_file, "argument [ output_file = " * Base.string(output_file) * " ] typeof error, no defined."];  # "用於傳出數據的媒介文檔路徑全名「output_file = " * Base.string(Base.typeof(output_file)) * "」不能被識別.";
    elseif !Core.isa(output_file, Core.String)
        # 使用 Core.isa(output_file, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(output_file) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(output_file) === Core.String 方法判別 output_file 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於傳出數據的媒介文檔路徑全名「output_file ∈ ", Base.typeof(output_file), "」不合法，只接受輸入文檔路徑全名字符串.");
        return ["error", output_file, "argument [ output_file = " * Base.string(output_file) * " ] typeof error, not String."];  # ["error", output_file, "用於傳出數據的媒介文檔路徑全名「output_file = " * Base.string(Base.typeof(output_file)) * "」不合法，只接受輸入文檔路徑全名字符串."];
    end

    # 判斷傳入的參數用於傳入數據的媒介目錄（文件夾）monitor_dir 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(monitor_dir) 判斷 monitor_dir 變量是否已經被定義過;
    if !Base.@isdefined(monitor_dir) || monitor_dir === "" || monitor_dir === Core.nothing
        # local monitor_dir = Base.string(Base.Filesystem.splitdir(monitor_file)[1]);  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸入傳值的媒介目錄 "../Intermediary/";
        monitor_dir = Base.string(Base.Filesystem.splitdir(monitor_file)[1]);  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸入傳值的媒介目錄 "../Intermediary/";
        # Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組;
        # local monitor_dir = Core.nothing;  # 置空;
        println("用於傳入數據的媒介目錄（文件夾）「monitor_dir ∈ ", Base.typeof(monitor_dir), "」不能被識別.");
        # return ["error", monitor_dir, "argument [ monitor_dir = " * Base.string(monitor_dir) * " ] typeof error, no defined."];  # "用於傳入數據的媒介目錄（文件夾）「monitor_dir = " * Base.string(Base.typeof(monitor_dir)) * "」不能被識別.";
    elseif !Core.isa(monitor_dir, Core.String)
        # 使用 Core.isa(monitor_dir, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(monitor_dir) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(monitor_dir) === Core.String 方法判別 monitor_dir 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於傳入數據的媒介目錄（文件夾）「monitor_dir ∈ ", Base.typeof(monitor_dir), "」不合法，只接受輸入文檔路徑全名字符串.");
        return ["error", monitor_dir, "argument [ monitor_dir = " * Base.string(monitor_dir) * " ] typeof error, not String."];  # "用於傳入數據的媒介目錄（文件夾）「monitor_dir = " * Base.string(Base.typeof(monitor_dir)) * "」不合法，只接受輸入目錄（文件夾）全名字符串.";
    # elseif monitor_dir !== Base.string(Base.Filesystem.splitdir(monitor_file)[1])
    #     # 使用 Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組，Base.Filesystem.splitdir(monitor_file) 將 monitor_file 拆分爲 (輸入媒介目錄, 輸入媒介文檔名) 兩部分;
    #     println("用於傳入數據的媒介目錄（文件夾）「monitor_dir ∈ ", Base.typeof(monitor_dir), "」不合法，與 monitor_file 文檔所在目錄不同.");
    #     return ["error", monitor_dir, "argument [ monitor_dir = " * Base.string(monitor_dir) * " ] typeof error, not content monitor_file."];  # "用於傳入數據的媒介目錄（文件夾）「monitor_dir = " * Base.string(Base.typeof(monitor_dir)) * "」不合法，與 monitor_file 文檔所在目錄不同.";
    end

    # 判斷傳入的參數用於傳出數據的媒介目錄（文件夾）output_dir 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(output_dir) 判斷 output_dir 變量是否已經被定義過;
    if !Base.@isdefined(output_dir) || output_dir === "" || output_dir === Core.nothing
        # local output_dir = Base.string(Base.Filesystem.splitdir(output_file)[1]);  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介目錄 "../Intermediary/";
        output_dir = Base.string(Base.Filesystem.splitdir(output_file)[1]);  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介目錄 "../Intermediary/";
        # Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組;
        # local output_dir = Core.nothing;  # 置空;
        println("用於傳出數據的媒介目錄（文件夾）「output_dir ∈ ", Base.typeof(output_dir), "」不能被識別.");
        # return ["error", output_dir, "argument [ output_dir = " * Base.string(output_dir) * " ] typeof error, no defined."];  # "用於傳出數據的媒介目錄（文件夾）「output_dir = " * Base.string(Base.typeof(output_dir)) * "」不能被識別.";
    elseif !Core.isa(output_dir, Core.String)
        # 使用 Core.isa(output_dir, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(output_dir) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(output_dir) === Core.String 方法判別 output_dir 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於傳出數據的媒介目錄（文件夾）「output_dir ∈ ", Base.typeof(output_dir), "」不合法，只接受輸入文檔路徑全名字符串.");
        return ["error", output_dir, "argument [ output_dir = " * Base.string(output_dir) * " ] typeof error, not String."];  # "用於傳出數據的媒介目錄（文件夾）「output_dir = " * Base.string(Base.typeof(output_dir)) * "」不合法，只接受輸入目錄（文件夾）全名字符串.";
    # elseif output_dir !== Base.string(Base.Filesystem.splitdir(output_file)[1])
    #     # 使用 Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組，Base.Filesystem.splitdir(output_file) 將 output_file 拆分爲 (輸出媒介目錄, 輸出媒介文檔名) 兩部分;
    #     println("用於傳出數據的媒介目錄（文件夾）「output_dir ∈ ", typeof(output_dir), "」不合法，與 output_file 文檔所在目錄不同.");
    #     return ["error", output_dir, "argument [ output_dir = " * Base.string(output_dir) * " ] typeof error, not content output_file."];  # "用於傳出數據的媒介目錄（文件夾）「output_dir = " * Base.string(Base.typeof(output_dir)) * "」不合法，與 output_file 文檔所在目錄不同.";
    end

    # 判斷傳入的參數用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）temp_cache_IO_data_dir 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(temp_cache_IO_data_dir) 判斷 temp_cache_IO_data_dir 變量是否已經被定義過;
    if !Base.@isdefined(temp_cache_IO_data_dir) || temp_cache_IO_data_dir === "" || temp_cache_IO_data_dir === Core.nothing
        # local temp_cache_IO_data_dir = Base.string(Base.Filesystem.splitdir(monitor_file)[1]);  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾） "../Intermediary/";
        temp_cache_IO_data_dir = monitor_dir;  # Base.string(Base.Filesystem.splitdir(monitor_file)[1]);  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾） "../Intermediary/";
        # Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組;
        # local temp_cache_IO_data_dir = Core.nothing;  # 置空;
        println("用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）「temp_cache_IO_data_dir ∈ ", Base.typeof(temp_cache_IO_data_dir), "」不能被識別.");
        # return ["error", temp_cache_IO_data_dir, "argument [ temp_cache_IO_data_dir = " * Base.string(temp_cache_IO_data_dir) * " ] typeof error, no defined."];  # "用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）「temp_cache_IO_data_dir = " * Base.string(Base.typeof(temp_cache_IO_data_dir)) * "」不能被識別.";
    elseif !Core.isa(temp_cache_IO_data_dir, Core.String)
        # 使用 Core.isa(temp_cache_IO_data_dir, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(temp_cache_IO_data_dir) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(temp_cache_IO_data_dir) === Core.String 方法判別 temp_cache_IO_data_dir 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）「temp_cache_IO_data_dir ∈ ", Base.typeof(temp_cache_IO_data_dir), "」不合法，只接受輸入文檔路徑全名字符串.");
        return ["error", temp_cache_IO_data_dir, "argument [ temp_cache_IO_data_dir = " * Base.string(temp_cache_IO_data_dir) * " ] typeof error, not String."];  # "用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）「temp_cache_IO_data_dir = " * Base.string(Base.typeof(temp_cache_IO_data_dir)) * "」不合法，只接受輸入目錄（文件夾）全名字符串.";
    end

    # 判斷傳入的具體執行處理數據的函數參數 do_Function 是否已定義且為函數，使用函數 Base.@isdefined(do_Function) 判斷 do_Function 變量是否已經被定義過;
    if !Base.@isdefined(do_Function) || do_Function === "" || do_Function === Core.nothing
        # local do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # local do_Function = Core.nothing;  # 置空;
        # println("傳入的參數，指定的變量「do_Function ∈ ", Base.typeof(do_Function), "」不能被識別.");
        # return "argument [ do_Function = " * Base.string(do_Function) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「do_Function = " * Base.string(Base.typeof(do_Function)) * "」不能被識別.";
    elseif !(Base.typeof(do_Function) <: Core.Function)
        # 使用 Core.isa(do_Function, Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_Function) <: Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_Function) <: Function 方法判別 do_Function 變量的類型是否包含於函數Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「do_Function ∈ ", Base.typeof(do_Function), "」不是一個函數類型的變量.");
        return "argument [ do_Function = " * Base.string(do_Function) * " ] typeof error, not Function."  # "傳入的參數，指定的變量「do_Function = " * Base.string(Base.typeof(do_Function)) * "」不是一個函數類型的變量.";

        # try
        #     if length(methods(do_Function)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的自定義系統暫停時長參數 time_sleep 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(time_sleep) 判斷 time_sleep 變量是否已經被定義過;
    if !Base.@isdefined(time_sleep) || time_sleep === "" || time_sleep === Core.nothing
        # local time_sleep = Core.Float64(0.02);  # Core.Float64 類型變量，20 毫秒，系統暫停等待時長;
        time_sleep = Core.Float64(0.02);  # Float64 類型變量，20 毫秒，系統暫停等待時長;
        # local time_sleep = Core.nothing;  # 置空;
        # println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不能被識別.");
        # return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不能被識別.";
    elseif !(Base.typeof(time_sleep) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(time_sleep, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判別 time_sleep 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不是一個數值類型的變量.");
        return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的自定義多綫程并發數目參數 number_Worker_threads 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(number_Worker_threads) 判斷 number_Worker_threads 變量是否已經被定義過;
    if !Base.@isdefined(number_Worker_threads) || number_Worker_threads === "" || number_Worker_threads === Core.nothing
        # local number_Worker_threads = Core.UInt8(0);  # Core.UInt8 類型，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
        number_Worker_threads = Core.UInt8(0);  # Core.UInt8 類型，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
        # local number_Worker_threads = Core.nothing;  # 置空;
        # println("傳入的參數，指定的變量「number_Worker_threads ∈ ", Base.typeof(number_Worker_threads), "」不能被識別.");
        # return "argument [ number_Worker_threads = " * Base.string(number_Worker_threads) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「number_Worker_threads = " * Base.string(Base.typeof(number_Worker_threads)) * "」不能被識別.";
    elseif !(Base.typeof(number_Worker_threads) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(number_Worker_threads, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判別 number_Worker_threads 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「number_Worker_threads ∈ ", Base.typeof(number_Worker_threads), "」不是一個數值類型的變量.");
        return "argument [ number_Worker_threads = " * Base.string(number_Worker_threads) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「number_Worker_threads = " * Base.string(Base.typeof(number_Worker_threads)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的參數用於指定監聽并發的層次（多綫程、多進程）的變量 isMonitorThreadsOrProcesses 是否已定義且為字符串類型 Union{Core.String, Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8}，使用函數 Base.@isdefined(isMonitorThreadsOrProcesses) 判斷 isMonitorThreadsOrProcesses 變量是否已經被定義過;
    if !Base.@isdefined(isMonitorThreadsOrProcesses) || isMonitorThreadsOrProcesses === "" || isMonitorThreadsOrProcesses === Core.nothing
        # local isMonitorThreadsOrProcesses = 0 || "0" || "Multi-Threading" || "Multi-Processes";
        # local isMonitorThreadsOrProcesses = Core.nothing;  # 置空;
        println("指定監聽并發的層次（多綫程、多進程）的變量「isMonitorThreadsOrProcesses ∈ ", Base.typeof(isMonitorThreadsOrProcesses), "」不能被識別.");
        return ["error", isMonitorThreadsOrProcesses, "argument [ isMonitorThreadsOrProcesses = " * Base.string(isMonitorThreadsOrProcesses) * " ] typeof error, no defined."];  # "指定監聽并發的層次（多綫程、多進程）的變量「isMonitorThreadsOrProcesses = " * Base.string(Base.typeof(isMonitorThreadsOrProcesses)) * "」不能被識別.";
    elseif !(Base.typeof(isMonitorThreadsOrProcesses) <: Core.Union{Core.String, Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # || (Core.Int64(isMonitorThreadsOrProcesses) !== Core.Int64(0) && isMonitorThreadsOrProcesses !== "0" && isMonitorThreadsOrProcesses !== "Multi-Threading" && isMonitorThreadsOrProcesses !== "Multi-Processes")
        # 使用 Core.isa(isMonitorThreadsOrProcesses, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isMonitorThreadsOrProcesses) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isMonitorThreadsOrProcesses) === Core.String 方法判別 isMonitorThreadsOrProcesses 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("指定監聽并發的層次（多綫程、多進程）的變量「isMonitorThreadsOrProcesses ", Base.typeof(isMonitorThreadsOrProcesses), "」不合法，只接受輸入：Core.Int64(0) || \"0\" || \"Multi-Threading\" || \"Multi-Processes\" 四個值.");
        return ["error", isMonitorThreadsOrProcesses, "argument [ isMonitorThreadsOrProcesses = " * Base.string(isMonitorThreadsOrProcesses) * " ] typeof error, not String or Integer."];  # ["error", isMonitorThreadsOrProcesses, "指定監聽并發的層次（多綫程、多進程）的變量「isMonitorThreadsOrProcesses = " * Base.string(Base.typeof(isMonitorThreadsOrProcesses)) * "」不合法，只接受輸入：Core.Int64(0) || \"0\" || \"Multi-Threading\" || \"Multi-Processes\" 四個值."];
    end

    # 判斷傳入的參數用於指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量 isDoTasksOrThreads 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(isDoTasksOrThreads) 判斷 isDoTasksOrThreads 變量是否已經被定義過;
    if !Base.@isdefined(isDoTasksOrThreads) || isDoTasksOrThreads === "" || isDoTasksOrThreads === Core.nothing
        # local isDoTasksOrThreads = "Tasks" || "Multi-Threading";
        # local isDoTasksOrThreads = Core.nothing;  # 置空;
        println("指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isDoTasksOrThreads ∈ ", Base.typeof(isDoTasksOrThreads), "」不能被識別.");
        return ["error", isDoTasksOrThreads, "argument [ isDoTasksOrThreads = " * Base.string(isDoTasksOrThreads) * " ] typeof error, no defined."];  # "指定監聽并發的層次（多綫程、多進程）的變量「isDoTasksOrThreads = " * Base.string(Base.typeof(isDoTasksOrThreads)) * "」不能被識別.";
    elseif !Core.isa(isDoTasksOrThreads, Core.String) || (isDoTasksOrThreads !== "Tasks" && isDoTasksOrThreads !== "Multi-Threading")
        # 使用 Core.isa(isDoTasksOrThreads, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isDoTasksOrThreads) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isDoTasksOrThreads) === Core.String 方法判別 isDoTasksOrThreads 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isDoTasksOrThreads ", Base.typeof(isDoTasksOrThreads), "」不合法，只接受輸入：\"Tasks\" || \"Multi-Threading\" 兩個值.");
        return ["error", isDoTasksOrThreads, "argument [ isDoTasksOrThreads = " * Base.string(isDoTasksOrThreads) * " ] typeof error, not String."];  # ["error", isDoTasksOrThreads, "指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isDoTasksOrThreads = " * Base.string(Base.typeof(isDoTasksOrThreads)) * "」不合法，只接受輸入：\"Tasks\" || \"Multi-Threading\" 兩個值."];
    end

    # 判斷傳入的參數用於保存創建的子進程的字典變量 worker_queues_Dict 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(worker_queues_Dict) 判斷 worker_queues_Dict 變量是否已經被定義過;
    if !Base.@isdefined(worker_queues_Dict) || worker_queues_Dict === "" || worker_queues_Dict === Core.nothing
        worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.Task}() 用於保存創建的子進程的字典變量;        
        # println("用於保存創建的子進程的字典變量「worker_queues_Dict ∈ ", Base.typeof(worker_queues_Dict), "」不能被識別.");
        # return ["error", worker_queues_Dict, "argument [ worker_queues_Dict ∈ " * Base.string(worker_queues_Dict) * " ] typeof error, no defined."];  # "用於保存創建的子進程的字典變量「worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * "」不能被識別.";
    elseif !(Base.typeof(worker_queues_Dict) <: Base.Dict)
        # 使用 Core.isa(isDoTasksOrThreads, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isDoTasksOrThreads) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isDoTasksOrThreads) === Core.String 方法判別 isDoTasksOrThreads 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於保存創建的子進程的字典變量「worker_queues_Dict ∈ ", Base.typeof(worker_queues_Dict), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
        return ["error", worker_queues_Dict, "argument [ worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * " ] typeof error, not Dict."];  # ["error", worker_queues_Dict, "用於保存創建的子進程的字典變量「worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    end

    # 判斷傳入的參數用於記錄每個綫程纍加的被調用運算的總次數的字典變量 total_worker_called_number 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(total_worker_called_number) 判斷 total_worker_called_number 變量是否已經被定義過;
    if !Base.@isdefined(total_worker_called_number) || total_worker_called_number === "" || total_worker_called_number === Core.nothing
        # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
        total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
        # println("用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ ", Base.typeof(total_worker_called_number), "」不能被識別.");
        # return ["error", total_worker_called_number, "argument [ total_worker_called_number ∈ " * Base.string(total_worker_called_number) * " ] typeof error, no defined."];  # "用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * "」不能被識別.";
    elseif !(Base.typeof(total_worker_called_number) <: Base.Dict)
        # 使用 Core.isa(isDoTasksOrThreads, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isDoTasksOrThreads) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isDoTasksOrThreads) === Core.String 方法判別 isDoTasksOrThreads 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ ", Base.typeof(total_worker_called_number), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
        return ["error", total_worker_called_number, "argument [ total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * " ] typeof error, not Dict."];  # ["error", total_worker_called_number, "用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    end

    # 檢查創建用於輸入傳值的監聽媒介目錄（文件夾）;
    # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介目錄（文件夾）是否存在，如果不存在，則創建目錄，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
    # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isdir(monitor_dir) 方法判斷是否為目錄（文件夾）;
    if !(Base.Filesystem.ispath(monitor_dir) && Base.Filesystem.isdir(monitor_dir))
        # 同步創建，創建用於傳入數據的監聽媒介文件夾;
        try
            # 同步遞歸創建目錄 Base.Filesystem.mkpath(path::AbstractString; mode::Unsigned=0o777)，返回值(return) path;
            Base.Filesystem.mkpath(monitor_dir, mode=0o777);  # 同步遞歸創建目錄，返回值(return) path;
            # println("目錄: " * monitor_dir * " 創建成功.");
        catch err
            println("用於輸入數據的媒介文件夾: " * monitor_dir * " 無法創建.");
            println(err);
            # println(Base.typeof(err));
            return ["error", monitor_dir, "path [ monitor_dir = " * Base.string(monitor_dir) * " ] mkpath fail."];
        end
    end

    # 判斷媒介文件夾是否創建成功;
    if !(Base.Filesystem.ispath(monitor_dir) && Base.Filesystem.isdir(monitor_dir))
        println("用於傳值的媒介文件夾 [ " * monitor_dir * " ] 無法被創建.");
        return ["error", monitor_dir, "path [ monitor_dir = " * Base.string(monitor_dir) * " ] mkpath fail."];
    elseif Base.stat(monitor_dir).mode !== Core.UInt64(16822) && Base.stat(monitor_dir).mode !== Core.UInt64(16895)
        # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(monitor_dir) 函數讀取文檔信息，使用 Base.stat(monitor_dir).mode 方法提取文檔權限碼;
        # println("用於傳值的媒介文件夾 [ " * monitor_dir * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
        try
            # 使用 Base.Filesystem.chmod(monitor_dir, mode=0o777; recursive=true) 函數修改文檔操作權限;
            # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
            Base.Filesystem.chmod(monitor_dir, mode=0o777; recursive=true);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
            # println("目錄: " * monitor_dir * " 操作權限成功修改爲 mode=0o777 .");

            # 八進制值    說明
            # 0o400      所有者可讀
            # 0o200      所有者可寫
            # 0o100      所有者可執行或搜索
            # 0o40       群組可讀
            # 0o20       群組可寫
            # 0o10       群組可執行或搜索
            # 0o4        其他人可讀
            # 0o2        其他人可寫
            # 0o1        其他人可執行或搜索
            # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
            # 數字	說明
            # 7	可讀、可寫、可執行
            # 6	可讀、可寫
            # 5	可讀、可執行
            # 4	唯讀
            # 3	可寫、可執行
            # 2	只寫
            # 1	只可執行
            # 0	沒有許可權
            # 例如，八進制值 0o765 表示：
            # 1) 、所有者可以讀取、寫入和執行該文檔；
            # 2) 、群組可以讀和寫入該文檔；
            # 3) 、其他人可以讀取和執行該文檔；
            # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
            # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

        catch err
            println("用於輸入數據的媒介文件夾: " * monitor_dir * " 無法修改操作權限爲 mode=0o777 .");
            println(err);
            # println(Base.typeof(err));
            return ["error", monitor_dir, "path [ monitor_dir = " * Base.string(monitor_dir) * " ] change the permissions mode=0o777 fail."];
        end
    end

    # 判斷文件夾權限;
    if !(Base.stat(monitor_dir).mode === Core.UInt64(16822) || Base.stat(monitor_dir).mode === Core.UInt64(16895))
        # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(monitor_dir) 函數讀取文檔信息，使用 Base.stat(monitor_dir).mode 方法提取文檔權限碼;
        println("用於輸入數據的媒介文件夾: " * monitor_dir * " 無法修改操作權限爲 mode=0o777 .");
        return ["error", monitor_dir, "path [ monitor_dir = " * Base.string(monitor_dir) * " ] change the permissions mode=0o777 fail."];
    end

    # # 可以先改變工作目錄到 static 路徑;
    # println("Starting directory: ", Base.Filesystem.abspath(Base.Filesystem.pwd()));  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # try
    #     Base.Filesystem.cd(monitor_dir);  # 更換工作目錄;
    # catch err
    #     println(err);
    # end
    # 同步讀取指定文件夾的内容 Base.Filesystem.readdir();

    # 檢查創建用於輸出傳值的監聽媒介目錄（文件夾）;
    # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳出數據的媒介目錄（文件夾）是否存在，如果不存在，則創建目錄，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
    # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isdir(output_dir) 方法判斷是否為目錄（文件夾）;
    if !(Base.Filesystem.ispath(output_dir) && Base.Filesystem.isdir(output_dir))
        # 同步創建，創建用於傳出數據的監聽媒介文件夾;
        try
            # 同步遞歸創建目錄 Base.Filesystem.mkpath(path::AbstractString; mode::Unsigned=0o777)，返回值(return) path;
            Base.Filesystem.mkpath(output_dir, mode=0o777);  # 同步遞歸創建目錄，返回值(return) path;
            # println("目錄: " * output_dir * " 創建成功.");
        catch err
            println("用於輸出數據的媒介文件夾: " * output_dir * " 無法創建.");
            println(err);
            # println(Base.typeof(err));
            return ["error", output_dir, "path [ output_dir = " * Base.string(output_dir) * " ] mkpath fail."];
        end
    end

    # 判斷媒介文件夾是否創建成功;
    if !(Base.Filesystem.ispath(output_dir) && Base.Filesystem.isdir(output_dir))
        println("用於傳值的媒介文件夾 [ " * output_dir * " ] 無法被創建.");
        return ["error", output_dir, "path [ output_dir = " * Base.string(output_dir) * " ] mkpath fail."];
    elseif Base.stat(output_dir).mode !== Core.UInt64(16822) && Base.stat(output_dir).mode !== Core.UInt64(16895)
        # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(output_dir) 函數讀取文檔信息，使用 Base.stat(output_dir).mode 方法提取文檔權限碼;
        # println("用於傳值的媒介文件夾 [ " * output_dir * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
        try
            # 使用 Base.Filesystem.chmod(output_dir, mode=0o777; recursive=true) 函數修改文檔操作權限;
            # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
            Base.Filesystem.chmod(output_dir, mode=0o777; recursive=true);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
            # println("目錄: " * output_dir * " 操作權限成功修改爲 mode=0o777 .");

            # 八進制值    說明
            # 0o400      所有者可讀
            # 0o200      所有者可寫
            # 0o100      所有者可執行或搜索
            # 0o40       群組可讀
            # 0o20       群組可寫
            # 0o10       群組可執行或搜索
            # 0o4        其他人可讀
            # 0o2        其他人可寫
            # 0o1        其他人可執行或搜索
            # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
            # 數字	說明
            # 7	可讀、可寫、可執行
            # 6	可讀、可寫
            # 5	可讀、可執行
            # 4	唯讀
            # 3	可寫、可執行
            # 2	只寫
            # 1	只可執行
            # 0	沒有許可權
            # 例如，八進制值 0o765 表示：
            # 1) 、所有者可以讀取、寫入和執行該文檔；
            # 2) 、群組可以讀和寫入該文檔；
            # 3) 、其他人可以讀取和執行該文檔；
            # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
            # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

        catch err
            println("用於輸出數據的媒介文件夾: " * output_dir * " 無法修改操作權限爲 mode=0o777 .");
            println(err);
            # println(Base.typeof(err));
            return ["error", output_dir, "path [ output_dir = " * Base.string(output_dir) * " ] change the permissions mode=0o777 fail."];
        end
    end

    # 判斷文件夾權限;
    if !(Base.stat(output_dir).mode === Core.UInt64(16822) || Base.stat(output_dir).mode === Core.UInt64(16895))
        # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(output_dir) 函數讀取文檔信息，使用 Base.stat(output_dir).mode 方法提取文檔權限碼;
        println("用於輸出數據的媒介文件夾: " * output_dir * " 無法修改操作權限爲 mode=0o777 .");
        return ["error", output_dir, "path [ output_dir = " * Base.string(output_dir) * " ] change the permissions mode=0o777 fail."];
    end

    # 檢查創建用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）;
    # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）是否存在，如果不存在，則創建目錄，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
    # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isdir(temp_cache_IO_data_dir) 方法判斷是否為目錄（文件夾）;
    if !(Base.Filesystem.ispath(temp_cache_IO_data_dir) && Base.Filesystem.isdir(temp_cache_IO_data_dir))
        # 同步創建，創建用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）;
        try
            # 同步遞歸創建目錄 Base.Filesystem.mkpath(path::AbstractString; mode::Unsigned=0o777)，返回值(return) path;
            Base.Filesystem.mkpath(temp_cache_IO_data_dir, mode=0o777);  # 同步遞歸創建目錄，返回值(return) path;
            # println("目錄: " * temp_cache_IO_data_dir * " 創建成功.");
        catch err
            println("用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）: " * temp_cache_IO_data_dir * " 無法創建.");
            println(err);
            # println(Base.typeof(err));
            return ["error", temp_cache_IO_data_dir, "path [ temp_cache_IO_data_dir = " * Base.string(temp_cache_IO_data_dir) * " ] mkpath fail."];
        end
    end

    # 判斷媒介文件夾是否創建成功;
    if !(Base.Filesystem.ispath(temp_cache_IO_data_dir) && Base.Filesystem.isdir(temp_cache_IO_data_dir))
        println("用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾） [ " * temp_cache_IO_data_dir * " ] 無法被創建.");
        return ["error", temp_cache_IO_data_dir, "path [ temp_cache_IO_data_dir = " * Base.string(temp_cache_IO_data_dir) * " ] mkpath fail."];
    elseif Base.stat(temp_cache_IO_data_dir).mode !== Core.UInt64(16822) && Base.stat(temp_cache_IO_data_dir).mode !==Core.UInt64(16895)
        # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(temp_cache_IO_data_dir) 函數讀取文檔信息，使用 Base.stat(temp_cache_IO_data_dir).mode 方法提取文檔權限碼;
        # println("用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾） [ " * temp_cache_IO_data_dir * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
        try
            # 使用 Base.Filesystem.chmod(temp_cache_IO_data_dir, mode=0o777; recursive=true) 函數修改文檔操作權限;
            # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
            Base.Filesystem.chmod(temp_cache_IO_data_dir, mode=0o777; recursive=true);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
            # println("目錄: " * temp_cache_IO_data_dir * " 操作權限成功修改爲 mode=0o777 .");

            # 八進制值    說明
            # 0o400      所有者可讀
            # 0o200      所有者可寫
            # 0o100      所有者可執行或搜索
            # 0o40       群組可讀
            # 0o20       群組可寫
            # 0o10       群組可執行或搜索
            # 0o4        其他人可讀
            # 0o2        其他人可寫
            # 0o1        其他人可執行或搜索
            # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
            # 數字	說明
            # 7	可讀、可寫、可執行
            # 6	可讀、可寫
            # 5	可讀、可執行
            # 4	唯讀
            # 3	可寫、可執行
            # 2	只寫
            # 1	只可執行
            # 0	沒有許可權
            # 例如，八進制值 0o765 表示：
            # 1) 、所有者可以讀取、寫入和執行該文檔；
            # 2) 、群組可以讀和寫入該文檔；
            # 3) 、其他人可以讀取和執行該文檔；
            # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
            # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

        catch err
            println("用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）: " * temp_cache_IO_data_dir * " 無法修改操作權限爲 mode=0o777 .");
            println(err);
            # println(Base.typeof(err));
            return ["error", temp_cache_IO_data_dir, "path [ temp_cache_IO_data_dir = " * Base.string(temp_cache_IO_data_dir) * " ] change the permissions mode=0o777 fail."];
        end
    end

    # 判斷文件夾權限;
    if !(Base.stat(temp_cache_IO_data_dir).mode === Core.UInt64(16822) || Base.stat(temp_cache_IO_data_dir).mode === Core.UInt64(16895))
        # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(temp_cache_IO_data_dir) 函數讀取文檔信息，使用 Base.stat(temp_cache_IO_data_dir).mode 方法提取文檔權限碼;
        println("用於暫存輸入與輸出傳值的臨時文檔隊列的臨時監聽媒介目錄（文件夾）: " * temp_cache_IO_data_dir * " 無法修改操作權限爲 mode=0o777 .");
        return ["error", temp_cache_IO_data_dir, "path [ temp_cache_IO_data_dir = " * Base.string(temp_cache_IO_data_dir) * " ] change the permissions mode=0o777 fail."];
    end

    # 使用 Julia 原生的 FileWatching 文件事件模組的 FileWatching.watch_file(path::AbstractString, timeout_s::Real=-1) 方法監聽指定文檔被更改事件 "D:\\temp\\intermediary_write_NodeJS.txt";
    # 使用 Julia 原生的 FileWatching 文件事件模組的 FileWatching.watch_folder(path::AbstractString, timeout_s::Real=-1) 方法監聽指定目錄（文件夾）被更改事件 "D:\\temp\\";
    # 或者使用 Julia 原生的 FileWatching 文件事件模組的 FileWatching.poll_file(path::AbstractString, interval_s::Real=5.007, timeout_s::Real=-1) -> (previous::StatStruct, current) 方法監聽指定文檔被更改事件 "D:\\temp\\intermediary_write_NodeJS.txt";
    # Monitor a file for changes by polling every interval_s seconds until a change occurs or timeout_s seconds have elapsed. The interval_s should be a long period; the default is 5.007 seconds.
    # Returns a pair of status objects (previous, current) when a change is detected. The previous status is always a StatStruct, but it may have all of the fields zeroed (indicating the file didn't previously exist, or wasn't previously accessible).
    # The current status object may be a StatStruct, an EOFError (indicating the timeout elapsed), or some other Exception subtype (if the stat operation failed - for example, if the path does not exist).
    # To determine when a file was modified, compare current Core.isa StatStruct && mtime(prev) != mtime(current) to detect notification of changes. However, using watch_file for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.
    # 監視文檔的更改事件，方法是每隔 interval_s 秒輪詢一次，直到發生更改或超時 timeout_s 秒，輪詢間隔時長 interval_s 設置不應太短，預設值為 5.007 秒;
    # 檢測到更改時返回一對狀態對象（previous, current），更改前的狀態對象 previous 始終是 StatStruct，但它可能會將所有字段歸零（表示該文檔以前不存在，或者以前不可訪問）;
    # 現在的狀態對象 current 可以是 StatStruct、EOFError（表示超時已過）或者其它的一些異常 Exception 的子類型（如果使用 Base.stat("file") 函數讀取文檔信息操作失敗，例如，如果路徑不存在）;
    # 要確定文檔何時被修改，請比較 current Core.isa StatStruct && mtime(prev) != mtime(current) 檢測更改通知;

    # 使用 Julia 原生的定時器 Base.Timer(callback::Function, delay; interval = 0) 方法，自定義編寫監聽動作代碼，實現監聽功能;
    # 創建一個計時器，用於喚醒等待它的任務（通過調用 timer 對象上的 wait 方法）並調用回調函數;
    # 等待的任務被喚醒，回調函數在延遲秒的初始延遲後被調用，然後以秒為單位以給定的間隔時長重複，如果間隔時長設定爲等於 0，則計時器只會被觸發一次，回調函數是一個參數（計時器本身）調用的，當計時器關閉（通過 close() 方法）時，等待任務會被錯誤喚醒，使用 isopen() 方法，可以檢查計時器是否仍然處於活動狀態;
    # 如下示例，第一個數字在延遲兩秒鐘後打印輸出到控制臺，然後快速打印下面的數字;
    # Create a timer that wakes up tasks waiting for it (by calling wait on the timer object) and calls the function callback.
    # Waiting tasks are woken and the function callback is called after an initial delay of delay seconds, and then repeating with the given interval in seconds. If interval is equal to 0, the timer is only triggered once. The function callback is called with a single argument, the timer itself. When the timer is closed (by close waiting tasks are woken with an error. Use isopen to check whether a timer is still active.
    # Examples:
    # Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.
    # begin
    #     i = 0
    #     cb(timer) = (global i += 1; println(i))
    #     t = Timer(cb, 2, interval=0.2)
    #     println(Base.typeof(t))
    #     println(t)
    #     wait(t)
    #     Base.sleep(0.5)
    #     close(t)
    # end
    # 1
    # 2
    # 3

    # SharedArrays.SharedArray{T}(dims::NTuple; init=false, pids=Int[]);
    # input_queues_array = SharedArrays.SharedArray{Base.Dict{Core.String, Core.Any}, 1}(init=false, pids=[Distributed.myid()]);  # 需要事先加載原生的共享數組模組 using SharedArrays 模組，并需要使用廣播關鍵字 Distributed.@everywhere SharedArrays 在所有子進程中加載指定模組或函數或變量;
    input_queues_array = Core.Array{Base.Dict{Core.String, Core.Any}, 1}();  # 傳入數據等待運算的隊列數組;
    # input_queues_array = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
    # input_queues_array = Core.Array{Base.Dict{Core.String, Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}}, 1}();  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;

    # output_queues_array = SharedArrays.SharedArray{Base.Dict{Core.String, Core.Any}, 1}(init=false, pids=[Distributed.myid()]);  # 需要事先加載原生的共享數組模組 using SharedArrays 模組，并需要使用廣播關鍵字 Distributed.@everywhere SharedArrays 在所有子進程中加載指定模組或函數或變量;
    output_queues_array = Core.Array{Base.Dict{Core.String, Core.Any}, 1}();  # 傳出數據等待寫入正式用於傳出數據的媒介文檔的隊列數組;

    # Distributed.RemoteChannel(f::Function, pid::Integer=myid());
    # Distributed.@everywhere rc2to = Distributed.RemoteChannel(()->Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    # Distributed.@everywhere rc2from = Distributed.RemoteChannel(()->Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    # Distributed.@everywhere rc3to = Distributed.RemoteChannel(()->Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    # Distributed.@everywhere rc3from = Distributed.RemoteChannel(()->Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    # Distributed.@everywhere rc4to = Distributed.RemoteChannel(()->Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    # Distributed.@everywhere rc4from = Distributed.RemoteChannel(()->Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    rc2to = Distributed.RemoteChannel(()->Base.Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    rc2from = Distributed.RemoteChannel(()->Base.Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    rc3to = Distributed.RemoteChannel(()->Base.Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    rc3from = Distributed.RemoteChannel(()->Base.Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    rc4to = Distributed.RemoteChannel(()->Base.Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());
    rc4from = Distributed.RemoteChannel(()->Base.Channel{Base.Dict{Core.String, Core.Any}}(1), Distributed.myid());

    function func_Exit()

        if isMonitorThreadsOrProcesses === "Multi-Processes" || isMonitorThreadsOrProcesses === "Multi-Threading"

            RemoteChannel_Data_Dict = Base.Dict{Core.String, Core.Any}(
                # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                "monitor_file" => monitor_file,
                "monitor_dir" => monitor_dir,
                # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                "output_dir" => output_dir,
                "output_file" => output_file,
                "temp_cache_IO_data_dir" => temp_cache_IO_data_dir,
                "to_executable" => to_executable,
                "to_script" => to_script,
                "input_queues_array" => input_queues_array,
                "output_queues_array" => output_queues_array,
                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                "label" => "exit",
                "message" => "exit worker process."
            );

            if Base.isopen(rc2to)
                RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_file() > worker process-2 be exit.";
                Base.put!(rc2to, RemoteChannel_Data_Dict);
                Base.close(rc2to);
            end

            if Base.isopen(rc3to)
                RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_input_queues() > worker process-3 be exit.";
                Base.put!(rc3to, RemoteChannel_Data_Dict);
                Base.close(rc3to);
            end

            if Base.isopen(rc4to)
                RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_output_queues() > worker process-4 be exit.";
                Base.put!(rc4to, RemoteChannel_Data_Dict);
                Base.close(rc4to);
            end

            RemoteChannel_Data_Dict = Core.nothing;

            # if Base.isready(rc2from)
            #     # rc2Dict = Base.take!(rc2from);
            #     for rc2Dict in rc2from
            #         # input_queues_array = rc2Dict["input_queues_array"];
            #         # output_queues_array = rc2Dict["output_queues_array"];
            #         if rc2Dict["label"] === "exit"
            #             println(rc2Dict["message"]);
            #         end
            #     end
            #     # rc2Dict = Core.nothing;
            # end

            # if Base.isready(rc3from)
            #     # rc3Dict = Base.take!(rc3from);
            #     for rc3Dict in rc3from
            #         # input_queues_array = rc3Dict["input_queues_array"];
            #         # output_queues_array = rc3Dict["output_queues_array"];
            #         if rc3Dict["label"] === "exit"
            #             println(rc3Dict["message"]);
            #         end
            #     end
            #     # rc3Dict = Core.nothing;
            # end

            # if Base.isready(rc4from)
            #     # rc4Dict = Base.take!(rc4from);
            #     for rc4Dict in rc4from
            #         # input_queues_array = rc4Dict["input_queues_array"];
            #         # output_queues_array = rc4Dict["output_queues_array"];
            #         if rc4Dict["label"] === "exit"
            #             println(rc4Dict["message"]);
            #         end
            #     end
            #     # rc4Dict = Core.nothing;
            # end
        end
    end
    Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

    # 監聽文件夾，監測指定目錄下是否有新增或刪除文檔或文件夾的動作;
    input_file_NUM = Core.UInt64(0);  # 監聽到的第幾次傳入媒介文檔;

    # 創建一個自定義的函數，當計時器輪詢時調用，用以實現當指定的被監聽的用於傳輸數據的媒介文檔出現時的具體操作動作，監聽指定的硬盤用於傳數據的媒介文檔，當出現監聽的目標文檔時，激活處理函數;
    function func_Monitor_file(
        monitor_file::Core.String,
        # monitor_dir::Core.String,
        # do_Function,
        # output_dir::Core.String,
        output_file::Core.String,
        to_executable::Core.String,
        to_script::Core.String,
        temp_cache_IO_data_dir::Core.String,
        # number_Worker_threads::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
        time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
        # output_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1},
        input_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1}
    ) ::Core.Array{Core.Any, 1}

        # # print("當前協程 task: ", Base.current_task(), "\n");
        # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
        # print("當前綫程 thread 的 PID: ", Base.Threads.threadid(), "\n");
        # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
        # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
        # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
        # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
        # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
        # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
        # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
        # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
        # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
        # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
        # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
        # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
        # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

        # output_queues_array = Base.deepcopy(output_queues);
        input_queues_array = Base.deepcopy(input_queues);

        # 監聽指定的硬盤用於傳數據的媒介文檔，當出現監聽的目標文檔時，激活處理函數;
        # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介文檔是否存在，如果不存在，則中止函數退出，如果存在則判斷操作權限，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
        # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isfile(monitor_file) 方法判斷是否為文檔;
        if Base.Filesystem.ispath(monitor_file) && Base.Filesystem.isfile(monitor_file)

            # global input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;
            input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;

            # 檢查指定媒介文檔的操作權限是否爲可讀并且可寫，如無可讀可寫權限，則對其修改權限;
            if Base.stat(monitor_file).mode !== Core.UInt64(33206) && Base.stat(monitor_file).mode !== Core.UInt64(33279)
                # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(monitor_file) 函數讀取文檔信息，使用 Base.stat(monitor_file).mode 方法提取文檔權限碼;
                # println("用於傳值的媒介文檔 [ " * monitor_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                try
                    # 使用 Base.Filesystem.chmod(monitor_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
                    # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                    Base.Filesystem.chmod(monitor_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                    # println("文檔: " * monitor_file * " 操作權限成功修改爲 mode=0o777 .");

                    # 八進制值    說明
                    # 0o400      所有者可讀
                    # 0o200      所有者可寫
                    # 0o100      所有者可執行或搜索
                    # 0o40       群組可讀
                    # 0o20       群組可寫
                    # 0o10       群組可執行或搜索
                    # 0o4        其他人可讀
                    # 0o2        其他人可寫
                    # 0o1        其他人可執行或搜索
                    # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                    # 數字	說明
                    # 7	可讀、可寫、可執行
                    # 6	可讀、可寫
                    # 5	可讀、可執行
                    # 4	唯讀
                    # 3	可寫、可執行
                    # 2	只寫
                    # 1	只可執行
                    # 0	沒有許可權
                    # 例如，八進制值 0o765 表示：
                    # 1) 、所有者可以讀取、寫入和執行該文檔；
                    # 2) 、群組可以讀和寫入該文檔；
                    # 3) 、其他人可以讀取和執行該文檔；
                    # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                    # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                catch err
                    println("用於輸入數據的媒介文檔: " * monitor_file * " 無法修改操作權限爲 mode=0o777 .");
                    println(err);
                    # println(Base.typeof(err));

                    # Julia提供了許多類型的錯誤：
                    # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                    # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                    # BoundsError：在索引陣列時嘗試訪問越界元素。
                    # DivideError：這是數字除以0時的結果。
                    # DomainError：有效域之外的參數。
                    # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                    # InexactError：嘗試進行精確類型轉換失敗。
                    # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                    # LoadError：載入檔時發生錯誤。
                    # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                    # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                    # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                    # OverflowError：當操作結果太大時會發生這種情況。
                    # ParseError：解析給定運算式時出現問題。
                    # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                    # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                    # UndefRefError：未知引用。
                    # UndefVarError：對不存在的變數進行未知引用。
                    # InitError：調用模組的init方法時出現此錯誤。
                    # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                    # NullException：嘗試訪問Null值
                    # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                    # return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] change the permissions mode=0o777 fail."];
                end
            end

            # 拼接生成對應的用於傳入媒介文檔 monitor_file 和傳出媒介文檔 output_file 的兩個臨時暫存監聽媒介文檔名：temp_monitor_file 和 temp_output_file;
            # 同步移動文檔，將用於傳入數據的媒介文檔 monitor_file 從媒介文件夾 monitor_dir 移動到臨時暫存媒介文件夾 temp_cache_IO_data_dir;
            index_NUM = "_" * Base.string(input_file_NUM);  # 傳入數據的臨時暫存文檔 temp_monitor_file 的序號尾;
            # if length(input_queues_array) > 0

            #     if Core.isa(input_queues_array[length(input_queues_array)]["monitor_file"], Core.String) && input_queues_array[length(input_queues_array)]["monitor_file"] !== ""

            #         # ("/", "home", "myuser", "example.jl") === Base.Filesystem.splitpath("/home/myuser/example.jl")
            #         # "路徑" === Base.Filesystem.splitdir("路徑 + 文檔名 + 擴展名")[1]
            #         # "文檔名 + 擴展名" === Base.Filesystem.splitdir("路徑 + 文檔名 + 擴展名")[2]
            #         # "路徑" === Base.Filesystem.dirname("路徑 + 文檔名 + 擴展名")
            #         # "文檔名 + 擴展名" === Base.Filesystem.basename("路徑 + 文檔名 + 擴展名")
            #         # "文檔名" === Base.Filesystem.splitext("文檔名 + 擴展名")[1]
            #         # "擴展名" === Base.Filesystem.splitext("文檔名 + 擴展名")[2]
            #         # "/home/myuser/example.jl" === Base.Filesystem.joinpath("/home/myuser", "example.jl")
            #         # Base.Filesystem.abspath("/home/myuser/example.jl")
            #         # "/home/example.jl" === Base.Filesystem.normpath("/home/myuser/../example.jl")
            #         # ("a", "b") === Base.split("a_b", '_')
            #         # "a_b" === Base.string("a", "_", "b")

            #         # Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"])
            #         # Base.Filesystem.splitext(Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"]))[1]
            #         # Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"]))[1]);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(Core.String)型變量;
            #         if Base.occursin("_", Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"]))[1]))
            #             index_NUM = "_" * Base.string(Base.parse(Core.UInt64, Base.convert(Core.String, Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"]))[1]), '_')[length(Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"]))[1]), '_'))])) + Core.UInt64(1));
            #         end
            #     end
            # else
            #     index_NUM = "_1";
            # end

            temp_monitor_file_name = Base.string(Base.Filesystem.splitext(Base.Filesystem.basename(monitor_file))[1]) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(Base.Filesystem.basename(monitor_file))[2]);
            temp_monitor_file = Base.Filesystem.abspath(Base.Filesystem.normpath(Base.Filesystem.joinpath(temp_cache_IO_data_dir, temp_monitor_file_name)));  # 用於傳入數據的臨時暫存文檔 temp_monitor_file 路徑全名;
            # println(temp_monitor_file);

            temp_output_file_name = Base.string(Base.Filesystem.splitext(Base.Filesystem.basename(output_file))[1]) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(Base.Filesystem.basename(output_file))[2]);
            temp_output_file = Base.Filesystem.abspath(Base.Filesystem.normpath(Base.Filesystem.joinpath(temp_cache_IO_data_dir, temp_output_file_name)));  # 用於傳出數據的臨時暫存文檔 temp_output_file 路徑全名;
            # println(temp_output_file);

            # 解析臨時暫存媒介文檔名的尾綴序號;
            # Base.Filesystem.basename(temp_output_file)
            # Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]
            # Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(Core.String)型變量;
            # Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]), '_')[length(Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]), '_'))]
            # Base.Meta.parse(Core.UInt64, Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]), '_')[length(Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]), '_'))])

            # 判斷用於接收傳值的臨時媒介文檔是否有重名的;
            file_bool = (Base.Filesystem.ispath(temp_monitor_file) && Base.Filesystem.isfile(temp_monitor_file)) || (Base.Filesystem.ispath(temp_output_file) && Base.Filesystem.isfile(temp_output_file));  # 同步判斷，使用 Julia 原生模組 Base.Filesystem 的 Base.Filesystem.ispath() 方法判斷目錄或文檔是否存在以及使用 Base.Filesystem.isfile() 方法判斷是否為文檔;
            while file_bool

                # 遞增臨時文檔名尾綴序號;
                # println(temp_monitor_file);
                # # Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[2]
                # # Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[2])
                # # Base.Meta.parse(Core.UInt64, Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[2]))
                # global input_file_NUM = Base.Meta.parse(Core.UInt64, Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[2]));
                # global input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;
                input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;
                index_NUM = "_" * Base.string(input_file_NUM);  # 傳入數據的臨時暫存文檔 temp_monitor_file 的序號尾;
                # # Base.Filesystem.splitext(Base.Filesystem.basename(temp_monitor_file))[1]
                # # Base.Filesystem.splitext(temp_monitor_file)[1]
                # # Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[1]
                # # Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[1])

                # 修改更新暫存的用於臨時輸入傳值的文檔名;
                temp_monitor_file = Base.Filesystem.normpath(Base.string(Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[1])) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(temp_monitor_file)[2]));  # 用於傳入數據的臨時暫存文檔 temp_monitor_file 路徑全名;
                # println(Base.typeof(temp_monitor_file));
                # println(temp_monitor_file);

                # 修改更新暫存的用於臨時輸出傳值的文檔名;
                temp_output_file = Base.Filesystem.normpath(Base.string(Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[1])) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(temp_output_file)[2]));  # 用於傳出數據的臨時暫存文檔 temp_output_file 路徑全名;
                # println(Base.typeof(temp_output_file));
                # println(temp_output_file);

                file_bool = (Base.Filesystem.ispath(temp_monitor_file) && Base.Filesystem.isfile(temp_monitor_file)) || (Base.Filesystem.ispath(temp_output_file) && Base.Filesystem.isfile(temp_output_file));  # 同步判斷，使用 Julia 原生模組 Base.Filesystem 的 Base.Filesystem.ispath() 方法判斷目錄或文檔是否存在以及使用 Base.Filesystem.isfile() 方法判斷是否為文檔;
            end

            # # 判斷用於輸出傳值的臨時媒介文檔是否有重名的;
            # file_bool = (Base.Filesystem.ispath(temp_output_file) && Base.Filesystem.isfile(temp_output_file)) || (Base.Filesystem.ispath(temp_monitor_file) && Base.Filesystem.isfile(temp_monitor_file));  # 同步判斷，使用 Julia 原生模組 Base.Filesystem 的 Base.Filesystem.ispath() 方法判斷目錄或文檔是否存在以及使用 Base.Filesystem.isfile() 方法判斷是否為文檔;
            # while file_bool

            #     # 遞增臨時文檔名尾綴序號;
            #     # println(temp_output_file);
            #     # # Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[2]
            #     # # Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[2])
            #     # # Base.Meta.parse(Core.UInt64, Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[2]))
            #     # global input_file_NUM = Base.Meta.parse(Core.UInt64, Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[2]));
            #     # global input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;
            #     input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;
            #     index_NUM = "_" * Base.string(input_file_NUM);  # 傳出數據的臨時暫存文檔 temp_output_file 的序號尾;
            #     # # Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]
            #     # # Base.Filesystem.splitext(temp_output_file)[1]
            #     # # Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[1]
            #     # # Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[1])

            #     # 修改更新暫存的用於臨時輸出傳值的文檔名;
            #     temp_output_file = Base.Filesystem.normpath(Base.string(Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[1])) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(temp_output_file)[2]));  # 用於傳出數據的臨時暫存文檔 temp_output_file 路徑全名;
            #     # println(Base.typeof(temp_output_file));
            #     # println(temp_output_file);

            #     # 修改更新暫存的用於臨時輸入傳值的文檔名;
            #     temp_monitor_file = Base.Filesystem.normpath(Base.string(Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[1])) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(temp_monitor_file)[2]));  # 用於傳入數據的臨時暫存文檔 temp_monitor_file 路徑全名;
            #     # println(Base.typeof(temp_monitor_file));
            #     # println(temp_monitor_file);

            #     file_bool = (Base.Filesystem.ispath(temp_output_file) && Base.Filesystem.isfile(temp_output_file)) || (Base.Filesystem.ispath(temp_monitor_file) && Base.Filesystem.isfile(temp_monitor_file));  # 同步判斷，使用 Julia 原生模組 Base.Filesystem 的 Base.Filesystem.ispath() 方法判斷目錄或文檔是否存在以及使用 Base.Filesystem.isfile() 方法判斷是否為文檔;
            # end

            index_NUM = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            temp_monitor_file_name = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            temp_output_file_name = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            file_bool = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            # Base.GC.gc();  # 内存回收函數 gc();

            # 同步移動更名文檔，將用於傳入數據的媒介文檔 monitor_file 從媒介文件夾 monitor_dir 移動到臨時暫存媒介文件夾 temp_cache_IO_data_dir;
            try
                # Base.Filesystem.mv(src::AbstractString, dst::AbstractString; force::Bool=false)
                # Move the file, link, or directory from src to dst. force=true will first remove an existing dst. Return dst.
                Base.Filesystem.mv(monitor_file, temp_monitor_file; force=false);  # 將文檔、鏈接或目錄從 monitor_file 更名移動到 temp_monitor_file，如果參數 force=true 將首先刪除現有的 temp_monitor_file 文檔，函數返回值為 temp_monitor_file 字符串;
                # println("用於輸入傳值的媒介文檔: " * monitor_file * " 已經被移動更名爲: " * temp_monitor_file * " .");
            catch err
                println("用於輸入數據的媒介文檔: " * monitor_file * " 無法移動更名爲: " * temp_monitor_file * " .");
                println(err);
                # println(Base.typeof(err));
                return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] not move."];
            end

            Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

            # 判斷用於接收傳值的媒介文檔 monitor_file，是否已經從硬盤刪除，即判斷用於接收傳值的媒介文檔，是否已經從媒介目錄移動到暫存目錄，並已經更名為 <原名> + "_<序號>" + <原擴展名> 硬盤刪除;
            if Base.Filesystem.ispath(monitor_file) && Base.Filesystem.isfile(monitor_file)
                println("用於輸入數據的媒介文檔: " * monitor_file * " 無法移動更名爲: " * temp_monitor_file * " .");
                return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] not move."];
            end

            # 判斷新生成用於暫存的臨時接收傳值的媒介文檔 temp_monitor_file，是否已經創建成功，即判斷用於接收傳值的媒介文檔，是否已經從媒介目錄移動到���存目錄，並已經更名為 <原名> + "_<序號>" + <原擴展名> 硬盤刪除;
            if Base.Filesystem.ispath(temp_monitor_file) && Base.Filesystem.isfile(temp_monitor_file)

                # 檢查指定用於暫存的臨時接收傳值的媒介文檔的操作權限是否爲可讀并且可寫，如無可讀可寫權限，則對其修改權限;
                if Base.stat(temp_monitor_file).mode !== Core.UInt64(33206) && Base.stat(temp_monitor_file).mode !== Core.UInt64(33279)
                    # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(temp_monitor_file) 函數讀取文檔信息，使用 Base.stat(temp_monitor_file).mode 方法提取文檔權限碼;
                    println("用於暫存的臨時接收傳值的媒介文檔 [ " * temp_monitor_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                    try
                        # 使用 Base.Filesystem.chmod(temp_monitor_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
                        # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                        Base.Filesystem.chmod(temp_monitor_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                        println("文檔: " * temp_monitor_file * " 操作權限成功修改爲 mode=0o777 .");

                        # 八進制值    說明
                        # 0o400      所有者可讀
                        # 0o200      所有者可寫
                        # 0o100      所有者可執行或搜索
                        # 0o40       群組可讀
                        # 0o20       群組可寫
                        # 0o10       群組可執行或搜索
                        # 0o4        其他人可讀
                        # 0o2        其他人可寫
                        # 0o1        其他人可執行或搜索
                        # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                        # 數字	說明
                        # 7	可讀、可寫、可執行
                        # 6	可讀、可寫
                        # 5	可讀、可執行
                        # 4	唯讀
                        # 3	可寫、可執行
                        # 2	只寫
                        # 1	只可執行
                        # 0	沒有許可權
                        # 例如，八進制值 0o765 表示：
                        # 1) 、所有者可以讀取、寫入和執行該文檔；
                        # 2) 、群組可以讀和寫入該文檔；
                        # 3) 、其他人可以讀取和執行該文檔；
                        # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                        # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                    catch err
                        println("用於暫存的臨時接收傳值的媒介文檔: " * temp_monitor_file * " 無法修改操作權限爲 mode=0o777 .");
                        println(err);
                        # println(Base.typeof(err));
                        # return ["error", temp_monitor_file, "document [ temp_monitor_file = " * Base.string(temp_monitor_file) * " ] change the permissions mode=0o777 fail."];
                    end
                end

            else
                println("用於暫存的臨時接收傳值的媒介文檔: " * temp_monitor_file * " 無法創建.");
                return ["error", temp_monitor_file, "document [ temp_monitor_file = " * Base.string(temp_monitor_file) * " ] not create."];
            end

            # 追加推入等待讀取運算的傳入數據的隊列數組末尾;
            # input_queues_array = Core.Array{Base.Dict{Core.String, Core.Any}, 1}();  # 傳入數據等待運算的隊列數組;
            # 聲明一個字典，隊列中的一個元素數據;
            # Base.Dict{Core.String, Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}}()
            worker_Data = Base.Dict{Core.String, Core.Any}(
                # "read_file_do_Function" => read_file_do_Function,
                "monitor_file" => temp_monitor_file,  # monitor_file;
                "monitor_dir" => temp_cache_IO_data_dir,  # monitor_dir;
                # "do_Function" => do_Function,  # do_Function_obj["do_Function"];
                "output_dir" => temp_cache_IO_data_dir,  # output_dir;
                "output_file" => temp_output_file,  # output_file，output_queues_array;
                "to_executable" => to_executable,
                "to_script" => to_script
            );

            # global input_queues_array = Base.push!(input_queues_array, worker_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
            input_queues_array = Base.push!(input_queues_array, worker_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
            # println(input_queues_array);
            # println(length(input_queues_array));
            # result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = input_queues_array[1]["read_file_do_Function"](input_queues_array[1]["monitor_file"], input_queues_array[1]["monitor_dir"], input_queues_array[1]["do_Function"], input_queues_array[1]["output_dir"], input_queues_array[1]["output_file"], input_queues_array[1]["to_executable"], input_queues_array[1]["to_script"], time_sleep);

            worker_Data = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            # Base.GC.gc();  # 内存回收函數 gc();

            # return [monitor_file * " -> " * temp_monitor_file * " -> input_queues_array", input_queues_array, output_queues_array];
            return ["monitor_file -> temp_monitor_file -> input_queues_array[last]", input_queues_array, output_queues_array];
        else
            return ["The monitor_file path does not exist.", input_queues_array, output_queues_array];
        end
    end

    # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.Task}();
    # # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
    # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;

    # 創建通道(Channel);
    main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
    sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
    control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));  # 用於控制并發數目的通道，寫入一個元素相當於記錄一個啓動的子協程(task)，取出一個元素相當於一個子協程(task)執行完畢，如通道已經滿，則阻塞等待;
    # Base.put!(main_to_sub_channel, channel_message_Dict);  # 向通道(Channel)中寫入元素;
    # # Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
    # Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
    # Base.close(main_to_sub_channel);  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗;

    # isDoTasksOrThreads = "Tasks";  # "Multi-Threading";

    # 當選擇使用多協程（Task）并發運算時，在子協程（Task）中執行的函數;
    function funcTask(
        do_Function,
        read_file_do_Function,
        time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
        main_to_sub_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
        sub_to_main_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
        control_number_Queues_channel::Base.Channel{Core.UInt64}
    ) ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}

        # # print("當前協程 task: ", Base.current_task(), "\n");
        # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
        # print("當前綫程 thread 的 PID: ", Base.Threads.threadid(), "\n");
        # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
        # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
        # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
        # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
        # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
        # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
        # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
        # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
        # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
        # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
        # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
        # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
        # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

        worker_Data_Dict = Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
        # worker_Data_Dict = Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;

        if Base.isa(worker_Data_Dict, Base.Dict) && Base.haskey(worker_Data_Dict, "monitor_file") && worker_Data_Dict["monitor_file"] !== Core.nothing && Base.isa(worker_Data_Dict["monitor_file"], Core.String) && worker_Data_Dict["monitor_file"] !== "" && Base.haskey(worker_Data_Dict, "output_file") && worker_Data_Dict["output_file"] !== Core.nothing && Base.isa(worker_Data_Dict["output_file"], Core.String) && worker_Data_Dict["output_file"] !== ""

            # result = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();
            result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = read_file_do_Function(
                worker_Data_Dict["monitor_file"],
                worker_Data_Dict["monitor_dir"],
                do_Function,
                worker_Data_Dict["output_dir"],
                worker_Data_Dict["output_file"],
                worker_Data_Dict["to_executable"],
                worker_Data_Dict["to_script"],
                time_sleep
            );
            # result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = worker_Data_Dict["read_file_do_Function"](
            #     worker_Data_Dict["monitor_file"],
            #     worker_Data_Dict["monitor_dir"],
            #     worker_Data_Dict["do_Function"],
            #     worker_Data_Dict["output_dir"],
            #     worker_Data_Dict["output_file"],
            #     worker_Data_Dict["to_executable"],
            #     worker_Data_Dict["to_script"],
            #     time_sleep
            # );

            nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            # println(Base.string(nowTime));

            if Base.typeof(result) <: Core.Array && result[1] === "error"

                # println("return Error: ", result[3]);  # error;

                # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # println(Base.string(nowTime));
                # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # log_text = "error < " * Base.string(result[3]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(worker_Data_Dict["monitor_file"]) * " > < " * Base.string(worker_Data_Dict["output_file"]) * " >.";
                # print(log_text * "\n");
                # log_file = "";  # 日志文檔;
                # # 同步寫入用於記錄過程的日志文檔;
                # try
                #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                #     # # write(filename::AbstractString, x)
                #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                #     # println(numBytes);
                #     # println(Base.stat(log_file).size);
                #     # println(Base.stat(log_file).mtime);
                #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                #     # println(Base.stat(log_file).ctime);
                #     # # Base.displaysize([io::IO]) -> (lines, columns)
                #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                #     # # Base.countlines — Function
                #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                #     # println(Base.countlines(log_file, eol='\\n'));

                #     fWIO = Base.open(log_file, "a+");
                #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                #     # Keyword	Description				Default
                #     # read		open for reading		!write
                #     # write		open for writing		truncate | append
                #     # create	create if non-existent	!read & write | truncate | append
                #     # truncate	truncate to zero size	!read & write
                #     # append	seek to end				false

                #     # Mode	Description						Keywords
                #     # r		read							none
                #     # w		write, create, truncate			write = true
                #     # a		write, create, append			append = true
                #     # r+	read, write						read = true, write = true
                #     # w+	read, write, create, truncate	truncate = true, read = true
                #     # a+	read, write, create, append		append = true, read = true

                #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                #     if Base.iswritable(fWIO)
                #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                #         println(numBytes);
                #         println(Base.stat(log_file).size);
                #         println(Base.stat(log_file).mtime);
                #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                #         println(Base.stat(log_file).ctime);
                #         # Base.displaysize([io::IO]) -> (lines, columns)
                #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                #         # Base.countlines — Function
                #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                #         println(Base.countlines(log_file, eol='\\n'));
                #     end

                #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                #     # Base.ismarked(io);  # Return true if stream s is marked;
                #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                #     # Base.close(io);  # 關閉緩衝區;
                #     # println(a)
                #     # Base.redirect_stdout — Function
                #     # redirect_stdout([stream]) -> (rd, wr)
                #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                #     # If called with the optional stream argument, then returns stream itself.
                #     # Base.redirect_stdout — Method
                #     # redirect_stdout(f::Function, stream)
                #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                #     # Base.redirect_stderr — Function
                #     # redirect_stderr([stream]) -> (rd, wr)
                #     # Like redirect_stdout, but for stderr.
                #     # Base.redirect_stderr — Method
                #     # redirect_stderr(f::Function, stream)
                #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                #     # Base.redirect_stdin — Function
                #     # redirect_stdin([stream]) -> (rd, wr)
                #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                #     # Base.redirect_stdin — Method
                #     # redirect_stdin(f::Function, stream)
                #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                # catch err
                #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                #     println(err);
                #     # println(Base.typeof(err));

                #     # Julia提供了許多類型的錯誤：
                #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                #     # DivideError：這是數字除以0時的結果。
                #     # DomainError：有效域之外的參數。
                #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                #     # InexactError：嘗試進行精確類型轉換失敗。
                #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                #     # LoadError：載入檔時發生錯誤。
                #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                #     # OverflowError：當操作結果太大時會發生這種情況。
                #     # ParseError：解析給定運算式時出現問題。
                #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                #     # UndefRefError：未知引用。
                #     # UndefVarError：對不存在的變數進行未知引用。
                #     # InitError：調用模組的init方法時出現此錯誤。
                #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                #     # NullException：嘗試訪問Null值
                #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                # finally
                #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                #     if Base.eof(fWIO)
                #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                #     end
                # end

                result_Data_Dict = Base.Dict{Core.String, Core.Any}(
                    # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                    "monitor_file" => worker_Data_Dict["monitor_file"],  # temp_monitor_file，monitor_file;
                    "monitor_dir" => worker_Data_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir;
                    # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                    "output_dir" => worker_Data_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir;
                    "output_file" => worker_Data_Dict["output_file"],  # temp_output_file，output_file，output_queues_array;
                    "to_executable" => worker_Data_Dict["to_executable"],  # to_executable;
                    "to_script" => worker_Data_Dict["to_script"],  # to_script;
                    "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                    "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                    "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                    "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    "label" => "error",
                    "message" => "Function [ read_file_do_Function ] return error."
                );

                Base.put!(sub_to_main_channel, result_Data_Dict);  # 向通道(Channel)中寫入元素;
                num = Base.take!(control_number_Queues_channel);  # 取出用於控制并發數目的通道中的元素，使主進程中可以繼續創建子進程。使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;

                # result_Data_Dict = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                # Base.GC.gc();  # 内存回收函數 gc();

                return ["error", result[2], "Function [ read_file_do_Function ] return error."];
            end

            if Base.typeof(result) <: Core.Array && result[1] !== "error"
                # result[1] === "success"

                # 判斷用於輸出的臨時暫存媒介文檔是否創建成功，如果創建成功，則修改文檔權限;
                # result[2] === input_queues_array[1]["output_file"] === temp_output_file === output_queues_array[1]["output_file"];
                if Base.Filesystem.ispath(result[2]) && Base.Filesystem.isfile(result[2])
                    if Base.stat(result[2]).mode !== Core.UInt64(33206) && Base.stat(result[2]).mode !== Core.UInt64(33279)
                        # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(result[2]) 函數讀取文檔信息，使用 Base.stat(result[2]).mode 方法提取文檔權限碼;
                        # println("用於傳出數據的臨時暫存媒介文檔 [ " * result[2] * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                        try
                            # 使用 Base.Filesystem.chmod(result[2], mode=0o777; recursive=false) 函數修改文檔操作權限;
                            # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                            Base.Filesystem.chmod(result[2], mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                            # println("文檔: " * result[2] * " 操作權限成功修改爲 mode=0o777 .");

                            # 八進制值    說明
                            # 0o400      所有者可讀
                            # 0o200      所有者可寫
                            # 0o100      所有者可執行或搜索
                            # 0o40       群組可讀
                            # 0o20       群組可寫
                            # 0o10       群組可執行或搜索
                            # 0o4        其他人可讀
                            # 0o2        其他人可寫
                            # 0o1        其他人可執行或搜索
                            # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                            # 數字	說明
                            # 7	可讀、可寫、可執行
                            # 6	可讀、可寫
                            # 5	可讀、可執行
                            # 4	唯讀
                            # 3	可寫、可執行
                            # 2	只寫
                            # 1	只可執行
                            # 0	沒有許可權
                            # 例如，八進制值 0o765 表示：
                            # 1) 、所有者可以讀取、寫入和執行該文檔；
                            # 2) 、群組可以讀和寫入該文檔；
                            # 3) 、其他人可以讀取和執行該文檔；
                            # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                            # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                        catch err
                            # println("用於傳出數據的臨時暫存媒介文檔: " * result[2] * " 無法修改操作權限爲 mode=0o777 .");
                            # println(err);
                            # println(err.msg);
                            # println(Base.typeof(err));

                            result_Data_Dict = Base.Dict{Core.String, Core.Any}(
                                # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                                "monitor_file" => worker_Data_Dict["monitor_file"],  # temp_monitor_file，monitor_file;
                                "monitor_dir" => worker_Data_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir;
                                # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                                "output_dir" => worker_Data_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir;
                                "output_file" => worker_Data_Dict["output_file"],  # temp_output_file，output_file，output_queues_array;
                                "to_executable" => worker_Data_Dict["to_executable"],  # to_executable;
                                "to_script" => worker_Data_Dict["to_script"],  # to_script;
                                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                "threadID" => Base.string(Distributed.myid()),  # 子綫程（執行緒） ID;
                                "taskID" => Base.string(Distributed.myid()),  # 子協程（任務） ID;
                                "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                "label" => "error",
                                "message" => "document [ temp_output_file = " * Base.string(result[2]) * " ] change the permissions mode=0o777 fail."
                            );

                            Base.put!(sub_to_main_channel, result_Data_Dict);  # 向通道(Channel)中寫入元素;
                            num = Base.take!(control_number_Queues_channel);  # 取出用於控制并發數目的通道中的元素，使主進程中可以繼續創建子進程。使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;

                            # result_Data_Dict = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                            # Base.GC.gc();  # 内存回收函數 gc();

                            return ["error", result[2], "document [ temp_output_file = " * Base.string(result[2]) * " ] change the permissions mode=0o777 fail."];
                        end
                    end
                else
                    # println("用於傳出數據的臨時暫存媒介文檔: " * result[2] * " 無法被創建.");

                    result_Data_Dict = Base.Dict{Core.String, Core.Any}(
                        # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                        "monitor_file" => worker_Data_Dict["monitor_file"],  # temp_monitor_file，monitor_file;
                        "monitor_dir" => worker_Data_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir;
                        # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                        "output_dir" => worker_Data_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir;
                        "output_file" => worker_Data_Dict["output_file"],  # temp_output_file，output_file，output_queues_array;
                        "to_executable" => worker_Data_Dict["to_executable"],  # to_executable;
                        "to_script" => worker_Data_Dict["to_script"],  # to_script;
                        "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                        "threadID" => Base.string(Distributed.myid()),  # 子綫程（執行緒） ID;
                        "taskID" => Base.string(Distributed.myid()),  # 子協程（任務） ID;
                        "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        "label" => "error",
                        "message" => "document [ temp_output_file = " * Base.string(result[2]) * " ] not create."
                    );

                    Base.put!(sub_to_main_channel, result_Data_Dict);  # 向通道(Channel)中寫入元素;
                    num = Base.take!(control_number_Queues_channel);  # 取出用於控制并發數目的通道中的元素，使主進程中可以繼續創建子進程。使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;

                    # result_Data_Dict = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                    # Base.GC.gc();  # 内存回收函數 gc();

                    return ["error", result[2], "document [ temp_output_file = " * Base.string(result[2]) * " ] not create."];
                end

                result_Data_Dict = Base.Dict{Core.String, Core.Any}(
                    # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                    "monitor_file" => result[3],  # temp_monitor_file，monitor_file;
                    "monitor_dir" => worker_Data_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir;
                    # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                    "output_dir" => worker_Data_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir;
                    "output_file" => result[2],  # temp_output_file，output_file，output_queues_array;
                    "to_executable" => worker_Data_Dict["to_executable"],  # to_executable;
                    "to_script" => worker_Data_Dict["to_script"],  # to_script;
                    "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                    "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                    "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                    "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    "label" => "success",
                    "message" => Base.string(result[1])
                );

                Base.put!(sub_to_main_channel, result_Data_Dict);  # 向通道(Channel)中寫入元素;
                num = Base.take!(control_number_Queues_channel);  # 取出用於控制并發數目的通道中的元素，使主進程中可以繼續創建子進程。使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;

                # # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 是否仍然存在，如果仍存在，則將用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 同步從硬盤刪除;
                # # result[3] === input_queues_array[1]["monitor_file"] === temp_monitor_file === output_queues_array[1]["monitor_file"];
                # if Base.Filesystem.ispath(result[3]) && Base.Filesystem.isfile(result[3])
                #     # 讀取到輸入數據之後，同步刪除，用於接收傳值的媒介文檔;
                #     try
                #         # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                #         # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                #         Base.Filesystem.rm(result[3], force=true, recursive=false);  # 刪除給定路徑下的文檔、鏈接或空目錄，如果傳遞參數 force=true 時，則不存在的路徑不被視爲錯誤，如果傳遞參數 recursive=true 并且路徑是目錄時，則遞歸刪除所有内容;
                #         # Base.Filesystem.rm(path::AbstractString, force::Bool=false, recursive::Bool=false)
                #         # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                #         # println("媒介文檔: " * result[3] * " 已被刪除.");
                #     catch err
                #         println("用於傳入數據的臨時暫存媒介文檔: " * result[3] * " 無法刪除.");
                #         println(err);
                #         # println(err.msg);
                #         # println(Base.typeof(err));
                #         # return ["error", result[3], "document [ temp_monitor_file = " * Base.string(result[3]) * " ] not delete."];
                #     end

                #     # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                #     # # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 在已處理完數據後，是否已經從硬盤刪除;
                #     # if Base.Filesystem.ispath(result[3]) && Base.Filesystem.isfile(result[3])
                #     #     println("用於傳入數據的臨時暫存媒介文檔: " * result[3] * " 無法刪除.");
                #     #     # return ["error", result[3], "document [ temp_monitor_file = " * Base.string(result[3]) * " ] not delete."];
                #     # end
                # end

                # result_Data_Dict = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                # Base.GC.gc();  # 内存回收函數 gc();

                # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # println(Base.string(nowTime));
                # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(result[3]) * " ] -> [ " * Base.string(result[2]) * " ].";
                # print(log_text * "\n");
                # log_file = "";  # 日志文檔;
                # # 同步寫入用於記錄過程的日志文檔;
                # try
                #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                #     # # write(filename::AbstractString, x)
                #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                #     # println(numBytes);
                #     # println(Base.stat(log_file).size);
                #     # println(Base.stat(log_file).mtime);
                #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                #     # println(Base.stat(log_file).ctime);
                #     # # Base.displaysize([io::IO]) -> (lines, columns)
                #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                #     # # Base.countlines — Function
                #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                #     # println(Base.countlines(log_file, eol='\\n'));

                #     fWIO = Base.open(log_file, "a+");
                #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                #     # Keyword	Description				Default
                #     # read		open for reading		!write
                #     # write		open for writing		truncate | append
                #     # create	create if non-existent	!read & write | truncate | append
                #     # truncate	truncate to zero size	!read & write
                #     # append	seek to end				false

                #     # Mode	Description						Keywords
                #     # r		read							none
                #     # w		write, create, truncate			write = true
                #     # a		write, create, append			append = true
                #     # r+	read, write						read = true, write = true
                #     # w+	read, write, create, truncate	truncate = true, read = true
                #     # a+	read, write, create, append		append = true, read = true

                #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                #     if Base.iswritable(fWIO)
                #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                #         println(numBytes);
                #         println(Base.stat(log_file).size);
                #         println(Base.stat(log_file).mtime);
                #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                #         println(Base.stat(log_file).ctime);
                #         # Base.displaysize([io::IO]) -> (lines, columns)
                #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                #         # Base.countlines — Function
                #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                #         println(Base.countlines(log_file, eol='\\n'));
                #     end

                #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                #     # Base.ismarked(io);  # Return true if stream s is marked;
                #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                #     # Base.close(io);  # 關閉緩衝區;
                #     # println(a)
                #     # Base.redirect_stdout — Function
                #     # redirect_stdout([stream]) -> (rd, wr)
                #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                #     # If called with the optional stream argument, then returns stream itself.
                #     # Base.redirect_stdout — Method
                #     # redirect_stdout(f::Function, stream)
                #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                #     # Base.redirect_stderr — Function
                #     # redirect_stderr([stream]) -> (rd, wr)
                #     # Like redirect_stdout, but for stderr.
                #     # Base.redirect_stderr — Method
                #     # redirect_stderr(f::Function, stream)
                #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                #     # Base.redirect_stdin — Function
                #     # redirect_stdin([stream]) -> (rd, wr)
                #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                #     # Base.redirect_stdin — Method
                #     # redirect_stdin(f::Function, stream)
                #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                # catch err
                #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                #     println(err);
                #     # println(err.msg);
                #     # println(Base.typeof(err));
                #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                # finally
                #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                #     if Base.eof(fWIO)
                #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                #     end
                # end

                # return ["success", result[1], result[2], result[3]];
                return [result[1], result[2], result[3]];
            end
            # global input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
            # input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
        else
            return ["error", "main_to_sub_channel", "Base.typeof(Base.take!(main_to_sub_channel)) !== Base.Dict, not recognition."];
        end
    end

    # 創建一個自定義的函數，當計時器輪詢時調用，用以監聽傳入數據等待處理的任務隊列，當傳入數據等待處理的任務隊列長度大於 1 時，采用先進先出的原則，處理隊列中的任務排隊，並相應清除已經被處理過的任務元素;
    function func_Monitor_input_queues(
        # monitor_file::Core.String,
        # monitor_dir::Core.String,
        do_Function,
        # output_dir::Core.String,
        # output_file::Core.String,
        # to_executable::Core.String,
        # to_script::Core.String,
        # temp_cache_IO_data_dir::Core.String,
        number_Worker_threads::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
        time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
        read_file_do_Function,
        isDoTasksOrThreads::Core.String,
        funcTask,
        main_to_sub_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
        sub_to_main_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
        control_number_Queues_channel::Base.Channel{Core.UInt64},
        input_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1},
        output_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1},
        worker_queues_Dict::Base.Dict{Core.String, Core.Any},
        total_worker_called_number::Base.Dict{Core.String, Core.UInt64}
    ) ::Core.Array{Core.Any, 1}

        # # print("當前協程 task: ", Base.current_task(), "\n");
        # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
        # print("當前綫程 thread 的 TID: ", Base.Threads.threadid(), "\n");
        # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
        # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
        # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
        # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
        # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
        # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
        # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
        # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
        # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
        # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
        # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
        # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
        # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

        output_queues_array = Base.deepcopy(output_queues);
        input_queues_array = Base.deepcopy(input_queues);

        # 監聽待處理任務隊列數組 input_queues_array 和 空閑子綫程隊列 worker_free，當有待處理任務等待時，且有空閑子進程時，將待任務隊列中排在前面的第一個待處理任務，推入一個空閑子進程;
        if Base.typeof(input_queues_array) <: Core.Array && Base.length(input_queues_array) > 0

            # 無并發，就在當前主進程（Master）中，處理輸入任務隊列;
            if Core.Int8(number_Worker_threads) <= Core.Int8(0)

                if Base.isa(input_queues_array[1], Base.Dict) && Base.haskey(input_queues_array[1], "monitor_file") && input_queues_array[1]["monitor_file"] !== Core.nothing && Base.isa(input_queues_array[1]["monitor_file"], Core.String) && input_queues_array[1]["monitor_file"] !== "" && Base.haskey(input_queues_array[1], "output_file") && input_queues_array[1]["output_file"] !== Core.nothing && Base.isa(input_queues_array[1]["output_file"], Core.String) && input_queues_array[1]["output_file"] !== ""

                    # 記錄每個綫程纍加的被調用運算的總次數;
                    # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                    if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid()))
                        # global total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid())]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                        total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid())]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                    else
                        # global total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                        total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                    end
                    # if Base.haskey(total_worker_called_number, Base.string(Base.objectid(Base.current_task())))
                    #     # global total_worker_called_number[Base.string(Base.objectid(Base.current_task()))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(Base.current_task()))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                    #     total_worker_called_number[Base.string(Base.objectid(Base.current_task()))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(Base.current_task()))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                    # else
                    #     # global total_worker_called_number[Base.string(Base.objectid(Base.current_task()))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                    #     total_worker_called_number[Base.string(Base.objectid(Base.current_task()))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                    # end

                    # result = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();
                    result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = read_file_do_Function(
                        input_queues_array[1]["monitor_file"],
                        input_queues_array[1]["monitor_dir"],
                        do_Function,
                        input_queues_array[1]["output_dir"],
                        input_queues_array[1]["output_file"],
                        input_queues_array[1]["to_executable"],
                        input_queues_array[1]["to_script"],
                        time_sleep
                    );
                    # result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = input_queues_array[1]["read_file_do_Function"](
                    #     input_queues_array[1]["monitor_file"],
                    #     input_queues_array[1]["monitor_dir"],
                    #     input_queues_array[1]["do_Function"],
                    #     input_queues_array[1]["output_dir"],
                    #     input_queues_array[1]["output_file"],
                    #     input_queues_array[1]["to_executable"],
                    #     input_queues_array[1]["to_script"],
                    #     time_sleep
                    # );

                    nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));

                    if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"

                        println("return Error: ", result[3]);  # error;

                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        # println(Base.string(nowTime));
                        # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模���;
                        # log_text = "error < " * Base.string(result[3]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(input_queues_array[1]["monitor_file"]) * " > < " * Base.string(input_queues_array[1]["output_file"]) * " >.";
                        # print(log_text * "\n");
                        # log_file = "";  # 日志文檔;
                        # # 同步寫入用於記錄過程的日志文檔;
                        # try
                        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                        #     # # write(filename::AbstractString, x)
                        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                        #     # println(numBytes);
                        #     # println(Base.stat(log_file).size);
                        #     # println(Base.stat(log_file).mtime);
                        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        #     # println(Base.stat(log_file).ctime);
                        #     # # Base.displaysize([io::IO]) -> (lines, columns)
                        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                        #     # # Base.countlines — Function
                        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                        #     # println(Base.countlines(log_file, eol='\\n'));

                        #     fWIO = Base.open(log_file, "a+");
                        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                        #     # Keyword	Description				Default
                        #     # read		open for reading		!write
                        #     # write		open for writing		truncate | append
                        #     # create	create if non-existent	!read & write | truncate | append
                        #     # truncate	truncate to zero size	!read & write
                        #     # append	seek to end				false

                        #     # Mode	Description						Keywords
                        #     # r		read							none
                        #     # w		write, create, truncate			write = true
                        #     # a		write, create, append			append = true
                        #     # r+	read, write						read = true, write = true
                        #     # w+	read, write, create, truncate	truncate = true, read = true
                        #     # a+	read, write, create, append		append = true, read = true

                        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                        #     if Base.iswritable(fWIO)
                        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                        #         println(numBytes);
                        #         println(Base.stat(log_file).size);
                        #         println(Base.stat(log_file).mtime);
                        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        #         println(Base.stat(log_file).ctime);
                        #         # Base.displaysize([io::IO]) -> (lines, columns)
                        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                        #         # Base.countlines — Function
                        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                        #         println(Base.countlines(log_file, eol='\\n'));
                        #     end

                        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                        #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                        #     # Base.ismarked(io);  # Return true if stream s is marked;
                        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                        #     # Base.close(io);  # 關閉緩衝區;
                        #     # println(a)
                        #     # Base.redirect_stdout — Function
                        #     # redirect_stdout([stream]) -> (rd, wr)
                        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                        #     # If called with the optional stream argument, then returns stream itself.
                        #     # Base.redirect_stdout — Method
                        #     # redirect_stdout(f::Function, stream)
                        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                        #     # Base.redirect_stderr — Function
                        #     # redirect_stderr([stream]) -> (rd, wr)
                        #     # Like redirect_stdout, but for stderr.
                        #     # Base.redirect_stderr — Method
                        #     # redirect_stderr(f::Function, stream)
                        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                        #     # Base.redirect_stdin — Function
                        #     # redirect_stdin([stream]) -> (rd, wr)
                        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                        #     # Base.redirect_stdin — Method
                        #     # redirect_stdin(f::Function, stream)
                        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                        # catch err
                        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                        #     println(err);
                        #     # println(Base.typeof(err));

                        #     # Julia提供了許多類型的錯誤：
                        #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                        #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                        #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                        #     # DivideError：這是數字除以0時的結果。
                        #     # DomainError：有效域之外的參數。
                        #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                        #     # InexactError：嘗試進行精確類型轉換失敗。
                        #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                        #     # LoadError：載入檔時發生錯誤。
                        #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                        #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                        #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                        #     # OverflowError：當操作結果太大時會發生這種情況。
                        #     # ParseError：解析給定運算式時出現問題。
                        #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                        #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                        #     # UndefRefError：未知引用。
                        #     # UndefVarError：對不存在的變數進行未知引用。
                        #     # InitError：調用模組的init方法時出現此錯誤。
                        #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                        #     # NullException：嘗試訪問Null值
                        #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                        # finally
                        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                        #     if Base.eof(fWIO)
                        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                        #     end
                        # end
                    end

                    if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                        # result[1] === "success"

                        # 判斷用於輸出的臨時暫存媒介文檔是否創建成功，如果創建成功，則修改文檔權限;
                        # result[2] === input_queues_array[1]["output_file"] === temp_output_file === output_queues_array[1]["output_file"];
                        if Base.Filesystem.ispath(result[2]) && Base.Filesystem.isfile(result[2])
                            if Base.stat(result[2]).mode !== Core.UInt64(33206) && Base.stat(result[2]).mode !== Core.UInt64(33279)
                                # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(result[2]) 函數讀取文檔信息，使用 Base.stat(result[2]).mode 方法提取文檔權限碼;
                                # println("用於傳出數據的臨時暫存媒介文檔 [ " * result[2] * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                try
                                    # 使用 Base.Filesystem.chmod(result[2], mode=0o777; recursive=false) 函數修改文檔操作權限;
                                    # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                    Base.Filesystem.chmod(result[2], mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                    # println("文檔: " * result[2] * " 操作權限成功修改爲 mode=0o777 .");

                                    # 八進制值    說明
                                    # 0o400      所有者可讀
                                    # 0o200      所有者可寫
                                    # 0o100      所有者可執行或搜索
                                    # 0o40       群組可讀
                                    # 0o20       群組可寫
                                    # 0o10       群組可執行或搜索
                                    # 0o4        其他人可讀
                                    # 0o2        其他人可寫
                                    # 0o1        其他人可執行或搜索
                                    # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                    # 數字	說明
                                    # 7	可讀、可寫、可執行
                                    # 6	可讀、可寫
                                    # 5	可讀、可執行
                                    # 4	唯讀
                                    # 3	可寫、可執行
                                    # 2	只寫
                                    # 1	只可執行
                                    # 0	沒有許可權
                                    # 例如，八進制值 0o765 表示：
                                    # 1) 、所有者可以讀取、寫入和執行該文檔；
                                    # 2) 、群組可以讀和寫入該文檔；
                                    # 3) 、其他人可以讀取和執行該文檔；
                                    # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                    # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                catch err
                                    println("用於傳出數據的臨時暫存媒介文檔: " * result[2] * " 無法修改操作權限爲 mode=0o777 .");
                                    println(err);
                                    # println(Base.typeof(err));
                                    # return ["error", result[2], "document [ temp_output_file = " * Base.string(result[2]) * " ] change the permissions mode=0o777 fail."];
                                end
                            end
                        else
                            println("用於傳出數據的臨時暫存媒介文檔: " * result[2] * " 無法被創建.");
                            # return ["error", result[2], "document [ temp_output_file = " * Base.string(result[2]) * " ] not create."];
                        end

                        result_Data = Base.Dict{Core.String, Core.Any}(
                            # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                            "monitor_file" => result[3],  # temp_monitor_file，monitor_file;
                            "monitor_dir" => input_queues_array[1]["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir;
                            # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                            "output_dir" => input_queues_array[1]["output_dir"],  # temp_cache_IO_data_dir，output_dir;
                            "output_file" => result[2],  # temp_output_file，output_file，output_queues_array;
                            "to_executable" => input_queues_array[1]["to_executable"],  # to_executable;
                            "to_script" => input_queues_array[1]["to_script"],  # to_script;
                            "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                            "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                            "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                            "time" => Base.string(nowTime)  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        );

                        # global output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        # println(output_queues_array);
                        # println(length(output_queues_array));

                        # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 是否仍然存在，如果仍存在，則將用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 同步從硬盤刪除;
                        # result[3] === input_queues_array[1]["monitor_file"] === temp_monitor_file === output_queues_array[1]["monitor_file"];
                        if Base.Filesystem.ispath(result[3]) && Base.Filesystem.isfile(result[3])
                            # 讀取到輸入數據之後，同步刪除，用於接收傳值的媒介文檔;
                            try
                                # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                                # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                Base.Filesystem.rm(result[3], force=true, recursive=false);  # 刪除給定路徑下的文檔、鏈接或空目錄，如果傳遞參數 force=true 時，則不存在的路徑不被視爲錯誤，如果傳遞參數 recursive=true 并且路徑是目錄時，則遞歸刪除所有内容;
                                # Base.Filesystem.rm(path::AbstractString, force::Bool=false, recursive::Bool=false)
                                # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                # println("媒介文檔: " * result[3] * " 已被刪除.");
                            catch err
                                println("用於傳入數據的臨時暫存媒介文檔: " * result[3] * " 無法刪除.");
                                println(err);
                                # println(Base.typeof(err));
                                # return ["error", result[3], "document [ temp_monitor_file = " * Base.string(result[3]) * " ] not delete."];
                            end

                            # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                            # # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 在已處理完數據後，是否已經從硬盤刪除;
                            # if Base.Filesystem.ispath(result[3]) && Base.Filesystem.isfile(result[3])
                            #     println("用於傳入數據的臨時暫存媒介文檔: " * result[3] * " 無法刪除.");
                            #     # return ["error", result[3], "document [ temp_monitor_file = " * Base.string(result[3]) * " ] not delete."];
                            # end
                        end

                        result_Data = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                        # Base.GC.gc();  # 内存回收函數 gc();

                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        # println(Base.string(nowTime));
                        # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                        log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(result[3]) * " ] -> [ " * Base.string(result[2]) * " ].";
                        # print(log_text * "\n");
                        # log_file = "";  # 日志文檔;
                        # # 同步寫入用於記錄過程的日志文檔;
                        # try
                        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                        #     # # write(filename::AbstractString, x)
                        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                        #     # println(numBytes);
                        #     # println(Base.stat(log_file).size);
                        #     # println(Base.stat(log_file).mtime);
                        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        #     # println(Base.stat(log_file).ctime);
                        #     # # Base.displaysize([io::IO]) -> (lines, columns)
                        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                        #     # # Base.countlines — Function
                        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                        #     # println(Base.countlines(log_file, eol='\\n'));

                        #     fWIO = Base.open(log_file, "a+");
                        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                        #     # Keyword	Description				Default
                        #     # read		open for reading		!write
                        #     # write		open for writing		truncate | append
                        #     # create	create if non-existent	!read & write | truncate | append
                        #     # truncate	truncate to zero size	!read & write
                        #     # append	seek to end				false

                        #     # Mode	Description						Keywords
                        #     # r		read							none
                        #     # w		write, create, truncate			write = true
                        #     # a		write, create, append			append = true
                        #     # r+	read, write						read = true, write = true
                        #     # w+	read, write, create, truncate	truncate = true, read = true
                        #     # a+	read, write, create, append		append = true, read = true

                        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                        #     if Base.iswritable(fWIO)
                        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                        #         println(numBytes);
                        #         println(Base.stat(log_file).size);
                        #         println(Base.stat(log_file).mtime);
                        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        #         println(Base.stat(log_file).ctime);
                        #         # Base.displaysize([io::IO]) -> (lines, columns)
                        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                        #         # Base.countlines — Function
                        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                        #         println(Base.countlines(log_file, eol='\\n'));
                        #     end

                        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                        #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                        #     # Base.ismarked(io);  # Return true if stream s is marked;
                        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                        #     # Base.close(io);  # 關閉緩衝區;
                        #     # println(a)
                        #     # Base.redirect_stdout — Function
                        #     # redirect_stdout([stream]) -> (rd, wr)
                        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                        #     # If called with the optional stream argument, then returns stream itself.
                        #     # Base.redirect_stdout — Method
                        #     # redirect_stdout(f::Function, stream)
                        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                        #     # Base.redirect_stderr — Function
                        #     # redirect_stderr([stream]) -> (rd, wr)
                        #     # Like redirect_stdout, but for stderr.
                        #     # Base.redirect_stderr — Method
                        #     # redirect_stderr(f::Function, stream)
                        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                        #     # Base.redirect_stdin — Function
                        #     # redirect_stdin([stream]) -> (rd, wr)
                        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                        #     # Base.redirect_stdin — Method
                        #     # redirect_stdin(f::Function, stream)
                        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                        # catch err
                        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                        #     println(err);
                        #     # println(Base.typeof(err));
                        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                        # finally
                        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                        #     if Base.eof(fWIO)
                        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                        #     end
                        # end
                    end

                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(result[3]) * " ] -> [ " * Base.string(result[2]) * " ].";
                    # print(log_text * "\n");
                    # log_file = "";  # 日志文檔;
                    # # 同步寫入用於記錄過程的日志文檔;
                    # try
                    #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                    #     # # write(filename::AbstractString, x)
                    #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                    #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                    #     # println(numBytes);
                    #     # println(Base.stat(log_file).size);
                    #     # println(Base.stat(log_file).mtime);
                    #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    #     # println(Base.stat(log_file).ctime);
                    #     # # Base.displaysize([io::IO]) -> (lines, columns)
                    #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                    #     # # Base.countlines — Function
                    #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                    #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                    #     # println(Base.countlines(log_file, eol='\\n'));

                    #     fWIO = Base.open(log_file, "a+");
                    #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                    #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                    #     # Keyword	Description				Default
                    #     # read		open for reading		!write
                    #     # write		open for writing		truncate | append
                    #     # create	create if non-existent	!read & write | truncate | append
                    #     # truncate	truncate to zero size	!read & write
                    #     # append	seek to end				false

                    #     # Mode	Description						Keywords
                    #     # r		read							none
                    #     # w		write, create, truncate			write = true
                    #     # a		write, create, append			append = true
                    #     # r+	read, write						read = true, write = true
                    #     # w+	read, write, create, truncate	truncate = true, read = true
                    #     # a+	read, write, create, append		append = true, read = true

                    #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                    #     if Base.iswritable(fWIO)
                    #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                    #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                    #         println(numBytes);
                    #         println(Base.stat(log_file).size);
                    #         println(Base.stat(log_file).mtime);
                    #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    #         println(Base.stat(log_file).ctime);
                    #         # Base.displaysize([io::IO]) -> (lines, columns)
                    #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                    #         # Base.countlines — Function
                    #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                    #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                    #         println(Base.countlines(log_file, eol='\\n'));
                    #     end

                    #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                    #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                    #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                    #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                    #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                    #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                    #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                    #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                    #     # Base.ismarked(io);  # Return true if stream s is marked;
                    #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                    #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                    #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                    #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                    #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                    #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                    #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                    #     # Base.close(io);  # 關閉緩衝區;
                    #     # println(a)
                    #     # Base.redirect_stdout — Function
                    #     # redirect_stdout([stream]) -> (rd, wr)
                    #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                    #     # If called with the optional stream argument, then returns stream itself.
                    #     # Base.redirect_stdout — Method
                    #     # redirect_stdout(f::Function, stream)
                    #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                    #     # Base.redirect_stderr — Function
                    #     # redirect_stderr([stream]) -> (rd, wr)
                    #     # Like redirect_stdout, but for stderr.
                    #     # Base.redirect_stderr — Method
                    #     # redirect_stderr(f::Function, stream)
                    #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                    #     # Base.redirect_stdin — Function
                    #     # redirect_stdin([stream]) -> (rd, wr)
                    #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                    #     # Base.redirect_stdin — Method
                    #     # redirect_stdin(f::Function, stream)
                    #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                    # catch err
                    #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                    #     println(err);
                    #     # println(Base.typeof(err));
                    #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                    # finally
                    #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                    #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                    #     if Base.eof(fWIO)
                    #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                    #     end
                    # end

                    # global input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                    input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                end
            end

            # 開啓并發，在子進程（Worker）中，處理輸入任務隊列;
            if Core.Int8(number_Worker_threads) > Core.Int8(0)

                if isDoTasksOrThreads === "Tasks"

                    # 在 Julia 中，稱協程（Coroutine）為任務（Task）。創建任務（Task）的方式有兩種，
                    # 用構造方法：
                    # taskname = Task(f)
                    # 用構造方法 Task(f) 將一個函數對象 f 封裝成名為 taskname 的任務（Task）。此時要求函數對象 f 必須是無參數的，即沒有參數或所有參數都有預設值。假如函數對象 f 有參數，那麼 f 就變成了運算式，在傳入 Task() 前會被執行，於是傳入 Task() 的不再是函數對象而是執行結果。為解決此問題，可以定義一個 f1()=f(參數)，然後 taskname = Task(f1)。
                    # 巨集（宏）命令 @task 將一個運算式封裝成任務（Task）
                    # taskname = @task 運算式
                    # 用巨集（宏）命令 @task 將一個運算式封裝成名為 taskname 的任務（Task）。注意大小寫。
                    # 創建後，可用 istaskstarted(taskname) 函數和 istaskdone(taskname) 函數查看創建的任務（Task）是否啟動和結束。Task 有五個狀態：runnable（可被啟動）, waiting（阻塞等待中）, queued（正被調度中）, done（執行結束）, failed（執行異常結束）。在 Julia 內部有一個調度器，負責維護 task 運行佇列。用 schedule(taskname) 函數可以把 Task 加入佇列並啟動，隨後會自動返回 done 狀態，表示已完成。
                    # 對於運算式，有個「合二為一」的巨集命令：@async 運算式。它會創建 Task 並直接啟動。例如：
                    # using Distributed
                    # a=zeros(1,5)
                    # 1×5 Array{Float64,2}:
                    # 0.0  0.0  0.0  0.0  0.0
                    # @async fill!(a, 4)
                    # Task (done) @0x00000000063059f0
                    # println(a)
                    # 1×5 Array{Float64,2}:
                    # 4.0  4.0  4.0  4.0  4.0
                    # 1
                    # 2
                    # 3
                    # 4
                    # 5
                    # 6
                    # 7
                    # 8
                    # 9
                    # 10
                    # 11
                    # 12
                    # 可以在被傳給 Task() 的函數對象 f 內部使用某些命令強迫這一 Task 改變狀態，包括：
                    # Base.sleep(N)  睡眠N秒
                    # yield()  請求切換為其他 task
                    # yieldto(taskname)  請求切換為指定的task，一般不建議使用

                    # 通道、管道(Channel);
                    # Base.Channel{T=Any}(size::Int=0);
                    # 如果一個 Channel 是空的，讀取的 task（即執行 v = Base.take!(c::Channel) 的 task）會被阻塞直到有新的資料準備好了。
                    # 如果一個 Channel 是滿的，那麼寫入的 task（即執行 Base.put!(c::Channel, v) 的 task）則會被阻塞，直到 Channel 有空餘。
                    # Base.isready(c::Channel) 可以用來檢查一個 channel 中是否有已經準備好的元素，而等待一個元素準備好 則用 Base.wait(r::Future) 函數。
                    # 一個 Channel 一開始處於開啟狀態，也就是說可以被 take! 讀取和 put! 寫入。Base.close(c::Channel[, excp::Exception]) 會關閉一個 Channel，對於一個已經關閉的 Channel，put! 會失敗。
                    # Channel 可以在 for 迴圈中遍歷，此時，迴圈會一直運行直到 Channel 中有資料，遍歷過程中會取遍加入到 Channel 中的所有值。一旦 Channel關閉或者取空了，for 迴圈就會終止。
                    # c = Channel{Int}(10)
                    # foreach(i->put!(c, i), 1:3)
                    # 此時，如果直接用 for 去遍歷通道 c 中的內容，則在讀取完後會一直等待通道(Channel)中有新的資料進來，如果在控制臺REPL上運行，則會停在那裡。
                    # data = [i for i in c]
                    # 如果先把Channel關閉，再用for去遍歷，則會讀出Channel中的內容，因此此時c已經關閉，for不會再等待寫入了。
                    # close(c);
                    # data = [i for i in c]

                    # 使用 Base.bind(chnl::Channel, task::Task) 方法，將通道(Channel)的生存期與任務或叫協程(task)相關聯。當協程(task)終止時，通道(Channel)自動關閉。任務中任何未捕獲的異常都會傳播到通道(Channel)上的所有等待者。
                    # 通道(Channel)對象可以獨立於協程(task)終止顯式關閉。終止協程(task)對已關閉的通道(Channel)對象沒有影響。
                    # 當通道(Channel)綁定到多個協程(task)時，第一個終止的協程(task)將關閉通道(Channel)。當多個通道(Channel)綁定到同一個協程(task)時，協程(task)的終止將關閉所有綁定的通道(Channel)。
                    # task = Base.@async foreach(i->put!(c, i), 1:4);
                    # Base.bind(c,task);
                    # for i in c
                    #     Base.@show i
                    #     println(Base.current_task())
                    # end;
                    # i = 1
                    # i = 2
                    # i = 3
                    # i = 4
                    # Base.isopen(c)
                    # false
                    # c2 = Base.Channel{Core.Float64}(32)  # 創建一個長度爲 32，元素(item)類型爲 Float64 的通道(Channel);
                    # Base.put!(c2, 2)  # 向通道(Channel)中寫入元素;
                    # itme1 = Base.fetch(c2)  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
                    # itme1 = Base.take!(c2)  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                    # Base.close(c2)  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗，take!() 和 fetch() 爲空時，將會關閉這個通道;
                    # Base.isready(c2)

                    # # 用Channel完成多工（多任務 task）之間的資料交互
                    # # 新建兩個Channel，一個是Int型，一個是Tuple型，對於每個任務，延時一段時間後，開始執行該任務的內容，並將結果放入到results中。
                    # const jobs = Channel{Int}(32)
                    # const results = Channel{Tuple}(32)
                    # function do_work()
                    #     for job_id in jobs
                    #         exec_time = rand()
                    #         Base.sleep(exec_time)  # simulates elapsed time doing actual work typically performed externally.
                    #         put!(results, (job_id, exec_time))
                    #     end
                    # end
                    # # 向jobs中放入數據
                    # function make_jobs(n)
                    #     for i in 1:n
                    #         put!(jobs, i)
                    #     end
                    # end
                    # # 寫入12個資料
                    # n = 12
                    # @async make_jobs(n)
                    # # @async表示把後面的運算式放到Task裡，並加入到程式的執行清單中
                    # # 開四個任務來處理
                    # for i in 1:4
                    #     # start 4 tasks to process requests in parallel
                    #     @async do_work()
                    # end
                    # # 取出4個任務的執行結果
                    # @elapsed while n > 0
                    #     # print out results
                    #     job_id, exec_time = take!(results)
                    #     println("$job_id finished in $(round(exec_time; digits=2)) seconds")
                    #     global n = n - 1
                    # end
                    # # >>1 finished in 0.51 seconds
                    # # 4 finished in 0.62 seconds
                    # # 3 finished in 0.75 seconds
                    # # 2 finished in 0.81 seconds
                    # # 5 finished in 0.55 seconds
                    # # 8 finished in 0.35 seconds
                    # # 6 finished in 0.77 seconds
                    # # 9 finished in 0.38 seconds
                    # # 12 finished in 0.11 seconds
                    # # 7 finished in 0.88 seconds
                    # # 11 finished in 0.25 seconds
                    # # 10 finished in 0.75 seconds

                    input_queues_length = Base.length(input_queues_array);

                    # 使用協程(task)創建子協程執行具體動作;
                    for i in 1:input_queues_length

                        if Base.isa(input_queues_array[i], Base.Dict)

                            # 控制並發數;
                            # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                            Base.put!(control_number_Queues_channel, Core.UInt64(i));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                            worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[i]["read_file_do_Function"];
                                "monitor_file" => input_queues_array[i]["monitor_file"],  # monitor_file;
                                "monitor_dir" => input_queues_array[i]["monitor_dir"],  # monitor_dir;
                                # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                "output_dir" => input_queues_array[i]["output_dir"],  # output_dir;
                                "output_file" => input_queues_array[i]["output_file"],  # output_file，output_queues_array;
                                "to_executable" => input_queues_array[i]["to_executable"],
                                "to_script" => input_queues_array[i]["to_script"]
                            );

                            # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                            # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                            Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                            # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                            #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                            # end

                            f() = funcTask(do_Function, read_file_do_Function, time_sleep, main_to_sub_channel, sub_to_main_channel, control_number_Queues_channel);
                            workerTask = Core.Task(f);  # 創建一個協程（任務）task;
                            workerTask.sticky = false;

                            # # 保存每個被創建的協程(task)在一個字典中;
                            # # 使用 Base.objectid(Base.current_task()) 方法返回當前協程（task） ID 號;
                            # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                            # if Base.haskey(worker_queues_Dict, Base.string(Base.objectid(workerTask)))
                            #     # global worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                            #     worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                            # else
                            #     # global worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                            #     worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                            # end
                            # # 記錄每個綫程纍加的被調用運算的總次數;
                            # # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                            # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                            # if Base.haskey(total_worker_called_number, Base.string(Base.objectid(workerTask)))
                            #     # global total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(workerTask))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                            #     total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(workerTask))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                            # else
                            #     # global total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            #     total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            # end

                            Base.schedule(workerTask);  # 用 Base.schedule(t::Task, [val]; error=false) 函數把未啓動的協程(Task)加入等待執行的隊列並啓動，隨後會自動返回 done 狀態，表示已經執行完畢;
                            # Base.wait(workerTask);  # 阻塞主進程後面的代碼執行，直到該子協程 workerTask 運行完畢;
                            # 用 istaskstarted(taskname) 和 istaskdone(taskname) 查看 Task 是否已經啓動和結束。Task 有五個狀態：runnable（可被啓動）, waiting（阻塞等待中）, queued（正被調度中）, done（執行結束）, failed（執行異常結束）。Julia 内部有一個調度器，負責維護 task 運行隊列;
                        end
                    end

                    # 讀出輸出通道中子協程(task)返回的結果;
                    # Base.take!(sub_to_main_channel);
                    # 這裏 for 結構本質上是一串自動執行的從通道中取出元素 take!() 的操作，和 take!() 操作一樣會移除元素。當通道 Channel 中元素取為空時，for 結構會阻塞;
                    # 使用 close(channelname) 强制關閉通道 Channel 的入口並釋放所有 put!() 和 take!() 的阻塞，此時 for 循環取完通道 Channel 中元素為空時，將不再阻塞會自行退出;
                    for result_Dict in sub_to_main_channel

                        # 記錄每個協程（Task）纍加的被調用運算的總次數;
                        # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                        # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                        if Base.haskey(total_worker_called_number, Base.string(result_Dict["threadID"]))
                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                        else
                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                        end
                        # if Base.haskey(total_worker_called_number, Base.string(result_Dict["taskID"]))
                        #     # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                        #     total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                        # else
                        #     # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                        #     total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                        # end

                        if Base.isa(result_Dict, Base.Dict) && Base.haskey(result_Dict, "label") && result_Dict["label"] === "error"

                            if Base.haskey(result_Dict, "taskID") && result_Dict["taskID"] !== Core.nothing && Base.isa(result_Dict["taskID"], Core.String) && result_Dict["taskID"] !== ""
                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                    println(result_Dict["message"]);  # error;
                                else
                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                end
                            else
                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                    println("task return error:");
                                    println(result_Dict["message"]);  # error;
                                else
                                    println("task return error.");
                                end
                            end

                            # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            # println(Base.string(nowTime));
                            # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                            # log_text = "error < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["monitor_file"]) * " > < " * Base.string(result_Dict["output_file"]) * " >.";
                            # print(log_text * "\n");
                            # log_file = "";  # 日志文檔;
                            # # 同步寫入用於記錄過程的日志文檔;
                            # try
                            #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                            #     # # write(filename::AbstractString, x)
                            #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                            #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                            #     # println(numBytes);
                            #     # println(Base.stat(log_file).size);
                            #     # println(Base.stat(log_file).mtime);
                            #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            #     # println(Base.stat(log_file).ctime);
                            #     # # Base.displaysize([io::IO]) -> (lines, columns)
                            #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                            #     # # Base.countlines — Function
                            #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                            #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                            #     # println(Base.countlines(log_file, eol='\\n'));

                            #     fWIO = Base.open(log_file, "a+");
                            #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                            #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                            #     # Keyword	Description				Default
                            #     # read		open for reading		!write
                            #     # write		open for writing		truncate | append
                            #     # create	create if non-existent	!read & write | truncate | append
                            #     # truncate	truncate to zero size	!read & write
                            #     # append	seek to end				false

                            #     # Mode	Description						Keywords
                            #     # r		read							none
                            #     # w		write, create, truncate			write = true
                            #     # a		write, create, append			append = true
                            #     # r+	read, write						read = true, write = true
                            #     # w+	read, write, create, truncate	truncate = true, read = true
                            #     # a+	read, write, create, append		append = true, read = true

                            #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                            #     if Base.iswritable(fWIO)
                            #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                            #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                            #         println(numBytes);
                            #         println(Base.stat(log_file).size);
                            #         println(Base.stat(log_file).mtime);
                            #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            #         println(Base.stat(log_file).ctime);
                            #         # Base.displaysize([io::IO]) -> (lines, columns)
                            #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                            #         # Base.countlines — Function
                            #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                            #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                            #         println(Base.countlines(log_file, eol='\\n'));
                            #     end

                            #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                            #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                            #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                            #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                            #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                            #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                            #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                            #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                            #     # Base.ismarked(io);  # Return true if stream s is marked;
                            #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                            #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                            #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                            #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                            #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                            #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                            #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                            #     # Base.close(io);  # 關閉緩衝區;
                            #     # println(a)
                            #     # Base.redirect_stdout — Function
                            #     # redirect_stdout([stream]) -> (rd, wr)
                            #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                            #     # If called with the optional stream argument, then returns stream itself.
                            #     # Base.redirect_stdout — Method
                            #     # redirect_stdout(f::Function, stream)
                            #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                            #     # Base.redirect_stderr — Function
                            #     # redirect_stderr([stream]) -> (rd, wr)
                            #     # Like redirect_stdout, but for stderr.
                            #     # Base.redirect_stderr — Method
                            #     # redirect_stderr(f::Function, stream)
                            #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                            #     # Base.redirect_stdin — Function
                            #     # redirect_stdin([stream]) -> (rd, wr)
                            #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                            #     # Base.redirect_stdin — Method
                            #     # redirect_stdin(f::Function, stream)
                            #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                            # catch err
                            #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                            #     println(err);
                            #     # println(Base.typeof(err));

                            #     # Julia提供了許多類型的錯誤：
                            #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                            #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                            #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                            #     # DivideError：這是數字除以0時的結果。
                            #     # DomainError：有效域之外的參數。
                            #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                            #     # InexactError：嘗試進行精確類型轉換失敗。
                            #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                            #     # LoadError：載入檔時發生錯誤。
                            #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                            #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                            #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                            #     # OverflowError：當操作結果太大時會發生這種情況。
                            #     # ParseError：解析給定運算式時出現問題。
                            #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                            #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                            #     # UndefRefError：未知引用。
                            #     # UndefVarError：對不存在的變數進行未知引用。
                            #     # InitError：調用模組的init方法時出現此錯誤。
                            #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                            #     # NullException：嘗試訪問Null值
                            #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                            #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                            # finally
                            #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                            #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                            #     if Base.eof(fWIO)
                            #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                            #     end
                            # end
                        end

                        if Base.isa(result_Dict, Base.Dict) && Base.haskey(result_Dict, "label") && result_Dict["label"] === "success"

                            # 判斷用於輸出的臨時暫存媒介文檔是否創建成功，如果創建成功，則修改文檔權限;
                            # result_Dict["output_file"] === input_queues_array[1]["output_file"] === temp_output_file === output_queues_array[1]["output_file"];
                            if Base.Filesystem.ispath(result_Dict["output_file"]) && Base.Filesystem.isfile(result_Dict["output_file"])
                                if Base.stat(result_Dict["output_file"]).mode !== Core.UInt64(33206) && Base.stat(result_Dict["output_file"]).mode !== Core.UInt64(33279)
                                    # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(result_Dict["output_file"]) 函數讀取文檔信息，使用 Base.stat(result_Dict["output_file"]).mode 方法提取文檔權限碼;
                                    # println("用於傳出數據的臨時暫存媒介文檔 [ " * result_Dict["output_file"] * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                    try
                                        # 使用 Base.Filesystem.chmod(result_Dict["output_file"], mode=0o777; recursive=false) 函數修改文檔操作權限;
                                        # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                        Base.Filesystem.chmod(result_Dict["output_file"], mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                        # println("文檔: " * result_Dict["output_file"] * " 操作權限成功修改爲 mode=0o777 .");

                                        # 八進制值    說明
                                        # 0o400      所有者可讀
                                        # 0o200      所有者可寫
                                        # 0o100      所有者可執行或搜索
                                        # 0o40       群組可讀
                                        # 0o20       群組可寫
                                        # 0o10       群組可執行或搜索
                                        # 0o4        其他人可讀
                                        # 0o2        其他人可寫
                                        # 0o1        其他人可執行或搜索
                                        # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                        # 數字	說明
                                        # 7	可讀、可寫、可執行
                                        # 6	可讀、可寫
                                        # 5	可讀、可執行
                                        # 4	唯讀
                                        # 3	可寫、可執行
                                        # 2	只寫
                                        # 1	只可執行
                                        # 0	沒有許可權
                                        # 例如，八進制值 0o765 表示：
                                        # 1) 、所有者可以讀取、寫入和執行該文檔；
                                        # 2) 、群組可以讀和寫入該文檔；
                                        # 3) 、其他人可以讀取和執行該文檔；
                                        # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                        # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                    catch err
                                        println("用於傳出數據的臨時暫存媒介文檔: " * result_Dict["output_file"] * " 無法修改操作權限爲 mode=0o777 .");
                                        println(err);
                                        # println(err.msg);
                                        # println(Base.typeof(err));
                                        # return ["error", result_Dict["output_file"], "document [ temp_output_file = " * Base.string(result_Dict["output_file"]) * " ] change the permissions mode=0o777 fail."];
                                    end
                                end
                            else
                                println("用於傳出數據的臨時暫存媒介文檔: " * result_Dict["output_file"] * " 無法被創建.");
                                # return ["error", result_Dict["output_file"], "document [ temp_output_file = " * Base.string(result_Dict["output_file"]) * " ] not create."];
                            end

                            result_Data = Base.Dict{Core.String, Core.Any}(
                                # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                                "monitor_file" => result_Dict["monitor_file"],  # temp_monitor_file，monitor_file，input_queues_array[1]["monitor_file"];
                                "monitor_dir" => result_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir，input_queues_array[1]["monitor_dir"];
                                # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                                "output_dir" => result_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir，input_queues_array[1]["output_dir"];
                                "output_file" => result_Dict["output_file"],  # temp_output_file，output_file，output_queues_array，input_queues_array[1]["output_file"];
                                "to_executable" => result_Dict["to_executable"],  # to_executable，input_queues_array[1]["to_executable"];
                                "to_script" => result_Dict["to_script"],  # to_script，input_queues_array[1]["to_script"];
                                "processID" => result_Dict["processID"],  # Base.string(Distributed.myid()),  # 子進程 ID;
                                "threadID" => result_Dict["threadID"],  # Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                "taskID" => result_Dict["taskID"],  # Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                "time" => result_Dict["time"]  # Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            );

                            # global output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                            output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                            # println(output_queues_array);
                            # println(length(output_queues_array));

                            # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 是否仍然存在，如果仍存在，則將用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 同步從硬盤刪除;
                            # result_Dict["monitor_file"] === input_queues_array[1]["monitor_file"] === temp_monitor_file === output_queues_array[1]["monitor_file"];
                            if Base.Filesystem.ispath(result_Dict["monitor_file"]) && Base.Filesystem.isfile(result_Dict["monitor_file"])
                                # 讀取到輸入數據之後，同步刪除，用於接收傳值的媒介文檔;
                                try
                                    # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                                    # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                    Base.Filesystem.rm(result_Dict["monitor_file"], force=true, recursive=false);  # 刪除給定路徑下的文檔、鏈接或空目錄，如果傳遞參數 force=true 時，則不存在的路徑不被視爲錯誤，如果傳遞參數 recursive=true 并且路徑是目錄時，則遞歸刪除所有内容;
                                    # Base.Filesystem.rm(path::AbstractString, force::Bool=false, recursive::Bool=false)
                                    # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                    # println("媒介文檔: " * result_Dict["monitor_file"] * " 已被刪除.");
                                catch err
                                    println("用於傳入數據的臨時暫存媒介文檔: " * result_Dict["monitor_file"] * " 無法刪除.");
                                    println(err);
                                    # println(err.msg);
                                    # println(Base.typeof(err));
                                    # return ["error", result_Dict["monitor_file"], "document [ temp_monitor_file = " * Base.string(result_Dict["monitor_file"]) * " ] not delete."];
                                end

                                # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                                # # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 在已處理完數據後，是否已經從硬盤刪除;
                                # if Base.Filesystem.ispath(result_Dict["monitor_file"]) && Base.Filesystem.isfile(result_Dict["monitor_file"])
                                #     println("用於傳入數據的臨時暫存媒介文檔: " * result_Dict["monitor_file"] * " 無法刪除.");
                                #     # return ["error", result_Dict["monitor_file"], "document [ temp_monitor_file = " * Base.string(result_Dict["monitor_file"]) * " ] not delete."];
                                # end
                            end

                            result_Data = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                            # Base.GC.gc();  # 内存回收函數 gc();

                            # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            # println(Base.string(nowTime));
                            # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                            # log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["monitor_file"]) * " > < " * Base.string(result_Dict["output_file"]) * " >.";
                            # print(log_text * "\n");
                            # log_file = "";  # 日志文檔;
                            # # 同步寫入用於記錄過程的日志文檔;
                            # try
                            #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                            #     # # write(filename::AbstractString, x)
                            #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                            #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                            #     # println(numBytes);
                            #     # println(Base.stat(log_file).size);
                            #     # println(Base.stat(log_file).mtime);
                            #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            #     # println(Base.stat(log_file).ctime);
                            #     # # Base.displaysize([io::IO]) -> (lines, columns)
                            #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                            #     # # Base.countlines — Function
                            #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                            #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                            #     # println(Base.countlines(log_file, eol='\\n'));

                            #     fWIO = Base.open(log_file, "a+");
                            #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                            #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                            #     # Keyword	Description				Default
                            #     # read		open for reading		!write
                            #     # write		open for writing		truncate | append
                            #     # create	create if non-existent	!read & write | truncate | append
                            #     # truncate	truncate to zero size	!read & write
                            #     # append	seek to end				false

                            #     # Mode	Description						Keywords
                            #     # r		read							none
                            #     # w		write, create, truncate			write = true
                            #     # a		write, create, append			append = true
                            #     # r+	read, write						read = true, write = true
                            #     # w+	read, write, create, truncate	truncate = true, read = true
                            #     # a+	read, write, create, append		append = true, read = true

                            #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                            #     if Base.iswritable(fWIO)
                            #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                            #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                            #         println(numBytes);
                            #         println(Base.stat(log_file).size);
                            #         println(Base.stat(log_file).mtime);
                            #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            #         println(Base.stat(log_file).ctime);
                            #         # Base.displaysize([io::IO]) -> (lines, columns)
                            #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                            #         # Base.countlines — Function
                            #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                            #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                            #         println(Base.countlines(log_file, eol='\\n'));
                            #     end

                            #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                            #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                            #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                            #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                            #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                            #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                            #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                            #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                            #     # Base.ismarked(io);  # Return true if stream s is marked;
                            #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                            #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                            #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                            #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                            #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                            #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                            #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                            #     # Base.close(io);  # 關閉緩衝區;
                            #     # println(a)
                            #     # Base.redirect_stdout — Function
                            #     # redirect_stdout([stream]) -> (rd, wr)
                            #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                            #     # If called with the optional stream argument, then returns stream itself.
                            #     # Base.redirect_stdout — Method
                            #     # redirect_stdout(f::Function, stream)
                            #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                            #     # Base.redirect_stderr — Function
                            #     # redirect_stderr([stream]) -> (rd, wr)
                            #     # Like redirect_stdout, but for stderr.
                            #     # Base.redirect_stderr — Method
                            #     # redirect_stderr(f::Function, stream)
                            #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                            #     # Base.redirect_stdin — Function
                            #     # redirect_stdin([stream]) -> (rd, wr)
                            #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                            #     # Base.redirect_stdin — Method
                            #     # redirect_stdin(f::Function, stream)
                            #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                            # catch err
                            #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                            #     println(err);
                            #     # println(Base.typeof(err));
                            #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                            # finally
                            #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                            #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                            #     if Base.eof(fWIO)
                            #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                            #     end
                            # end
                        end

                        # 使用 Base.isready(c::Channel) 函數判斷通道中元素是否已經取空，如果已經取空 Base.isready(c::Channel) 返回為 false 值，則跳出 for 循環，如果一個空通道從未寫入過元素，則 Base.isready(sub_to_main_channel) 值爲 true，因此會一直阻塞等待不會跳出循環;
                        if !Base.isready(sub_to_main_channel)
                            break;
                        end
                    end

                    # 刪除任務隊列數組中前面已經處理過的任務元素;
                    for i in 1:input_queues_length
                        # global input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                        input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                    end
                end

                if Base.string(isDoTasksOrThreads) === Base.string("Multi-Threading")

                    # 必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
                    # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
                    # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
                    # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
                    # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;

                    # 通道、管道(Channel);
                    # Base.Channel{T=Any}(size::Int=0);
                    # 如果一個 Channel 是空的，讀取的 task（即執行 v = Base.take!(c::Channel) 的 task）會被阻塞直到有新的資料準備好了。
                    # 如果一個 Channel 是滿的，那麼寫入的 task（即執行 Base.put!(c::Channel, v) 的 task）則會被阻塞，直到 Channel 有空餘。
                    # Base.isready(c::Channel) 可以用來檢查一個 channel 中是否有已經準備好的元素，而等待一個元素準備好 則用 Base.wait(r::Future) 函數。
                    # 一個 Channel 一開始處於開啟狀態，也就是說可以被 take! 讀取和 put! 寫入。Base.close(c::Channel[, excp::Exception]) 會關閉一個 Channel，對於一個已經關閉的 Channel，put! 會失敗。
                    # Channel 可以在 for 迴圈中遍歷，此時，迴圈會一直運行直到 Channel 中有資料，遍歷過程中會取遍加入到 Channel 中的所有值。一旦 Channel關閉或者取空了，for 迴圈就會終止。
                    # c = Channel{Int}(10)
                    # foreach(i->put!(c, i), 1:3)
                    # 此時，如果直接用 for 去遍歷通道 c 中的內容，則在讀取完後會一直等待通道(Channel)中有新的資料進來，如果在控制臺REPL上運行，則會停在那裡。
                    # data = [i for i in c]
                    # 如果先把Channel關閉，再用for去遍歷，則會讀出Channel中的內容，因此此時c已經關閉，for不會再等待寫入了。
                    # close(c);
                    # data = [i for i in c]

                    # 使用 Base.bind(chnl::Channel, task::Task) 方法，將通道(Channel)的生存期與任務或叫協程(task)相關聯。當協程(task)終止時，通道(Channel)自動關閉。任務中任何未捕獲的異常都會傳播到通道(Channel)上的所有等待者。
                    # 通道(Channel)對象可以獨立於協程(task)終止顯式關閉。終止協程(task)對已關閉的通道(Channel)對象沒有影響。
                    # 當通道(Channel)綁定到多個協程(task)時，第一個終止的協程(task)將關閉通道(Channel)。當多個通道(Channel)綁定到同一個協程(task)時，協程(task)的終止將關閉所有綁定的通道(Channel)。
                    # task = Base.@async foreach(i->put!(c, i), 1:4);
                    # Base.bind(c,task);
                    # for i in c
                    #     Base.@show i
                    #     println(Base.current_task())
                    # end;
                    # i = 1
                    # i = 2
                    # i = 3
                    # i = 4
                    # Base.isopen(c)
                    # false
                    # c2 = Base.Channel{Core.Float64}(32)  # 創建一個長度爲 32，元素(item)類型爲 Float64 的通道(Channel);
                    # Base.put!(c2, 2)  # 向通道(Channel)中寫入元素;
                    # itme1 = Base.fetch(c2)  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
                    # itme1 = Base.take!(c2)  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                    # Base.close(c2)  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗，take!() 和 fetch() 爲空時，將會關閉這個通道;
                    # Base.isready(c2)

                    # # 用Channel完成多工（多任務 task）之間的資料交互
                    # # 新建兩個Channel，一個是Int型，一個是Tuple型，對於每個任務，延時一段時間後，開始執行該任務的內容，並將結果放入到results中。
                    # const jobs = Channel{Int}(32)
                    # const results = Channel{Tuple}(32)
                    # function do_work()
                    #     for job_id in jobs
                    #         exec_time = rand()
                    #         Base.sleep(exec_time)  # simulates elapsed time doing actual work typically performed externally.
                    #         put!(results, (job_id, exec_time))
                    #     end
                    # end
                    # # 向jobs中放入數據
                    # function make_jobs(n)
                    #     for i in 1:n
                    #         put!(jobs, i)
                    #     end
                    # end
                    # # 寫入12個資料
                    # n = 12
                    # @async make_jobs(n)
                    # # @async表示把後面的運算式放到Task裡，並加入到程式的執行清單中
                    # # 開四個任務來處理
                    # for i in 1:4
                    #     # start 4 tasks to process requests in parallel
                    #     @async do_work()
                    # end
                    # # 取出4個任務的執行結果
                    # @elapsed while n > 0
                    #     # print out results
                    #     job_id, exec_time = take!(results)
                    #     println("$job_id finished in $(round(exec_time; digits=2)) seconds")
                    #     global n = n - 1
                    # end
                    # # >>1 finished in 0.51 seconds
                    # # 4 finished in 0.62 seconds
                    # # 3 finished in 0.75 seconds
                    # # 2 finished in 0.81 seconds
                    # # 5 finished in 0.55 seconds
                    # # 8 finished in 0.35 seconds
                    # # 6 finished in 0.77 seconds
                    # # 9 finished in 0.38 seconds
                    # # 12 finished in 0.11 seconds
                    # # 7 finished in 0.88 seconds
                    # # 11 finished in 0.25 seconds
                    # # 10 finished in 0.75 seconds

                    input_queues_length = Base.length(input_queues_array);

                    # Base.Threads.@spawn expr
                    # Create and run a Task on any available thread. To wait for the task to finish, call wait on the result of this macro, or call fetch to wait and then obtain its return value.
                    # 使用 Base.Threads.@spawn 方法創建一個子綫程執行具體動作;
                    for i in 1:input_queues_length

                        if Base.isa(input_queues_array[i], Base.Dict)

                            # 控制並發數;
                            # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                            Base.put!(control_number_Queues_channel, Core.UInt64(i));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                            worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[i]["read_file_do_Function"];
                                "monitor_file" => input_queues_array[i]["monitor_file"],  # monitor_file;
                                "monitor_dir" => input_queues_array[i]["monitor_dir"],  # monitor_dir;
                                # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                "output_dir" => input_queues_array[i]["output_dir"],  # output_dir;
                                "output_file" => input_queues_array[i]["output_file"],  # output_file，output_queues_array;
                                "to_executable" => input_queues_array[i]["to_executable"],
                                "to_script" => input_queues_array[i]["to_script"]
                            );

                            # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                            # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                            Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                            # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                            #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                            # end

                            # 創建一個子綫程（worker thread）;
                            # workerThread = Base.Threads.@spawn begin
                            #     funcTask(do_Function, read_file_do_Function, time_sleep, main_to_sub_channel, sub_to_main_channel, control_number_Queues_channel);
                            # end
                            workerThread = Base.Threads.@spawn funcTask(do_Function, read_file_do_Function, time_sleep, main_to_sub_channel, sub_to_main_channel, control_number_Queues_channel);
                            # r = Base.fetch(workerThread);  # 等待讀取子綫程運行完畢後的返回值，阻塞後面的代碼執行;
                            # Base.wait(workerThread);  # 阻塞主進程後面的代碼執行，直到該子綫程 workerThread 運行完畢;

                            # # 保存每個被創建的綫程（worker thread）在一個字典中;
                            # # 使用 Base.Threads.threadid() 方法返回當前綫程 ID 號;
                            # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                            # if Base.haskey(worker_queues_Dict, Base.string(Base.Threads.threadid(workerThread)))
                            #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                            #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                            # else
                            #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                            #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                            # end
                            # # 記錄每個綫程纍加的被調用運算的總次數;
                            # # 使用 Base.Threads.threadid() 方法返回當前子綫程(thread) ID 號;
                            # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                            # if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid(workerThread)))
                            #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                            #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                            # else
                            #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            # end
                        end
                    end

                    # # Base.Threads.@threads for...end
                    # # A macro to parallelize a for-loop to run with multiple threads. This spawns nthreads() number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.
                    # # 使用 Base.Threads.@threads for...end 方法創建子綫程，多綫程并發執行 for...end 循環，在每次 for 循環中具體動作;
                    # Base.Threads.@threads for i in 1:input_queues_length

                    #     if Base.isa(input_queues_array[i], Base.Dict)

                    #         # 控制並發數;
                    #         # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                    #         Base.put!(control_number_Queues_channel, Core.UInt64(i));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                    #         worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                    #             # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[i]["read_file_do_Function"];
                    #             "monitor_file" => input_queues_array[i]["monitor_file"],  # monitor_file;
                    #             "monitor_dir" => input_queues_array[i]["monitor_dir"],  # monitor_dir;
                    #             # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                    #             "output_dir" => input_queues_array[i]["output_dir"],  # output_dir;
                    #             "output_file" => input_queues_array[i]["output_file"],  # output_file，output_queues_array;
                    #             "to_executable" => input_queues_array[i]["to_executable"],
                    #             "to_script" => input_queues_array[i]["to_script"]
                    #         );

                    #         # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                    #         # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                    #         Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                    #         # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                    #         #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                    #         # end

                    #         resultArray = funcTask(do_Function, read_file_do_Function, time_sleep, main_to_sub_channel, sub_to_main_channel, control_number_Queues_channel);
                    #         # println(resultArray);

                    #         # # 保存每個被創建的綫程（worker thread）在一個字典中;
                    #         # # 使用 Base.Threads.threadid() 方法返回當前綫程 ID 號;
                    #         # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                    #         # if Base.haskey(worker_queues_Dict, Base.string(Base.Threads.threadid(workerThread)))
                    #         #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                    #         #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                    #         # else
                    #         #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                    #         #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                    #         # end
                    #         # # 記錄每個綫程纍加的被調用運算的總次數;
                    #         # # 使用 Base.Threads.threadid() 方法返回當前子綫程(thread) ID 號;
                    #         # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                    #         # if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid(workerThread)))
                    #         #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                    #         #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                    #         # else
                    #         #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                    #         #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                    #         # end
                    #     end
                    # end

                    # 讀出輸出通道中子綫程（worker thread）返回的結果;
                    # Base.take!(sub_to_main_channel);
                    # 這裏 for 結構本質上是一串自動執行的從通道中取出元素 take!() 的操作，和 take!() 操作一樣會移除元素。當通道 Channel 中元素取為空時，for 結構會阻塞;
                    # 使用 close(channelname) 强制關閉通道 Channel 的入口並釋放所有 put!() 和 take!() 的阻塞，此時 for 循環取完通道 Channel 中元素為空時，將不再阻塞會自行退出;
                    for result_Dict in sub_to_main_channel

                        # 記錄每個綫程纍加的被調用運算的總次數;
                        # 使用 Base.Threads.threadid() 方法返回當前子綫程(thread) ID 號;
                        # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                        if Base.haskey(total_worker_called_number, Base.string(result_Dict["threadID"]))
                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                        else
                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                        end

                        if Base.isa(result_Dict, Base.Dict) && Base.haskey(result_Dict, "label") && result_Dict["label"] === "error"

                            if Base.haskey(result_Dict, "threadID") && result_Dict["threadID"] !== Core.nothing && Base.isa(result_Dict["threadID"], Core.String) && result_Dict["threadID"] !== ""
                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                    println("worker thread-" * Base.string(result_Dict["threadID"]) * " return error:");
                                    println(result_Dict["message"]);  # error;
                                else
                                    println("worker thread-" * Base.string(result_Dict["threadID"]) * " return error:");
                                end
                            else
                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                    println("worker thread return error:");
                                    println(result_Dict["message"]);  # error;
                                else
                                    println("worker thread return error.");
                                end
                            end

                            # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            # println(Base.string(nowTime));
                            # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                            # log_text = "error < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["monitor_file"]) * " > < " * Base.string(result_Dict["output_file"]) * " >.";
                            # print(log_text * "\n");
                            # log_file = "";  # 日志文檔;
                            # # 同步寫入用於記錄過程的日志文檔;
                            # try
                            #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                            #     # # write(filename::AbstractString, x)
                            #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                            #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                            #     # println(numBytes);
                            #     # println(Base.stat(log_file).size);
                            #     # println(Base.stat(log_file).mtime);
                            #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            #     # println(Base.stat(log_file).ctime);
                            #     # # Base.displaysize([io::IO]) -> (lines, columns)
                            #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                            #     # # Base.countlines — Function
                            #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                            #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                            #     # println(Base.countlines(log_file, eol='\\n'));

                            #     fWIO = Base.open(log_file, "a+");
                            #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                            #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                            #     # Keyword	Description				Default
                            #     # read		open for reading		!write
                            #     # write		open for writing		truncate | append
                            #     # create	create if non-existent	!read & write | truncate | append
                            #     # truncate	truncate to zero size	!read & write
                            #     # append	seek to end				false

                            #     # Mode	Description						Keywords
                            #     # r		read							none
                            #     # w		write, create, truncate			write = true
                            #     # a		write, create, append			append = true
                            #     # r+	read, write						read = true, write = true
                            #     # w+	read, write, create, truncate	truncate = true, read = true
                            #     # a+	read, write, create, append		append = true, read = true

                            #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                            #     if Base.iswritable(fWIO)
                            #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                            #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                            #         println(numBytes);
                            #         println(Base.stat(log_file).size);
                            #         println(Base.stat(log_file).mtime);
                            #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            #         println(Base.stat(log_file).ctime);
                            #         # Base.displaysize([io::IO]) -> (lines, columns)
                            #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                            #         # Base.countlines — Function
                            #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                            #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                            #         println(Base.countlines(log_file, eol='\\n'));
                            #     end

                            #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                            #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                            #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                            #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                            #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                            #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                            #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                            #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                            #     # Base.ismarked(io);  # Return true if stream s is marked;
                            #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                            #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                            #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                            #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                            #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                            #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                            #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                            #     # Base.close(io);  # 關閉緩衝區;
                            #     # println(a)
                            #     # Base.redirect_stdout — Function
                            #     # redirect_stdout([stream]) -> (rd, wr)
                            #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                            #     # If called with the optional stream argument, then returns stream itself.
                            #     # Base.redirect_stdout — Method
                            #     # redirect_stdout(f::Function, stream)
                            #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                            #     # Base.redirect_stderr — Function
                            #     # redirect_stderr([stream]) -> (rd, wr)
                            #     # Like redirect_stdout, but for stderr.
                            #     # Base.redirect_stderr — Method
                            #     # redirect_stderr(f::Function, stream)
                            #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                            #     # Base.redirect_stdin — Function
                            #     # redirect_stdin([stream]) -> (rd, wr)
                            #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                            #     # Base.redirect_stdin — Method
                            #     # redirect_stdin(f::Function, stream)
                            #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                            # catch err
                            #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                            #     println(err);
                            #     # println(Base.typeof(err));

                            #     # Julia提供了許多類型的錯誤：
                            #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                            #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                            #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                            #     # DivideError：這是數字除以0時的結果。
                            #     # DomainError：有效域之外的參數。
                            #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                            #     # InexactError：嘗試進行精確類型轉換失敗。
                            #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                            #     # LoadError：載入檔時發生錯誤。
                            #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                            #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                            #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                            #     # OverflowError：當操作結果太大時會發生這種情況。
                            #     # ParseError：解析給定運算式時出現問題。
                            #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                            #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                            #     # UndefRefError：未知引用。
                            #     # UndefVarError：對不存在的變數進行未知引用。
                            #     # InitError：調用模組的init方法時出現此錯誤。
                            #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                            #     # NullException：嘗試訪問Null值
                            #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                            #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                            # finally
                            #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                            #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                            #     if Base.eof(fWIO)
                            #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                            #     end
                            # end
                        end

                        if Base.isa(result_Dict, Base.Dict) && Base.haskey(result_Dict, "label") && result_Dict["label"] === "success"

                            # 判斷用於輸出的臨時暫存媒介文檔是否創建成功，如果創建成功，則修改文檔權限;
                            # result_Dict["output_file"] === input_queues_array[1]["output_file"] === temp_output_file === output_queues_array[1]["output_file"];
                            if Base.Filesystem.ispath(result_Dict["output_file"]) && Base.Filesystem.isfile(result_Dict["output_file"])
                                if Base.stat(result_Dict["output_file"]).mode !== Core.UInt64(33206) && Base.stat(result_Dict["output_file"]).mode !== Core.UInt64(33279)
                                    # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(result_Dict["output_file"]) 函數讀取文檔信息，使用 Base.stat(result_Dict["output_file"]).mode 方法提取文檔權限碼;
                                    # println("用於傳出數據的臨時暫存媒介文檔 [ " * result_Dict["output_file"] * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                    try
                                        # 使用 Base.Filesystem.chmod(result_Dict["output_file"], mode=0o777; recursive=false) 函數修改文檔操作權限;
                                        # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                        Base.Filesystem.chmod(result_Dict["output_file"], mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                        # println("文檔: " * result_Dict["output_file"] * " 操作權限成功修改爲 mode=0o777 .");

                                        # 八進制值    說明
                                        # 0o400      所有者可讀
                                        # 0o200      所有者可寫
                                        # 0o100      所有者可執行或搜索
                                        # 0o40       群組可讀
                                        # 0o20       群組可寫
                                        # 0o10       群組可執行或搜索
                                        # 0o4        其他人可讀
                                        # 0o2        其他人可寫
                                        # 0o1        其他人可執行或搜索
                                        # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                        # 數字	說明
                                        # 7	可讀、可寫、可執行
                                        # 6	可讀、可寫
                                        # 5	可讀、可執行
                                        # 4	唯讀
                                        # 3	可寫、可執行
                                        # 2	只寫
                                        # 1	只可執行
                                        # 0	沒有許可權
                                        # 例如，八進制值 0o765 表示：
                                        # 1) 、所有者可以讀取、寫入和執行該文檔；
                                        # 2) 、群組可以讀和寫入該文檔；
                                        # 3) 、其他人可以讀取和執行該文檔；
                                        # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                        # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                    catch err
                                        println("用於傳出數據的臨時暫存媒介文檔: " * result_Dict["output_file"] * " 無法修改操作權限爲 mode=0o777 .");
                                        println(err);
                                        # println(err.msg);
                                        # println(Base.typeof(err));
                                        # return ["error", result_Dict["output_file"], "document [ temp_output_file = " * Base.string(result_Dict["output_file"]) * " ] change the permissions mode=0o777 fail."];
                                    end
                                end
                            else
                                println("用於傳出數據的臨時暫存媒介文檔: " * result_Dict["output_file"] * " 無法被創建.");
                                # return ["error", result_Dict["output_file"], "document [ temp_output_file = " * Base.string(result_Dict["output_file"]) * " ] not create."];
                            end

                            result_Data = Base.Dict{Core.String, Core.Any}(
                                # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                                "monitor_file" => result_Dict["monitor_file"],  # temp_monitor_file，monitor_file，input_queues_array[1]["monitor_file"];
                                "monitor_dir" => result_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir，input_queues_array[1]["monitor_dir"];
                                # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                                "output_dir" => result_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir，input_queues_array[1]["output_dir"];
                                "output_file" => result_Dict["output_file"],  # temp_output_file，output_file，output_queues_array，input_queues_array[1]["output_file"];
                                "to_executable" => result_Dict["to_executable"],  # to_executable，input_queues_array[1]["to_executable"];
                                "to_script" => result_Dict["to_script"],  # to_script，input_queues_array[1]["to_script"];
                                "processID" => result_Dict["processID"],  # Base.string(Distributed.myid()),  # 子進程 ID;
                                "threadID" => result_Dict["threadID"],  # Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                "taskID" => result_Dict["taskID"],  # Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                "time" => result_Dict["time"]  # Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            );

                            # global output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                            output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                            # println(output_queues_array);
                            # println(length(output_queues_array));

                            # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 是否仍然存在，如果仍存在，則將用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 同步從硬盤刪除;
                            # result_Dict["monitor_file"] === input_queues_array[1]["monitor_file"] === temp_monitor_file === output_queues_array[1]["monitor_file"];
                            if Base.Filesystem.ispath(result_Dict["monitor_file"]) && Base.Filesystem.isfile(result_Dict["monitor_file"])
                                # 讀取到輸入數據之後，同步刪除，用於接收傳值的媒介文檔;
                                try
                                    # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                                    # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                    Base.Filesystem.rm(result_Dict["monitor_file"], force=true, recursive=false);  # 刪除給定路徑下的文檔、鏈接或空目錄，如果傳遞參數 force=true 時，則不存在的路徑不被視爲錯誤，如果傳遞參數 recursive=true 并且路徑是目錄時，則遞歸刪除所有内容;
                                    # Base.Filesystem.rm(path::AbstractString, force::Bool=false, recursive::Bool=false)
                                    # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                    # println("媒介文檔: " * result_Dict["monitor_file"] * " 已被刪除.");
                                catch err
                                    println("用於傳入數據的臨時暫存媒介文檔: " * result_Dict["monitor_file"] * " 無法刪除.");
                                    println(err);
                                    # println(err.msg);
                                    # println(Base.typeof(err));
                                    # return ["error", result_Dict["monitor_file"], "document [ temp_monitor_file = " * Base.string(result_Dict["monitor_file"]) * " ] not delete."];
                                end

                                # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                                # # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 在已處理完數據後，是否已經從硬盤刪除;
                                # if Base.Filesystem.ispath(result_Dict["monitor_file"]) && Base.Filesystem.isfile(result_Dict["monitor_file"])
                                #     println("用於傳入數據的臨時暫存媒介文檔: " * result_Dict["monitor_file"] * " 無法刪除.");
                                #     # return ["error", result_Dict["monitor_file"], "document [ temp_monitor_file = " * Base.string(result_Dict["monitor_file"]) * " ] not delete."];
                                # end
                            end

                            result_Data = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                            # Base.GC.gc();  # 内存回收函數 gc();

                            # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            # println(Base.string(nowTime));
                            # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                            # log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["monitor_file"]) * " > < " * Base.string(result_Dict["output_file"]) * " >.";
                            # print(log_text * "\n");
                            # log_file = "";  # 日志文檔;
                            # # 同步寫入用於記錄過程的日志文檔;
                            # try
                            #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                            #     # # write(filename::AbstractString, x)
                            #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                            #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                            #     # println(numBytes);
                            #     # println(Base.stat(log_file).size);
                            #     # println(Base.stat(log_file).mtime);
                            #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            #     # println(Base.stat(log_file).ctime);
                            #     # # Base.displaysize([io::IO]) -> (lines, columns)
                            #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                            #     # # Base.countlines — Function
                            #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                            #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                            #     # println(Base.countlines(log_file, eol='\\n'));

                            #     fWIO = Base.open(log_file, "a+");
                            #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                            #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                            #     # Keyword	Description				Default
                            #     # read		open for reading		!write
                            #     # write		open for writing		truncate | append
                            #     # create	create if non-existent	!read & write | truncate | append
                            #     # truncate	truncate to zero size	!read & write
                            #     # append	seek to end				false

                            #     # Mode	Description						Keywords
                            #     # r		read							none
                            #     # w		write, create, truncate			write = true
                            #     # a		write, create, append			append = true
                            #     # r+	read, write						read = true, write = true
                            #     # w+	read, write, create, truncate	truncate = true, read = true
                            #     # a+	read, write, create, append		append = true, read = true

                            #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                            #     if Base.iswritable(fWIO)
                            #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                            #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                            #         println(numBytes);
                            #         println(Base.stat(log_file).size);
                            #         println(Base.stat(log_file).mtime);
                            #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            #         println(Base.stat(log_file).ctime);
                            #         # Base.displaysize([io::IO]) -> (lines, columns)
                            #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                            #         # Base.countlines — Function
                            #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                            #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                            #         println(Base.countlines(log_file, eol='\\n'));
                            #     end

                            #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                            #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                            #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                            #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                            #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                            #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                            #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                            #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                            #     # Base.ismarked(io);  # Return true if stream s is marked;
                            #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                            #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                            #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                            #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                            #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                            #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                            #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                            #     # Base.close(io);  # 關閉緩衝區;
                            #     # println(a)
                            #     # Base.redirect_stdout — Function
                            #     # redirect_stdout([stream]) -> (rd, wr)
                            #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                            #     # If called with the optional stream argument, then returns stream itself.
                            #     # Base.redirect_stdout — Method
                            #     # redirect_stdout(f::Function, stream)
                            #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                            #     # Base.redirect_stderr — Function
                            #     # redirect_stderr([stream]) -> (rd, wr)
                            #     # Like redirect_stdout, but for stderr.
                            #     # Base.redirect_stderr — Method
                            #     # redirect_stderr(f::Function, stream)
                            #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                            #     # Base.redirect_stdin — Function
                            #     # redirect_stdin([stream]) -> (rd, wr)
                            #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                            #     # Base.redirect_stdin — Method
                            #     # redirect_stdin(f::Function, stream)
                            #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                            # catch err
                            #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                            #     println(err);
                            #     # println(Base.typeof(err));
                            #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                            # finally
                            #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                            #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                            #     if Base.eof(fWIO)
                            #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                            #     end
                            # end
                        end

                        # 使用 Base.isready(c::Channel) 函數判斷通道中元素是否已經取空，如果已經取空 Base.isready(c::Channel) 返回為 false 值，則跳出 for 循環，如果一個空通道從未寫入過元素，則 Base.isready(sub_to_main_channel) 值爲 true，因此會一直阻塞等待不會跳出循環;
                        if !Base.isready(sub_to_main_channel)
                            break;
                        end
                    end

                    # 刪除任務隊列數組中前面已經處理過的任務元素;
                    for i in 1:input_queues_length
                        # global input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                        input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                    end
                end
            end

            return ["input_queues_array[1] -> temp_monitor_file -> temp_output_file -> output_queues_array[last]", input_queues_array, output_queues_array];
        else
            return ["The input queues array empty.", input_queues_array, output_queues_array];
        end
    end

    # 創建一個自定義的函數，當計時器輪詢時調用，用以監聽傳出數據等待處理的任務隊列，當傳出數據等待處理的任務隊列長度大於 1 時，采用先進先出的原則，處理隊列中的任務排隊，並相應清除已經被處理過的任務元素;
    function func_Monitor_output_queues(
        # monitor_file::Core.String,
        # monitor_dir::Core.String,
        # do_Function,
        # output_dir::Core.String,
        output_file::Core.String,
        # to_executable::Core.String,
        # to_script::Core.String,
        # temp_cache_IO_data_dir::Core.String,
        # number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
        # time_sleep::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
        input_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1},
        output_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1}
    ) ::Core.Array{Core.Any, 1}

        # # print("當前協程 task: ", Base.current_task(), "\n");
        # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
        # print("當前綫程 thread 的 PID: ", Base.Threads.threadid(), "\n");
        # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
        # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
        # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
        # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
        # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
        # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
        # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
        # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
        # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
        # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
        # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
        # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
        # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

        output_queues_array = Base.deepcopy(output_queues);
        input_queues_array = Base.deepcopy(input_queues);

        # 監聽待傳出數據結果隊列數組 output_queues_array，當有用於傳出數據的媒介目錄 output_dir 中不在含有 output_file 時，將待傳出數據結果隊列數組 output_queues_array 中排在前面的第一個結果文檔，更名移人用於傳出數據的媒介目錄 output_dir 中;
        if Base.length(output_queues_array) > 0

            output_queues_1_Dict = Base.Dict{Core.String, Core.Any}();  #  聲明一個空的字典類型的變量，承接 output_queues_array 數組中的一個元素;
            output_queues_1_Dict = output_queues_array[1];

            # 判斷用於輸出傳值的媒介文檔，是否已經存在且是否為文檔，如果已存在則從硬盤刪除，然後重新創建並寫入新值;
            if Base.Filesystem.ispath(output_file) && Base.Filesystem.isfile(output_file)
                # println("用於輸出傳值的媒介文檔: " * output_file * " 已經存在.");
                return ["The output_file already exists.", input_queues_array, output_queues_array];
            else
                # # global output_queues_array = Base.deleteat!(output_queues_array, 1);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                output_queues_array = Base.deleteat!(output_queues_array, 1);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                # # println(input_queues_array);
                # # println(length(input_queues_array));
                # # result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = input_queues_array[1]["read_file_do_Function"](input_queues_array[1]["monitor_file"], input_queues_array[1]["monitor_dir"], input_queues_array[1]["do_Function"], input_queues_array[1]["output_dir"], input_queues_array[1]["output_file"], input_queues_array[1]["to_executable"], input_queues_array[1]["to_script"], time_sleep);

                # 監聽指定的硬盤用於傳數據的媒介文檔，當出現監聽的目標文檔時，激活處理函數;
                # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介文檔是否存在，如果不存在，則中止函數退出，如果存在則判斷操作權限，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
                # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isfile(monitor_file) 方法判斷是否為文檔;
                if !(Base.Filesystem.ispath(output_queues_1_Dict["output_file"]) && Base.Filesystem.isfile(output_queues_1_Dict["output_file"]))
                    # output_queues_1_Dict["output_file"] === output_queues_array[1]["output_file"]
                    # # global output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                    # output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                    return ["document < temp_output_file = " * Base.string(output_queues_1_Dict["output_file"]) * " > not exists.", input_queues_array, output_queues_array];
                end

                if Base.Filesystem.ispath(output_queues_1_Dict["output_file"]) && Base.Filesystem.isfile(output_queues_1_Dict["output_file"])

                    # 檢查文檔操作權限，修改爲可讀、可寫權限，# output_queues_1_Dict["output_file"] === output_queues_array[1]["output_file"];
                    if Base.stat(output_queues_1_Dict["output_file"]).mode !== Core.UInt64(33206) && Base.stat(output_queues_1_Dict["output_file"]).mode !== Core.UInt64(33279)
                        # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(output_queues_1_Dict["output_file"]) 函數讀取文檔信息，使用 Base.stat(output_queues_1_Dict["output_file"]).mode 方法提取文檔權限碼;
                        # println("用於傳值的媒介文檔 [ " * output_queues_1_Dict["output_file"] * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                        try
                            # 使用 Base.Filesystem.chmod(output_queues_1_Dict["output_file"], mode=0o777; recursive=false) 函數修改文檔操作權限;
                            # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                            Base.Filesystem.chmod(output_queues_1_Dict["output_file"], mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                            # println("文檔: " * output_queues_1_Dict["output_file"] * " 操作權限成功修改爲 mode=0o777 .");

                            # 八進制值    說明
                            # 0o400      所有者可讀
                            # 0o200      所有者可寫
                            # 0o100      所有者可執行或搜索
                            # 0o40       群組可讀
                            # 0o20       群組可寫
                            # 0o10       群組可執行或搜索
                            # 0o4        其他人可讀
                            # 0o2        其他人可寫
                            # 0o1        其他人可執行或搜索
                            # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                            # 數字	說明
                            # 7	可讀、可寫、可執行
                            # 6	可讀、可寫
                            # 5	可讀、可執行
                            # 4	唯讀
                            # 3	可寫、可執行
                            # 2	只寫
                            # 1	只可執行
                            # 0	沒有許可權
                            # 例如，八進制值 0o765 表示：
                            # 1) 、所有者可以讀取、寫入和執行該文檔；
                            # 2) 、群組可以讀和寫入該文檔；
                            # 3) 、其他人可以讀取和執行該文檔；
                            # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                            # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                        catch err
                            println("用於輸出數據的臨時暫存媒介文檔: " * output_queues_1_Dict["output_file"] * " 無法修改操作權限爲 mode=0o777 .");
                            println(err);
                            # println(err.msg);
                            # println(Base.typeof(err));
                            # # global output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                            # output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                            return ["document < temp_output_file = " * Base.string(output_queues_1_Dict["output_file"]) * " > change the permissions mode=0o777 fail.", input_queues_array, output_queues_array];
                        end
                    end

                    # 同步移動更名文檔，將用於傳出數據的臨時暫存媒介文檔 temp_output_file 從臨時暫存媒介文件夾 temp_cache_IO_data_dir 移動到輸出數據的媒介文件夾 output_dir 並更名為正式輸出數據的媒介文檔 output_file;
                    try
                        # Base.Filesystem.mv(src::AbstractString, dst::AbstractString; force::Bool=false)
                        # Move the file, link, or directory from src to dst. force=true will first remove an existing dst. Return dst.
                        Base.Filesystem.mv(output_queues_1_Dict["output_file"], output_file; force=false);  # 將文檔、鏈接或目錄從 output_queues_1_Dict["output_file"] 更名移動到 output_file，如果參數 force=true 將首先刪除現有的 output_file 文檔，函數返回值為 output_file 字符串;
                        # println("用於輸出傳值的臨時暫存媒介文檔: " * output_queues_1_Dict["output_file"] * " 已經被移動更名爲用於傳出數據的正式媒介文檔: " * output_file * " .");
                    catch err
                        println("用於輸出數據的臨時暫存媒介文檔: " * output_queues_1_Dict["output_file"] * " 無法移動更名爲用於傳出數據的正式媒介文檔: " * output_file * " .");
                        println(err);
                        # println(Base.typeof(err));
                        # # global output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                        # output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                        return ["document < temp_output_file = " * Base.string(output_queues_1_Dict["output_file"]) * " > not move to < " * Base.string(output_file) * " >.", input_queues_array, output_queues_array];
                    end

                    # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                    # # 判斷用於輸出傳值的臨時暫存媒介文檔 output_queues_1_Dict["output_file"]，是否已經從硬盤刪除，即判斷用於輸出傳值的臨時暫存媒介文檔，是否已經從臨時暫存媒介目錄 temp_cache_IO_data_dir 移動到用於輸出的正式媒介目錄 output_dir，並已經更名為 output_file;
                    # if Base.Filesystem.ispath(output_queues_1_Dict["output_file"]) && Base.Filesystem.isfile(output_queues_1_Dict["output_file"])
                    #     println("用於輸出數據的臨時暫存媒介文檔: " * output_queues_1_Dict["output_file"] * " 無法移動更名爲用於傳出數據的正式媒介文檔: " * output_file * " .");
                    #     return ["error", output_queues_1_Dict["output_file"], "document [ temp_output_file = " * Base.string(output_queues_1_Dict["output_file"]) * " ] not move."];
                    # end

                    # 判斷新生成用於輸出傳值的正式媒介文檔 output_file，是否已經創建成功，即判斷用於輸出傳值的臨時暫存媒介文檔 temp_output_file，是否已經從臨時暫存媒介目錄 temp_cache_IO_data_dir 移動到用於輸出的正式媒介目錄 output_dir，並已經更名為 output_file;
                    if Base.Filesystem.ispath(output_file) && Base.Filesystem.isfile(output_file)

                        # # 檢查指定用於輸出傳值的正式媒介文檔 output_file 的操作權限是否爲可讀并且可寫，如無可讀可寫權限，則對其修改權限;
                        # if Base.stat(output_file).mode !== Core.UInt64(33206) && Base.stat(output_file).mode !== Core.UInt64(33279)
                        #     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(output_file) 函數讀取文檔信息，使用 Base.stat(output_file).mode 方法提取文檔權限碼;
                        #     # println("用於輸出傳值的正式媒介文檔 [ " * output_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                        #     try
                        #         # 使用 Base.Filesystem.chmod(output_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
                        #         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                        #         Base.Filesystem.chmod(output_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                        #         # println("文檔: " * output_file * " 操作權限成功修改爲 mode=0o777 .");

                        #         # 八進制值    說明
                        #         # 0o400      所有者可讀
                        #         # 0o200      所有者可寫
                        #         # 0o100      所有者可執行或搜索
                        #         # 0o40       群組可讀
                        #         # 0o20       群組可寫
                        #         # 0o10       群組可執行或搜索
                        #         # 0o4        其他人可讀
                        #         # 0o2        其他人可寫
                        #         # 0o1        其他人可執行或搜索
                        #         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                        #         # 數字	說明
                        #         # 7	可讀、可寫、可執行
                        #         # 6	可讀、可寫
                        #         # 5	可讀、可執行
                        #         # 4	唯讀
                        #         # 3	可寫、可執行
                        #         # 2	只寫
                        #         # 1	只可執行
                        #         # 0	沒有許可權
                        #         # 例如，八進制值 0o765 表示：
                        #         # 1) 、所有者可以讀取、寫入和執行該文檔；
                        #         # 2) 、群組可以讀和寫入該文檔；
                        #         # 3) 、其他人可以讀取和執行該文檔；
                        #         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                        #         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                        #     catch err
                        #         println("用於輸出傳值的媒介文檔: " * output_file * " 無法修改操作權限爲 mode=0o777 .");
                        #         println(err);
                        #         # println(Base.typeof(err));
                        #         # # global output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                        #         # output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                        #         # return ["error", output_file, "document [ output_file = " * Base.string(output_file) * " ] change the permissions mode=0o777 fail."];
                        #     end
                        # end


                        # # 使用 a = Base.read(`bash -c C:/node.exe C:/Cross/test.js a=5 b=6`, Core.String) 調用 shell 語句反饋，運算處理完之後，給調用語言的回復，然後再獲取返回值;
                        # # 判斷變量 to_executable 已被定義且類型取值合法，Core.isa(to_executable, Core.String) 與 Base.typeof(to_executable) === Core.String 等效;
                        # # local to_executable = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe"));  # String 類型變量，上一層路徑下的Node.JS解釋器可執行檔路徑C:\nodejs\node.exe：Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的解釋器可執行文件 "..\\NodeJS\\node.exe"，Julia 解釋器可執行檔全名 println(Base.Sys.BINDIR)：C:\Julia 1.5.1\bin，;
                        # # local to_executable = Core.nothing;  # 置空;
                        # if Base.@isdefined(to_executable) && to_executable !== Core.nothing && Core.isa(to_executable, Core.String) && to_executable !== ""

                        #     # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否存在;
                        #     if Base.Filesystem.ispath(to_executable) && Base.Filesystem.isfile(to_executable)

                        #         # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
                        #         if Base.stat(to_executable).mode !== Core.UInt64(33206) && Base.stat(to_executable).mode !== Core.UInt64(33279)
                        #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
                        #             println("回調程序二進制可執行檔 [ " * to_executable * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                        #             try
                        #                 # 使用 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false) 函數修改文檔操作權限;
                        #                 # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                        #                 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                        #                 println("回調程序二進制可執行檔: " * to_executable * " 操作權限成功修改爲 mode=0o777 .");

                        #                 # 八進制值    說明
                        #                 # 0o400      所有者可讀
                        #                 # 0o200      所有者可寫
                        #                 # 0o100      所有者可執行或搜索
                        #                 # 0o40       群組可讀
                        #                 # 0o20       群組可寫
                        #                 # 0o10       群組可執行或搜索
                        #                 # 0o4        其他人可讀
                        #                 # 0o2        其他人可寫
                        #                 # 0o1        其他人可執行或搜索
                        #                 # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                        #                 # 數字	說明
                        #                 # 7	可讀、可寫、可執行
                        #                 # 6	可讀、可寫
                        #                 # 5	可讀、可執行
                        #                 # 4	唯讀
                        #                 # 3	可寫、可執行
                        #                 # 2	只寫
                        #                 # 1	只可執行
                        #                 # 0	沒有許可權
                        #                 # 例如，八進制值 0o765 表示：
                        #                 # 1) 、所有者可以讀取、寫入和執行該文檔；
                        #                 # 2) 、群組可以讀和寫入該文檔；
                        #                 # 3) 、其他人可以讀取和執行該文檔；
                        #                 # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                        #                 # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                        #             catch err
                        #                 println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
                        #                 println(err);
                        #                 # println(err.msg);
                        #                 # println(Base.typeof(err));
                        #                 return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
                        #             end
                        #         end

                        #         # 判斷文件夾權限;
                        #         if !(Base.stat(to_executable).mode === Core.UInt64(33206) || Base.stat(to_executable).mode === Core.UInt64(33279))
                        #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
                        #             println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
                        #             return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
                        #         end

                        #         # 判斷變量 to_script 已被定義且類型取值合法，Core.isa(to_script, Core.String) 與 Base.typeof(to_script) === Core.String 等效;
                        #         # local to_script = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js"));  # String 類型變量，上一層路徑下的 JavaScript 脚本路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的被調用的脚本文檔 "../js/Ruuter.js";
                        #         # local to_script = Core.nothing;  # 置空;
                        #         if Base.@isdefined(to_script) && to_script !== Core.nothing && Core.isa(to_script, Core.String) && to_script !== ""
                        #             # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否存在;
                        #             if Base.Filesystem.ispath(to_script) && Base.Filesystem.isfile(to_script)
                        #                 # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
                        #                 if Base.stat(to_script).mode !== Core.UInt64(33206) && Base.stat(to_script).mode !== Core.UInt64(33279)
                        #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
                        #                     println("回調程序二進制可執行檔調用的脚本文檔 [ " * to_script * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                        #                     try
                        #                         # 使用 Base.Filesystem.chmod(to_script, mode=0o777; recursive=false) 函數修改文檔操作權限;
                        #                         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                        #                         Base.Filesystem.chmod(to_script, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                        #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 操作權限成功修改爲 mode=0o777 .");

                        #                         # 八進制值    說明
                        #                         # 0o400      所有者可讀
                        #                         # 0o200      所有者可寫
                        #                         # 0o100      所有者可執行或搜索
                        #                         # 0o40       群組可讀
                        #                         # 0o20       群組可寫
                        #                         # 0o10       群組可執行或搜索
                        #                         # 0o4        其他人可讀
                        #                         # 0o2        其他人可寫
                        #                         # 0o1        其他人可執行或搜索
                        #                         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                        #                         # 數字	說明
                        #                         # 7	可讀、可寫、可執行
                        #                         # 6	可讀、可寫
                        #                         # 5	可讀、可執行
                        #                         # 4	唯讀
                        #                         # 3	可寫、可執行
                        #                         # 2	只寫
                        #                         # 1	只可執行
                        #                         # 0	沒有許可權
                        #                         # 例如，八進制值 0o765 表示：
                        #                         # 1) 、所有者可以讀取、寫入和執行該文檔；
                        #                         # 2) 、群組可以讀和寫入該文檔；
                        #                         # 3) 、其他人可以讀取和執行該文檔；
                        #                         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                        #                         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                        #                     catch err
                        #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
                        #                         println(err);
                        #                         # println(err.msg);
                        #                         # println(Base.typeof(err));
                        #                         return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
                        #                     end
                        #                 end

                        #                 # 判斷文件夾權限;
                        #                 if !(Base.stat(to_script).mode === Core.UInt64(33206) || Base.stat(to_script).mode === Core.UInt64(33279))
                        #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
                        #                     println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
                        #                     return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
                        #                 end
                        #             else
                        #                 println("回調程序二進制可執行檔調用的脚本文檔路徑全名「to_script = " * Base.string(to_script) * "」不能被識別.");
                        #                 return ["error", to_script, "Callback script code document [ to_script = " * Base.string(to_script) * " ] error, no recognition."];
                        #             end

                        #             textCommand = "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
                        #             # Command = `bash -c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                        #             # Command = `cmd /c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                        #             Command = `bash -c $textCommand`;

                        #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
                        #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
                        #             # println(Base.typeof(resultBack));
                        #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
                        #             println(resultBack);
                        #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
                        #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                        #             # for x in Base.split(resultBack, "\n")
                        #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                        #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                        #             # end
                        #             # println(backArray);

                        #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                        #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                        #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                        #             # Base.GC.gc();  # 内存回收函數 gc();

                        #         else
                        #             textCommand = "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
                        #             # Command = `bash -c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                        #             # Command = `cmd /c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                        #             Command = `bash -c $textCommand`;

                        #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
                        #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
                        #             # println(Base.typeof(resultBack));
                        #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
                        #             println(resultBack);
                        #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
                        #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                        #             # for x in Base.split(resultBack, "\n")
                        #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                        #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                        #             # end
                        #             # println(backArray);

                        #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                        #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                        #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                        #             # Base.GC.gc();  # 内存回收函數 gc();
                        #         end
                        #     else
                        #         println("回調程序二進制可執行檔路徑全名「to_executable = " * Base.string(to_executable) * "」不能被識別.");
                        #         return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] error, no recognition."];
                        #     end
                        # end


                        # 打印日志記錄條目;
                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        # # println(Base.string(nowTime));
                        # # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                        # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                        # print(log_text * "\n");
                        # # log_file = "";  # 日志文檔;
                        # # # 同步寫入用於記錄過程的日志文檔;
                        # # try
                        # #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                        # #     # # write(filename::AbstractString, x)
                        # #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                        # #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                        # #     # println(numBytes);
                        # #     # println(Base.stat(log_file).size);
                        # #     # println(Base.stat(log_file).mtime);
                        # #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        # #     # println(Base.stat(log_file).ctime);
                        # #     # # Base.displaysize([io::IO]) -> (lines, columns)
                        # #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                        # #     # # Base.countlines — Function
                        # #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                        # #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                        # #     # println(Base.countlines(log_file, eol='\\n'));

                        # #     fWIO = Base.open(log_file, "a+");
                        # #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                        # #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                        # #     # Keyword	Description				Default
                        # #     # read		open for reading		!write
                        # #     # write		open for writing		truncate | append
                        # #     # create	create if non-existent	!read & write | truncate | append
                        # #     # truncate	truncate to zero size	!read & write
                        # #     # append	seek to end				false

                        # #     # Mode	Description						Keywords
                        # #     # r		read							none
                        # #     # w		write, create, truncate			write = true
                        # #     # a		write, create, append			append = true
                        # #     # r+	read, write						read = true, write = true
                        # #     # w+	read, write, create, truncate	truncate = true, read = true
                        # #     # a+	read, write, create, append		append = true, read = true

                        # #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                        # #     if Base.iswritable(fWIO)
                        # #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                        # #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                        # #         println(numBytes);
                        # #         println(Base.stat(log_file).size);
                        # #         println(Base.stat(log_file).mtime);
                        # #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        # #         println(Base.stat(log_file).ctime);
                        # #         # Base.displaysize([io::IO]) -> (lines, columns)
                        # #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                        # #         # Base.countlines — Function
                        # #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                        # #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                        # #         println(Base.countlines(log_file, eol='\\n'));
                        # #     end

                        # #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                        # #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                        # #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                        # #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                        # #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                        # #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                        # #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                        # #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                        # #     # Base.ismarked(io);  # Return true if stream s is marked;
                        # #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                        # #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                        # #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                        # #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                        # #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                        # #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                        # #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                        # #     # Base.close(io);  # 關閉緩衝區;
                        # #     # println(a)
                        # #     # Base.redirect_stdout — Function
                        # #     # redirect_stdout([stream]) -> (rd, wr)
                        # #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                        # #     # If called with the optional stream argument, then returns stream itself.
                        # #     # Base.redirect_stdout — Method
                        # #     # redirect_stdout(f::Function, stream)
                        # #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                        # #     # Base.redirect_stderr — Function
                        # #     # redirect_stderr([stream]) -> (rd, wr)
                        # #     # Like redirect_stdout, but for stderr.
                        # #     # Base.redirect_stderr — Method
                        # #     # redirect_stderr(f::Function, stream)
                        # #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                        # #     # Base.redirect_stdin — Function
                        # #     # redirect_stdin([stream]) -> (rd, wr)
                        # #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                        # #     # Base.redirect_stdin — Method
                        # #     # redirect_stdin(f::Function, stream)
                        # #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                        # # catch err
                        # #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                        # #     println(err);
                        # #     # println(Base.typeof(err));
                        # #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                        # # finally
                        # #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                        # #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                        # #     if Base.eof(fWIO)
                        # #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                        # #     end
                        # # end
                    else
                        # println("用於輸出傳值的媒介文檔: " * output_file * " 無法創建.");
                        # return ["error", output_file, "document [ output_file = " * Base.string(output_file) * " ] not create."];
                    end
                end

                return ["output_queues_array[1] -> temp_output_file -> output_file", input_queues_array, output_queues_array];
            end
        else
            return ["The output queues array empty.", input_queues_array, output_queues_array];
        end
    end

    if (Base.isa(isMonitorThreadsOrProcesses, Core.String) && isMonitorThreadsOrProcesses !== "Multi-Processes" && isMonitorThreadsOrProcesses !== "Multi-Threading" && Base.parse(Core.Int64, isMonitorThreadsOrProcesses) <= 0) || (Base.typeof(isMonitorThreadsOrProcesses) <: Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} && isMonitorThreadsOrProcesses <= 0)

        while true

            RemoteChannel_Data_Dict = Base.Dict{Core.String, Core.Any}(
                # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                "monitor_file" => monitor_file,
                "monitor_dir" => monitor_dir,
                # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                "output_dir" => output_dir,
                "output_file" => output_file,
                "temp_cache_IO_data_dir" => temp_cache_IO_data_dir,
                "to_executable" => to_executable,
                "to_script" => to_script,
                "input_queues_array" => input_queues_array,
                "output_queues_array" => output_queues_array,
                "worker_queues_Dict" => worker_queues_Dict,
                "total_worker_called_number" => total_worker_called_number,
                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                "label" => "Run",
                "message" => "Run"
            );

            if Base.isopen(rc2to)
                # RemoteChannel_Data_Dict["label"] = "Run";
                RemoteChannel_Data_Dict["message"] = "worker process-2 Function < func_Monitor_file() > be run.";
                Base.put!(rc2to, RemoteChannel_Data_Dict);
            end

            if Base.isready(rc2to)

                to2Dict = Base.take!(rc2to);

                if to2Dict["label"] === "exit"
                    break;
                    # Base.exit(0);
                end

                if to2Dict["label"] === "Run"

                    from2Dict = Base.Dict{Core.String, Core.Any}(
                        # "read_file_do_Function" => read_file_do_Function,  # to2Dict["read_file_do_Function"];
                        "monitor_file" => to2Dict["monitor_file"], # monitor_file,
                        "monitor_dir" => to2Dict["monitor_dir"], # monitor_dir,
                        # "do_Function" => do_Function,  # to2Dict["do_Function"]，do_data ;
                        "output_dir" => to2Dict["output_dir"], # output_dir,
                        "output_file" => to2Dict["output_file"], # output_file,
                        "temp_cache_IO_data_dir" => to2Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                        "to_executable" => to2Dict["to_executable"], # to_executable,
                        "to_script" => to2Dict["to_script"],  # to_script,
                        "input_queues_array" => to2Dict["input_queues_array"],  # input_queues_array,
                        "output_queues_array" => to2Dict["output_queues_array"],  # output_queues_array,
                        "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                        "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                        "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                        "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        "label" => "func_Monitor_file",
                        "message" => "worker process-" * Base.string(Distributed.myid()) * " The monitor_file not exist."
                    );

                    if Base.Filesystem.ispath(to2Dict["monitor_file"]) && Base.Filesystem.isfile(to2Dict["monitor_file"])

                        # result = func_Monitor_file(
                        #     monitor_file,
                        #     # monitor_dir,
                        #     # do_Function,
                        #     # output_dir,
                        #     output_file,
                        #     to_executable,
                        #     to_script,
                        #     temp_cache_IO_data_dir,
                        #     # number_Worker_threads,
                        #     time_sleep,
                        #     input_queues_array
                        # );

                        result = func_Monitor_file(
                            to2Dict["monitor_file"],
                            # to2Dict["monitor_dir"],
                            # do_Function, # to2Dict["do_Function"],
                            # to2Dict["output_dir"],
                            to2Dict["output_file"],
                            to2Dict["to_executable"],
                            to2Dict["to_script"],
                            to2Dict["temp_cache_IO_data_dir"],
                            # number_Worker_threads,
                            time_sleep,
                            to2Dict["input_queues_array"]
                        );

                        if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                            if result[1] !== "The monitor_file path does not exist."
                                if Base.length(result[2]) > 0
                                    input_queues_last = result[2][Base.length(result[2])];
                                    from2Dict["monitor_file"] = input_queues_last["monitor_file"];
                                    from2Dict["monitor_dir"] = input_queues_last["monitor_dir"];
                                    from2Dict["output_file"] = input_queues_last["output_file"];
                                    from2Dict["output_dir"] = input_queues_last["output_dir"];
                                    from2Dict["to_executable"] = input_queues_last["to_executable"];
                                    from2Dict["to_script"] = input_queues_last["to_script"];
                                    from2Dict["input_queues_array"] = result[2];
                                    from2Dict["label"] = "success";  # "func_Monitor_file";
                                    nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    # println(Base.string(nowTime));
                                    log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(monitor_file) * " ] -> [ " * Base.string(input_queues_last["monitor_file"]) * " ].";
                                    from2Dict["message"] = log_text;  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_file() > success.";
                                else
                                    from2Dict["label"] = "error";
                                    from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_file() > return input_queues_array empty.";
                                end
                            else
                                from2Dict["label"] = "empty";
                                from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_file() > return [ The monitor_file path does not exist. ]";
                            end
                        end

                        if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"
                            from2Dict["label"] = "error";
                            from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * Base.string(result[3]);  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_file() > return error, or The monitor_file path does not exist.";
                        end
                    else
                        from2Dict["label"] = "empty";
                        from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the monitor_file path does not exist.";
                    end

                    Base.put!(rc2from, from2Dict);

                    from2Dict = Core.nothing;
                    result = Core.nothing;
                end

                to2Dict = Core.nothing;
            else
                # continue;
                # break;
                # Base.exit(0);
            end

            if Base.isready(rc2from)
                
                from2rcDict = Base.take!(rc2from);

                if from2rcDict["label"] === "error"
                    println(from2rcDict["message"]);
                end

                if from2rcDict["label"] === "success"
                    # 打印日志記錄條目;
                    # println(from2rcDict["message"]);
                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                    # log_text = from2rcDict["time"] * " process-" * from2rcDict["processID"] * " thread-" * from2rcDict["threadID"] * " task-" * from2rcDict["taskID"] * " < " * from2rcDict["monitor_file"] * " > < " * from2rcDict["output_file"] * " >.";
                    # print(log_text * "\n");
                    input_queues_array = from2rcDict["input_queues_array"];
                    RemoteChannel_Data_Dict["input_queues_array"] = input_queues_array;
                    # output_queues_array = from2rcDict["output_queues_array"];
                    # RemoteChannel_Data_Dict["output_queues_array"] = output_queues_array;
                end

                from2rcDict = Core.nothing;
            end

            if Base.isopen(rc3to)
                # RemoteChannel_Data_Dict["label"] = "Run";
                RemoteChannel_Data_Dict["message"] = "worker process-3 Function < func_Monitor_input_queues() > be run.";
                Base.put!(rc3to, RemoteChannel_Data_Dict);
            end

            if Base.isready(rc3to)

                to3Dict = Base.take!(rc3to);

                if to3Dict["label"] === "exit"
                    break;
                    # Base.exit(0);
                end

                if to3Dict["label"] === "Run"

                    from3Dict = Base.Dict{Core.String, Core.Any}(
                        # "read_file_do_Function" => read_file_do_Function,  # to3Dict["read_file_do_Function"];
                        "monitor_file" => to3Dict["monitor_file"], # monitor_file,
                        "monitor_dir" => to3Dict["monitor_dir"], # monitor_dir,
                        # "do_Function" => do_Function,  # to3Dict["do_Function"]，do_data ;
                        "output_dir" => to3Dict["output_dir"], # output_dir,
                        "output_file" => to3Dict["output_file"], # output_file,
                        "temp_cache_IO_data_dir" => to3Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                        "to_executable" => to3Dict["to_executable"], # to_executable,
                        "to_script" => to3Dict["to_script"],  # to_script,
                        "input_queues_array" => to3Dict["input_queues_array"],  # input_queues_array,
                        "output_queues_array" => to3Dict["output_queues_array"],  # output_queues_array,
                        "worker_queues_Dict" => to3Dict["worker_queues_Dict"],
                        "total_worker_called_number" => to3Dict["total_worker_called_number"],
                        "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                        "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                        "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                        "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        "label" => "func_Monitor_input_queues",
                        "message" => "worker process-" * Base.string(Distributed.myid()) * " The input_queues_array empty."
                    );

                    result = func_Monitor_input_queues(
                        # to3Dict["monitor_file"], # monitor_file,
                        # to3Dict["monitor_dir"], # monitor_dir,
                        do_Function, # to3Dict["do_Function"],
                        # to3Dict["output_dir"], # output_dir,
                        # to3Dict["output_file"], # output_file,
                        # to3Dict["to_executable"], # to_executable,
                        # to3Dict["to_script"], # to_script,
                        # to3Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                        number_Worker_threads,
                        time_sleep,
                        read_file_do_Function, # to3Dict["read_file_do_Function"],
                        isDoTasksOrThreads,
                        funcTask,  # to3Dict["funcTask"],
                        main_to_sub_channel,
                        sub_to_main_channel,
                        control_number_Queues_channel,
                        to3Dict["input_queues_array"],  # input_queues_array,
                        to3Dict["output_queues_array"],  # output_queues_array,
                        to3Dict["worker_queues_Dict"],  # worker_queues_Dict,
                        to3Dict["total_worker_called_number"]  # total_worker_called_number
                    );

                    if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                        if result[1] !== "The input queues array empty."
                            if Base.length(result[3]) > 0
                                output_queues_last = result[3][Base.length(result[3])];
                                from3Dict["monitor_file"] = output_queues_last["monitor_file"];
                                from3Dict["monitor_dir"] = output_queues_last["monitor_dir"];
                                from3Dict["output_file"] = output_queues_last["output_file"];
                                from3Dict["output_dir"] = output_queues_last["output_dir"];
                                from3Dict["to_executable"] = output_queues_last["to_executable"];
                                from3Dict["to_script"] = output_queues_last["to_script"];
                                from3Dict["input_queues_array"] = result[2];
                                from3Dict["output_queues_array"] = result[3];
                                from3Dict["label"] = "success";  # "func_Monitor_input_queues";
                                # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                # println(Base.string(nowTime));
                                # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_last["monitor_file"]) * " ] -> [ " * Base.string(output_queues_last["output_file"]) * " ].";
                                log_text = Base.string(output_queues_last["time"]) * " process-" * Base.string(output_queues_last["processID"]) * " thread-" * Base.string(output_queues_last["threadID"]) * " task-" * Base.string(output_queues_last["taskID"]) * " [ " * Base.string(output_queues_last["monitor_file"]) * " ] -> [ " * Base.string(output_queues_last["output_file"]) * " ].";
                                from3Dict["message"] = log_text;  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_input_queues() > success.";
                            else
                                from3Dict["label"] = "error";
                                from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_input_queues() > return output_queues_array empty.";
                            end
                        else
                            from3Dict["label"] = "empty";
                            from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_input_queues() > return [ The input queues array empty. ]";
                        end
                    end

                    if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"
                        from3Dict["label"] = "error";
                        from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * Base.string(result[3]);  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_input_queues() > return error, or The input queues array empty.";
                    end

                    Base.put!(rc3from, from3Dict);

                    from3Dict = Core.nothing;
                    result = Core.nothing;
                end

                to3Dict = Core.nothing;
            else
                # continue;
                # break;
                # Base.exit(0);
            end

            if Base.isready(rc3from)

                from3rcDict = Base.take!(rc3from);

                if from3rcDict["label"] === "error"
                    println(from3rcDict["message"]);
                end

                if from3rcDict["label"] === "success"
                    # 打印日志記錄條目;
                    # println(from3rcDict["message"]);
                    log_text = Base.string(from3rcDict["time"]) * " process-" * Base.string(from3rcDict["processID"]) * " thread-" * Base.string(from3rcDict["threadID"]) * " task-" * Base.string(from3rcDict["taskID"]) * " [ " * Base.string(from3rcDict["output_queues_array"][Base.length(from3rcDict["output_queues_array"])]["monitor_file"]) * " ] -> [ " * Base.string(output_file) * " ].";
                    println(log_text);
                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                    # log_text = from3rcDict["time"] * " process-" * from3rcDict["processID"] * " thread-" * from3rcDict["threadID"] * " task-" * from3rcDict["taskID"] * " < " * from3rcDict["monitor_file"] * " > < " * from3rcDict["output_file"] * " >.";
                    # print(log_text * "\n");
                    input_queues_array = from3rcDict["input_queues_array"];
                    RemoteChannel_Data_Dict["input_queues_array"] = input_queues_array;
                    output_queues_array = from3rcDict["output_queues_array"];
                    RemoteChannel_Data_Dict["output_queues_array"] = output_queues_array;
                    worker_queues_Dict = from3rcDict["worker_queues_Dict"];
                    RemoteChannel_Data_Dict["worker_queues_Dict"] = worker_queues_Dict;
                    total_worker_called_number = from3rcDict["total_worker_called_number"];
                    RemoteChannel_Data_Dict["total_worker_called_number"] = total_worker_called_number;                    
                end

                from3rcDict = Core.nothing;
            end

            if Base.isopen(rc4to)
                # RemoteChannel_Data_Dict["label"] = "Run";
                RemoteChannel_Data_Dict["message"] = "worker process-4 Function < func_Monitor_output_queues() > be run.";
                Base.put!(rc4to, RemoteChannel_Data_Dict);
            end

            if Base.isready(rc4to)

                to4Dict = Base.take!(rc4to);

                if to4Dict["label"] === "exit"
                    break;
                    # Base.exit(0);
                end

                if to4Dict["label"] === "Run"

                    if Base.isa(to4Dict, Base.Dict) && Base.haskey(to4Dict, "output_queues_array") && Base.typeof(to4Dict["output_queues_array"]) <: Core.Array && Base.length(to4Dict["output_queues_array"]) > 0 && Base.isa(to4Dict["output_queues_array"][1], Base.Dict) && Base.haskey(to4Dict["output_queues_array"][1], "output_file") && Base.isa(to4Dict["output_queues_array"][1]["output_file"], Core.String) && to4Dict["output_queues_array"][1]["output_file"] !== ""
                        tempOutputFile = to4Dict["output_queues_array"][1]["output_file"];
                    else
                        tempOutputFile = "";
                    end

                    from4Dict = Base.Dict{Core.String, Core.Any}(
                        # "read_file_do_Function" => read_file_do_Function,  # to4Dict["read_file_do_Function"];
                        "monitor_file" => to4Dict["monitor_file"], # monitor_file,
                        "monitor_dir" => to4Dict["monitor_dir"], # monitor_dir,
                        # "do_Function" => do_Function,  # to4Dict["do_Function"]，do_data ;
                        "output_dir" => to4Dict["output_dir"], # output_dir,
                        "output_file" => to4Dict["output_file"], # output_file,
                        "temp_cache_IO_data_dir" => to4Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                        "to_executable" => to4Dict["to_executable"], # to_executable,
                        "to_script" => to4Dict["to_script"],  # to_script,
                        "input_queues_array" => to4Dict["input_queues_array"],  # input_queues_array,
                        "output_queues_array" => to4Dict["output_queues_array"],  # output_queues_array,
                        "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                        "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                        "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                        "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        "label" => "func_Monitor_output_queues",
                        "message" => "worker process-" * Base.string(Distributed.myid()) * " The output queues array empty."
                    );

                    
                    if Base.typeof(to4Dict["output_queues_array"]) <: Core.Array && Base.length(to4Dict["output_queues_array"]) > 0
                        if Base.typeof(to4Dict["input_queues_array"]) <: Core.Array

                            result = func_Monitor_output_queues(
                                # to4Dict["monitor_file"],  # monitor_file,
                                # to4Dict["monitor_dir"],  # monitor_dir,
                                # do_Function,  # to4Dict["do_Function"],
                                # to4Dict["output_dir"],  # output_dir,
                                to4Dict["output_file"],  # output_file,
                                # to4Dict["to_executable"],  # to_executable,
                                # to4Dict["to_script"],  # to_script,
                                # to4Dict["temp_cache_IO_data_dir"],  # temp_cache_IO_data_dir,
                                # number_Worker_threads,
                                # time_sleep,
                                to4Dict["input_queues_array"],  # input_queues_array,
                                to4Dict["output_queues_array"]  # output_queues_array
                            );

                            if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                                if result[1] === "The output queues array empty."
                                    from4Dict["label"] = "empty";
                                    from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_output_queues() > return [ " * Base.string(result[1]) * " ]";
                                elseif result[1] === "The output_file already exists."
                                    from4Dict["label"] = "output_file_exists";
                                    from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_output_queues() > return [ " * Base.string(result[1]) * " ]";
                                elseif result[1] === "output_queues_array[1] -> temp_output_file -> output_file"
                                    from4Dict["monitor_file"] = monitor_file;
                                    from4Dict["monitor_dir"] = monitor_dir;
                                    from4Dict["output_file"] = output_file;
                                    from4Dict["output_dir"] = output_dir;
                                    from4Dict["to_executable"] = to_executable;
                                    from4Dict["to_script"] = to_script;
                                    from4Dict["input_queues_array"] = result[2];
                                    from4Dict["output_queues_array"] = result[3];
                                    from4Dict["label"] = "success";  # "func_Monitor_output_queues";
                                    nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    # println(Base.string(nowTime));
                                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(to4Dict["output_queues_array"][Base.length(to4Dict["output_queues_array"])]["output_file"]) * " ] -> [ " * Base.string(output_file) * " ].";
                                    log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(tempOutputFile) * " ] -> [ " * Base.string(output_file) * " ].";
                                    from4Dict["message"] = log_text;  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_output_queues() > success.";
                                else
                                    from4Dict["input_queues_array"] = result[2];
                                    from4Dict["output_queues_array"] = result[3];
                                    from4Dict["label"] = "error";
                                    from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_output_queues() > return [ " * Base.string(result[1]) * " ]";
                                end
                            end

                            if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"
                                from4Dict["label"] = "error";
                                from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * Base.string(result[3]);  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_output_queues() > return error, or The output queues array empty.";
                            end
                        else
                            from4Dict["label"] = "error";
                            from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the input_queues_array not Core.Array, Base.typeof(input_queues_array) <: Core.Array is false.";
                        end
                    else
                        from4Dict["label"] = "empty";
                        from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the output_queues_array empty.";
                    end

                    Base.put!(rc4from, from4Dict);

                    from4Dict = Core.nothing;
                    result = Core.nothing;
                end

                to4Dict = Core.nothing;
            else
                # continue;
                # break;
                # Base.exit(0);
            end

            if Base.isready(rc4from)

                from4rcDict = Base.take!(rc4from);

                if from4rcDict["label"] === "error"
                    println(from4rcDict["message"]);
                end

                if from4rcDict["label"] === "success"
                    # 打印日志記錄條目;
                    # println(from4rcDict["message"]);
                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                    # log_text = from4rcDict["time"] * " process-" * from4rcDict["processID"] * " thread-" * from4rcDict["threadID"] * " task-" * from4rcDict["taskID"] * " [ " * from4rcDict["monitor_file"] * " ] -> [ " * from4rcDict["output_file"] * " ].";
                    # print(log_text * "\n");
                    # input_queues_array = from4rcDict["input_queues_array"];
                    # RemoteChannel_Data_Dict["input_queues_array"] = input_queues_array;
                    output_queues_array = from4rcDict["output_queues_array"];
                    RemoteChannel_Data_Dict["output_queues_array"] = output_queues_array;
                end

                from4rcDict = Core.nothing;
            end

            RemoteChannel_Data_Dict = Core.nothing;

            begin
                # # 使用 a = Base.read(`bash -c C:/node.exe C:/Cross/test.js a=5 b=6`, Core.String) 調用 shell 語句反饋，運算處理完之後，給調用語言的回復，然後再獲取返回值;
                # # 判斷變量 to_executable 已被定義且類型取值合法，Core.isa(to_executable, Core.String) 與 Base.typeof(to_executable) === Core.String 等效;
                # # local to_executable = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe"));  # String 類型變量，上一層路徑下的Node.JS解釋器可執行檔路徑C:\nodejs\node.exe：Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的解釋器可執行文件 "..\\NodeJS\\node.exe"，Julia 解釋器可執行檔全名 println(Base.Sys.BINDIR)：C:\Julia 1.5.1\bin，;
                # # local to_executable = Core.nothing;  # 置空;
                # if Base.@isdefined(to_executable) && to_executable !== Core.nothing && Core.isa(to_executable, Core.String) && to_executable !== ""

                #     # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否存在;
                #     if Base.Filesystem.ispath(to_executable) && Base.Filesystem.isfile(to_executable)

                #         # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
                #         if Base.stat(to_executable).mode !== Core.UInt64(33206) && Base.stat(to_executable).mode !== Core.UInt64(33279)
                #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
                #             println("回調程序二進制可執行檔 [ " * to_executable * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                #             try
                #                 # 使用 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false) 函數修改文檔操作權限;
                #                 # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                #                 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                #                 println("回調程序二進制可執行檔: " * to_executable * " 操作權限成功修改爲 mode=0o777 .");

                #                 # 八進制值    說明
                #                 # 0o400      所有者可讀
                #                 # 0o200      所有者可寫
                #                 # 0o100      所有者可執行或搜索
                #                 # 0o40       群組可讀
                #                 # 0o20       群組可寫
                #                 # 0o10       群組可執行或搜索
                #                 # 0o4        其他人可讀
                #                 # 0o2        其他人可寫
                #                 # 0o1        其他人可執行或搜索
                #                 # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                #                 # 數字	說明
                #                 # 7	可讀、可寫、可執行
                #                 # 6	可讀、可寫
                #                 # 5	可讀、可執行
                #                 # 4	唯讀
                #                 # 3	可寫、可執行
                #                 # 2	只寫
                #                 # 1	只可執行
                #                 # 0	沒有許可權
                #                 # 例如，八進制值 0o765 表示：
                #                 # 1) 、所有者可以讀取、寫入和執行該文檔；
                #                 # 2) 、群組可以讀和寫入該文檔；
                #                 # 3) 、其他人可以讀取和執行該文檔；
                #                 # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                #                 # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                #             catch err
                #                 println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
                #                 println(err);
                #                 # println(err.msg);
                #                 # println(Base.typeof(err));
                #                 return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
                #             end
                #         end

                #         # 判斷文件夾權限;
                #         if !(Base.stat(to_executable).mode === Core.UInt64(33206) || Base.stat(to_executable).mode === Core.UInt64(33279))
                #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
                #             println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
                #             return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
                #         end

                #         # 判斷變量 to_script 已被定義且類型取值合法，Core.isa(to_script, Core.String) 與 Base.typeof(to_script) === Core.String 等效;
                #         # local to_script = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js"));  # String 類型變量，上一層路徑下的 JavaScript 脚本路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的被調用的脚本文檔 "../js/Ruuter.js";
                #         # local to_script = Core.nothing;  # 置空;
                #         if Base.@isdefined(to_script) && to_script !== Core.nothing && Core.isa(to_script, Core.String) && to_script !== ""
                #             # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否存在;
                #             if Base.Filesystem.ispath(to_script) && Base.Filesystem.isfile(to_script)
                #                 # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
                #                 if Base.stat(to_script).mode !== Core.UInt64(33206) && Base.stat(to_script).mode !== Core.UInt64(33279)
                #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
                #                     println("回調程序二進制可執行檔調用的脚本文檔 [ " * to_script * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                #                     try
                #                         # 使用 Base.Filesystem.chmod(to_script, mode=0o777; recursive=false) 函數修改文檔操作權限;
                #                         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                #                         Base.Filesystem.chmod(to_script, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 操作權限成功修改爲 mode=0o777 .");

                #                         # 八進制值    說明
                #                         # 0o400      所有者可讀
                #                         # 0o200      所有者可寫
                #                         # 0o100      所有者可執行或搜索
                #                         # 0o40       群組可讀
                #                         # 0o20       群組可寫
                #                         # 0o10       群組可執行或搜索
                #                         # 0o4        其他人可讀
                #                         # 0o2        其他人可寫
                #                         # 0o1        其他人可執行或搜索
                #                         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                #                         # 數字	說明
                #                         # 7	可讀、可寫、可執行
                #                         # 6	可讀、可寫
                #                         # 5	可讀、可執行
                #                         # 4	唯讀
                #                         # 3	可寫、可執行
                #                         # 2	只寫
                #                         # 1	只可執行
                #                         # 0	沒有許可權
                #                         # 例如，八進制值 0o765 表示：
                #                         # 1) 、所有者可以讀取、寫入和執行該文檔；
                #                         # 2) 、群組可以讀和寫入該文檔；
                #                         # 3) 、其他人可以讀取和執行該文檔；
                #                         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                #                         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                #                     catch err
                #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
                #                         println(err);
                #                         # println(err.msg);
                #                         # println(Base.typeof(err));
                #                         return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
                #                     end
                #                 end

                #                 # 判斷文件夾權限;
                #                 if !(Base.stat(to_script).mode === Core.UInt64(33206) || Base.stat(to_script).mode === Core.UInt64(33279))
                #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
                #                     println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
                #                     return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
                #                 end
                #             else
                #                 println("回調程序二進制可執行檔調用的脚本文檔路徑全名「to_script = " * Base.string(to_script) * "」不能被識別.");
                #                 return ["error", to_script, "Callback script code document [ to_script = " * Base.string(to_script) * " ] error, no recognition."];
                #             end

                #             textCommand = "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
                #             # Command = `bash -c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             # Command = `cmd /c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             Command = `bash -c $textCommand`;

                #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
                #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
                #             # println(Base.typeof(resultBack));
                #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
                #             println(resultBack);
                #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
                #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                #             # for x in Base.split(resultBack, "\n")
                #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                #             # end
                #             # println(backArray);

                #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             # Base.GC.gc();  # 内存回收函數 gc();

                #         else
                #             textCommand = "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
                #             # Command = `bash -c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             # Command = `cmd /c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             Command = `bash -c $textCommand`;

                #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
                #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
                #             # println(Base.typeof(resultBack));
                #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
                #             println(resultBack);
                #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
                #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                #             # for x in Base.split(resultBack, "\n")
                #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                #             # end
                #             # println(backArray);

                #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             # Base.GC.gc();  # 内存回收函數 gc();
                #         end
                #     else
                #         println("回調程序二進制可執行檔路徑全名「to_executable = " * Base.string(to_executable) * "」不能被識別.");
                #         return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] error, no recognition."];
                #     end
                # end

                # 打印日志記錄條目;
                # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # # println(Base.string(nowTime));
                # # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                # print(log_text * "\n");
                # # log_file = "";  # 日志文檔;
                # # # 同步寫入用於記錄過程的日志文檔;
                # # try
                # #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                # #     # # write(filename::AbstractString, x)
                # #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                # #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                # #     # println(numBytes);
                # #     # println(Base.stat(log_file).size);
                # #     # println(Base.stat(log_file).mtime);
                # #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # #     # println(Base.stat(log_file).ctime);
                # #     # # Base.displaysize([io::IO]) -> (lines, columns)
                # #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                # #     # # Base.countlines — Function
                # #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                # #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                # #     # println(Base.countlines(log_file, eol='\\n'));

                # #     fWIO = Base.open(log_file, "a+");
                # #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                # #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                # #     # Keyword	Description				Default
                # #     # read		open for reading		!write
                # #     # write		open for writing		truncate | append
                # #     # create	create if non-existent	!read & write | truncate | append
                # #     # truncate	truncate to zero size	!read & write
                # #     # append	seek to end				false

                # #     # Mode	Description						Keywords
                # #     # r		read							none
                # #     # w		write, create, truncate			write = true
                # #     # a		write, create, append			append = true
                # #     # r+	read, write						read = true, write = true
                # #     # w+	read, write, create, truncate	truncate = true, read = true
                # #     # a+	read, write, create, append		append = true, read = true

                # #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                # #     if Base.iswritable(fWIO)
                # #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                # #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                # #         println(numBytes);
                # #         println(Base.stat(log_file).size);
                # #         println(Base.stat(log_file).mtime);
                # #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # #         println(Base.stat(log_file).ctime);
                # #         # Base.displaysize([io::IO]) -> (lines, columns)
                # #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                # #         # Base.countlines — Function
                # #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                # #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                # #         println(Base.countlines(log_file, eol='\\n'));
                # #     end

                # #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                # #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                # #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                # #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                # #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                # #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                # #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                # #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                # #     # Base.ismarked(io);  # Return true if stream s is marked;
                # #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                # #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                # #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                # #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                # #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                # #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                # #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                # #     # Base.close(io);  # 關閉緩衝區;
                # #     # println(a)
                # #     # Base.redirect_stdout — Function
                # #     # redirect_stdout([stream]) -> (rd, wr)
                # #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                # #     # If called with the optional stream argument, then returns stream itself.
                # #     # Base.redirect_stdout — Method
                # #     # redirect_stdout(f::Function, stream)
                # #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                # #     # Base.redirect_stderr — Function
                # #     # redirect_stderr([stream]) -> (rd, wr)
                # #     # Like redirect_stdout, but for stderr.
                # #     # Base.redirect_stderr — Method
                # #     # redirect_stderr(f::Function, stream)
                # #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                # #     # Base.redirect_stdin — Function
                # #     # redirect_stdin([stream]) -> (rd, wr)
                # #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                # #     # Base.redirect_stdin — Method
                # #     # redirect_stdin(f::Function, stream)
                # #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                # # catch err
                # #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                # #     println(err);
                # #     # println(Base.typeof(err));
                # #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                # # finally
                # #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                # #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                # #     if Base.eof(fWIO)
                # #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                # #     end
                # # end
            end

            Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
        end
    end

    if isMonitorThreadsOrProcesses === "Multi-Threading"

        # 必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
        # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
        # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
        # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
        # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;

        # Base.Threads.@spawn expr
        # Create and run a Task on any available thread. To wait for the task to finish, call wait on the result of this macro, or call fetch to wait and then obtain its return value.
        # 使用 Base.Threads.@spawn 方法創建一個子綫程，運行輪詢 func_Monitor_file 函數;
        wt2 = Base.Threads.@spawn begin

            # function func_Exit()

            #     from2Dict = Base.Dict{Core.String, Core.Any}(
            #         # # "read_file_do_Function" => read_file_do_Function,  # to2Dict["read_file_do_Function"];
            #         # "monitor_file" => to2Dict["monitor_file"], # monitor_file,
            #         # "monitor_dir" => to2Dict["monitor_dir"], # monitor_dir,
            #         # # "do_Function" => do_Function,  # to2Dict["do_Function"]，do_data ;
            #         # "output_dir" => to2Dict["output_dir"], # output_dir,
            #         # "output_file" => to2Dict["output_file"], # output_file,
            #         # "temp_cache_IO_data_dir" => to2Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
            #         # "to_executable" => to2Dict["to_executable"], # to_executable,
            #         # "to_script" => to2Dict["to_script"],  # to_script,
            #         # "input_queues_array" => to2Dict["input_queues_array"],  # input_queues_array,
            #         # "output_queues_array" => to2Dict["output_queues_array"],  # output_queues_array,
            #         "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
            #         "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
            #         "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
            #         "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            #         "label" => "exit",
            #         "message" => "Function < func_Monitor_file() > worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " being exit."
            #     );

            #     Base.put!(rc2from, from2Dict);

            #     Base.close(rc2from);
            # end
            # Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

            while true

                if Base.isready(rc2to)

                    to2Dict = Base.take!(rc2to);

                    from2Dict = Base.Dict{Core.String, Core.Any}(
                        # "read_file_do_Function" => read_file_do_Function,  # to2Dict["read_file_do_Function"];
                        "monitor_file" => to2Dict["monitor_file"], # monitor_file,
                        "monitor_dir" => to2Dict["monitor_dir"], # monitor_dir,
                        # "do_Function" => do_Function,  # to2Dict["do_Function"]，do_data ;
                        "output_dir" => to2Dict["output_dir"], # output_dir,
                        "output_file" => to2Dict["output_file"], # output_file,
                        "temp_cache_IO_data_dir" => to2Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                        "to_executable" => to2Dict["to_executable"], # to_executable,
                        "to_script" => to2Dict["to_script"],  # to_script,
                        "input_queues_array" => to2Dict["input_queues_array"],  # input_queues_array,
                        "output_queues_array" => to2Dict["output_queues_array"],  # output_queues_array,
                        "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                        "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                        "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                        "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        "label" => "func_Monitor_file",
                        "message" => "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task()))
                    );

                    if to2Dict["label"] === "exit"
                        from2Dict["label"] = "exit";
                        from2Dict["message"] = "Function < func_Monitor_file() > worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " being exit.";
                        Base.put!(rc2from, from2Dict);
                        Base.close(rc2from);

                        # continue;
                        break;
                        # Base.exit(0);
                    end

                    if to2Dict["label"] === "Run"

                        if Base.Filesystem.ispath(to2Dict["monitor_file"]) && Base.Filesystem.isfile(to2Dict["monitor_file"])
                            
                            # result = func_Monitor_file(
                            #     monitor_file,
                            #     # monitor_dir,
                            #     # do_Function,
                            #     # output_dir,
                            #     output_file,
                            #     to_executable,
                            #     to_script,
                            #     temp_cache_IO_data_dir,
                            #     # number_Worker_threads,
                            #     time_sleep,
                            #     input_queues_array
                            # );

                            result = func_Monitor_file(
                                to2Dict["monitor_file"],
                                # to2Dict["monitor_dir"],
                                # do_Function, # to2Dict["do_Function"],
                                # to2Dict["output_dir"],
                                to2Dict["output_file"],
                                to2Dict["to_executable"],
                                to2Dict["to_script"],
                                to2Dict["temp_cache_IO_data_dir"],
                                # number_Worker_threads,
                                time_sleep,
                                to2Dict["input_queues_array"]
                            );

                            if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                                if result[1] !== "The monitor_file path does not exist."
                                    if Base.length(result[2]) > 0
                                        input_queues_last = result[2][Base.length(result[2])];
                                        from2Dict["monitor_file"] = input_queues_last["monitor_file"];
                                        from2Dict["monitor_dir"] = input_queues_last["monitor_dir"];
                                        from2Dict["output_file"] = input_queues_last["output_file"];
                                        from2Dict["output_dir"] = input_queues_last["output_dir"];
                                        from2Dict["to_executable"] = input_queues_last["to_executable"];
                                        from2Dict["to_script"] = input_queues_last["to_script"];
                                        from2Dict["input_queues_array"] = result[2];
                                        from2Dict["label"] = "success";  # "func_Monitor_file";
                                        nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        # println(Base.string(nowTime));
                                        log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(monitor_file) * " ] -> [ " * Base.string(input_queues_last["monitor_file"]) * " ].";
                                        from2Dict["message"] = log_text;  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_file() > success.";
                                    else
                                        from2Dict["label"] = "error";
                                        from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_file() > return input_queues_array empty.";
                                    end
                                else
                                    from2Dict["label"] = "empty";
                                    from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_file() > return [ The monitor_file path does not exist. ]";
                                end
                            end

                            if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"
                                from2Dict["label"] = "error";
                                from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * Base.string(result[3]);  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_file() > return error, or The monitor_file path does not exist.";
                            end
                        else
                            from2Dict["label"] = "empty";
                            from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the monitor_file path does not exist.";
                        end

                        Base.put!(rc2from, from2Dict);

                        result = Core.nothing;
                    end

                    from2Dict = Core.nothing;
                    to2Dict = Core.nothing;
                else
                    # continue;
                    # break;
                    # Base.exit(0);
                end

                Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
            end
        end
        # r2 = Base.fetch(wt2);

        # 使用 Base.Threads.@spawn 方法創建一個子綫程，運行輪詢 func_Monitor_input_queues 函數;
        wt3 = Base.Threads.@spawn begin

            # function func_Exit()

            #     from3Dict = Base.Dict{Core.String, Core.Any}(
            #         # # "read_file_do_Function" => read_file_do_Function,  # to3Dict["read_file_do_Function"];
            #         # "monitor_file" => to3Dict["monitor_file"], # monitor_file,
            #         # "monitor_dir" => to3Dict["monitor_dir"], # monitor_dir,
            #         # # "do_Function" => do_Function,  # to3Dict["do_Function"]，do_data ;
            #         # "output_dir" => to3Dict["output_dir"], # output_dir,
            #         # "output_file" => to3Dict["output_file"], # output_file,
            #         # "temp_cache_IO_data_dir" => to3Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
            #         # "to_executable" => to3Dict["to_executable"], # to_executable,
            #         # "to_script" => to3Dict["to_script"],  # to_script,
            #         # "input_queues_array" => to3Dict["input_queues_array"],  # input_queues_array,
            #         # "output_queues_array" => to3Dict["output_queues_array"],  # output_queues_array,
            #         "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
            #         "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
            #         "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
            #         "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            #         "label" => "exit",
            #         "message" => "Function < func_Monitor_input_queues() > worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " being exit."
            #     );

            #     Base.put!(rc3from, from3Dict);

            #     Base.close(rc3from);
            # end
            # Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

            while true

                if Base.isready(rc3to)

                    to3Dict = Base.take!(rc3to);
                    
                    from3Dict = Base.Dict{Core.String, Core.Any}(
                        # "read_file_do_Function" => to3Dict["read_file_do_Function"], # read_file_do_Function,
                        "monitor_file" => to3Dict["monitor_file"], # monitor_file,
                        "monitor_dir" => to3Dict["monitor_dir"], # monitor_dir,
                        # "do_Function" => to3Dict["do_Function"], # do_Function, # do_data ;
                        "output_dir" => to3Dict["output_dir"], # output_dir,
                        "output_file" => to3Dict["output_file"], # output_file,
                        "temp_cache_IO_data_dir" => to3Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                        "to_executable" => to3Dict["to_executable"], # to_executable,
                        "to_script" => to3Dict["to_script"],  # to_script,
                        "input_queues_array" => to3Dict["input_queues_array"],  # input_queues_array,
                        "output_queues_array" => to3Dict["output_queues_array"],  # output_queues_array,
                        "worker_queues_Dict" => to3Dict["worker_queues_Dict"],
                        "total_worker_called_number" => to3Dict["total_worker_called_number"],
                        "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                        "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                        "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                        "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        "label" => "func_Monitor_input_queues",
                        "message" => "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task()))
                    );

                    if to3Dict["label"] === "exit"
                        from3Dict["label"] = "exit";
                        from3Dict["message"] = "Function < func_Monitor_input_queues() > worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " being exit.";
                        Base.put!(rc3from, from3Dict);
                        Base.close(rc3from);

                        # continue;
                        break;
                        # Base.exit(0);
                    end

                    if to3Dict["label"] === "Run"

                        if Base.typeof(to3Dict["input_queues_array"]) <: Core.Array && Base.length(to3Dict["input_queues_array"]) > 0
                            if Base.typeof(to3Dict["output_queues_array"]) <: Core.Array

                                # result = func_Monitor_input_queues(
                                #     # monitor_file,
                                #     # monitor_dir,
                                #     do_Function,
                                #     # output_dir,
                                #     # output_file,
                                #     # to_executable,
                                #     # to_script,
                                #     # temp_cache_IO_data_dir,
                                #     number_Worker_threads,
                                #     time_sleep,
                                #     read_file_do_Function,
                                #     isDoTasksOrThreads,
                                #     funcTask,
                                #     main_to_sub_channel,
                                #     sub_to_main_channel,
                                #     control_number_Queues_channel,
                                #     input_queues_array,
                                #     output_queues_array,
                                #     worker_queues_Dict,
                                #     total_worker_called_number
                                # );

                                result = func_Monitor_input_queues(
                                    # to3Dict["monitor_file"], # monitor_file,
                                    # to3Dict["monitor_dir"], # monitor_dir,
                                    do_Function, # to3Dict["do_Function"],
                                    # to3Dict["output_dir"], # output_dir,
                                    # to3Dict["output_file"], # output_file,
                                    # to3Dict["to_executable"], # to_executable,
                                    # to3Dict["to_script"], # to_script,
                                    # to3Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                                    number_Worker_threads,
                                    time_sleep,
                                    read_file_do_Function, # to3Dict["read_file_do_Function"],
                                    isDoTasksOrThreads,
                                    funcTask, # to3Dict["funcTask"],
                                    main_to_sub_channel,
                                    sub_to_main_channel,
                                    control_number_Queues_channel,
                                    to3Dict["input_queues_array"], # input_queues_array,
                                    to3Dict["output_queues_array"], # output_queues_array,
                                    to3Dict["worker_queues_Dict"],  # worker_queues_Dict,
                                    to3Dict["total_worker_called_number"],  # total_worker_called_number
                                );

                                if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                                    if result[1] === "The input queues array empty."
                                        from3Dict["label"] = "empty";
                                        from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_input_queues() > return [ The input queues array empty. ]";
                                    else
                                        if Base.length(result[3]) > 0
                                            output_queues_last = result[3][Base.length(result[3])];
                                            from3Dict["monitor_file"] = output_queues_last["monitor_file"];
                                            from3Dict["monitor_dir"] = output_queues_last["monitor_dir"];
                                            from3Dict["output_file"] = output_queues_last["output_file"];
                                            from3Dict["output_dir"] = output_queues_last["output_dir"];
                                            from3Dict["to_executable"] = output_queues_last["to_executable"];
                                            from3Dict["to_script"] = output_queues_last["to_script"];
                                            from3Dict["input_queues_array"] = result[2];
                                            from3Dict["output_queues_array"] = result[3];
                                            from3Dict["label"] = "success";  # "func_Monitor_input_queues";
                                            # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                            # println(Base.string(nowTime));
                                            # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_last["monitor_file"]) * " ] -> [ " * Base.string(output_queues_last["output_file"]) * " ].";
                                            log_text = Base.string(output_queues_last["time"]) * " process-" * Base.string(output_queues_last["processID"]) * " thread-" * Base.string(output_queues_last["threadID"]) * " task-" * Base.string(output_queues_last["taskID"]) * " [ " * Base.string(output_queues_last["monitor_file"]) * " ] -> [ " * Base.string(output_queues_last["output_file"]) * " ].";
                                            from3Dict["message"] = log_text;  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_input_queues() > success.";
                                        else
                                            from3Dict["label"] = "error";
                                            from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_input_queues() > return output_queues_array empty.";
                                        end
                                    end
                                end

                                if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"
                                    from3Dict["label"] = "error";
                                    from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * Base.string(result[3]);  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_input_queues() > return error, or The input queues array empty.";
                                end
                            else
                                from3Dict["label"] = "error";
                                from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the output_queues_array not Core.Array, Base.typeof(output_queues_array) <: Core.Array is false.";
                            end
                        else
                            from3Dict["label"] = "empty";
                            from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the input_queues_array empty.";
                        end

                        Base.put!(rc3from, from3Dict);

                        result = Core.nothing;
                    end

                    from3Dict = Core.nothing;
                    to3Dict = Core.nothing;
                else
                    # continue;
                    # break;
                    # Base.exit(0);
                end

                Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
            end
        end
        # r3 = Base.fetch(wt3);

        # 使用 Base.Threads.@spawn 方法創建一個子綫程，運行輪詢 func_Monitor_output_queues 函數;
        wt4 = Base.Threads.@spawn begin

            # function func_Exit()

            #     from4Dict = Base.Dict{Core.String, Core.Any}(
            #         # # "read_file_do_Function" => read_file_do_Function,  # to4Dict["read_file_do_Function"];
            #         # "monitor_file" => to4Dict["monitor_file"], # monitor_file,
            #         # "monitor_dir" => to4Dict["monitor_dir"], # monitor_dir,
            #         # # "do_Function" => do_Function,  # to4Dict["do_Function"]，do_data ;
            #         # "output_dir" => to4Dict["output_dir"], # output_dir,
            #         # "output_file" => to4Dict["output_file"], # output_file,
            #         # "temp_cache_IO_data_dir" => to4Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
            #         # "to_executable" => to4Dict["to_executable"], # to_executable,
            #         # "to_script" => to4Dict["to_script"],  # to_script,
            #         # "input_queues_array" => to4Dict["input_queues_array"],  # input_queues_array,
            #         # "output_queues_array" => to4Dict["output_queues_array"],  # output_queues_array,
            #         "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
            #         "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
            #         "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
            #         "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            #         "label" => "exit",
            #         "message" => "Function < func_Monitor_output_queues() > worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " being exit."
            #     );

            #     Base.put!(rc4from, from4Dict);

            #     Base.close(rc4from);
            # end
            # Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

            while true

                if Base.isready(rc4to)

                    to4Dict = Base.take!(rc4to);

                    from4Dict = Base.Dict{Core.String, Core.Any}(
                        # "read_file_do_Function" => read_file_do_Function,  # to4Dict["read_file_do_Function"];
                        "monitor_file" => to4Dict["monitor_file"], # monitor_file,
                        "monitor_dir" => to4Dict["monitor_dir"], # monitor_dir,
                        # "do_Function" => do_Function,  # to4Dict["do_Function"]，do_data ;
                        "output_dir" => to4Dict["output_dir"], # output_dir,
                        "output_file" => to4Dict["output_file"], # output_file,
                        "temp_cache_IO_data_dir" => to4Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                        "to_executable" => to4Dict["to_executable"], # to_executable,
                        "to_script" => to4Dict["to_script"],  # to_script,
                        "input_queues_array" => to4Dict["input_queues_array"],  # input_queues_array,
                        "output_queues_array" => to4Dict["output_queues_array"],  # output_queues_array,
                        "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                        "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                        "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                        "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        "label" => "func_Monitor_output_queues",
                        "message" => "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task()))
                    );

                    if to4Dict["label"] === "exit"
                        from4Dict["label"] = "exit";
                        from4Dict["message"] = "Function < func_Monitor_output_queues() > worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " being exit.";
                        Base.put!(rc4from, from4Dict);
                        Base.close(rc4from);

                        # continue;
                        break;
                        # Base.exit(0);
                    end

                    if to4Dict["label"] === "Run"

                        if Base.isa(to4Dict, Base.Dict) && Base.haskey(to4Dict, "output_queues_array") && Base.typeof(to4Dict["output_queues_array"]) <: Core.Array && Base.length(to4Dict["output_queues_array"]) > 0 && Base.isa(to4Dict["output_queues_array"][1], Base.Dict) && Base.haskey(to4Dict["output_queues_array"][1], "output_file") && Base.isa(to4Dict["output_queues_array"][1]["output_file"], Core.String) && to4Dict["output_queues_array"][1]["output_file"] !== ""
                            tempOutputFile = to4Dict["output_queues_array"][1]["output_file"];
                        else
                            tempOutputFile = "";
                        end

                        if Base.typeof(to4Dict["output_queues_array"]) <: Core.Array && Base.length(to4Dict["output_queues_array"]) > 0
                            if Base.typeof(to4Dict["input_queues_array"]) <: Core.Array
                                
                                result = func_Monitor_output_queues(
                                    # to4Dict["monitor_file"],  # monitor_file,
                                    # to4Dict["monitor_dir"],  # monitor_dir,
                                    # do_Function,  # to4Dict["do_Function"],
                                    # to4Dict["output_dir"],  # output_dir,
                                    to4Dict["output_file"],  # output_file,
                                    # to4Dict["to_executable"],  # to_executable,
                                    # to4Dict["to_script"],  # to_script,
                                    # to4Dict["temp_cache_IO_data_dir"],  # temp_cache_IO_data_dir,
                                    # number_Worker_threads,
                                    # time_sleep,
                                    to4Dict["input_queues_array"],  # input_queues_array,
                                    to4Dict["output_queues_array"]  # output_queues_array
                                );

                                if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                                    if result[1] === "The output queues array empty."
                                        from4Dict["label"] = "empty";
                                        from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_output_queues() > return [ " * Base.string(result[1]) * " ]";
                                    elseif result[1] === "The output_file already exists."
                                        from4Dict["label"] = "output_file_exists";
                                        from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_output_queues() > return [ " * Base.string(result[1]) * " ]";
                                    elseif result[1] === "output_queues_array[1] -> temp_output_file -> output_file"
                                        from4Dict["monitor_file"] = monitor_file;
                                        from4Dict["monitor_dir"] = monitor_dir;
                                        from4Dict["output_file"] = output_file;
                                        from4Dict["output_dir"] = output_dir;
                                        from4Dict["to_executable"] = to_executable;
                                        from4Dict["to_script"] = to_script;
                                        from4Dict["input_queues_array"] = result[2];
                                        from4Dict["output_queues_array"] = result[3];
                                        from4Dict["label"] = "success";  # "func_Monitor_output_queues";
                                        nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        # println(Base.string(nowTime));
                                        # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(to4Dict["output_queues_array"][Base.length(to4Dict["output_queues_array"])]["output_file"]) * " ] -> [ " * Base.string(output_file) * " ].";
                                        log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(tempOutputFile) * " ] -> [ " * Base.string(output_file) * " ].";
                                        from4Dict["message"] = log_text;  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_output_queues() > success.";
                                    else
                                        from4Dict["input_queues_array"] = result[2];
                                        from4Dict["output_queues_array"] = result[3];
                                        from4Dict["label"] = "error";
                                        from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_output_queues() > return [ " * Base.string(result[1]) * " ]";
                                    end
                                end

                                if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"
                                    from4Dict["label"] = "error";
                                    from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * Base.string(result[3]);  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_output_queues() > return error, or The output queues array empty.";
                                end
                            else
                                from4Dict["label"] = "error";
                                from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the input_queues_array not Core.Array, Base.typeof(input_queues_array) <: Core.Array is false.";
                            end
                        else
                            from4Dict["label"] = "empty";
                            from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the output_queues_array empty.";
                        end

                        Base.put!(rc4from, from4Dict);
                        result = Core.nothing;
                    end

                    from4Dict = Core.nothing;
                    to4Dict = Core.nothing;
                else
                    # continue;
                    # break;
                    # Base.exit(0);
                end

                Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
            end
        end
        # r4 = Base.fetch(wt4);

        while true

            RemoteChannel_Data_Dict = Base.Dict{Core.String, Core.Any}(
                # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                "monitor_file" => monitor_file,
                "monitor_dir" => monitor_dir,
                # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                "output_dir" => output_dir,
                "output_file" => output_file,
                "temp_cache_IO_data_dir" => temp_cache_IO_data_dir,
                "to_executable" => to_executable,
                "to_script" => to_script,
                "input_queues_array" => input_queues_array,
                "output_queues_array" => output_queues_array,
                "worker_queues_Dict" => worker_queues_Dict,
                "total_worker_called_number" => total_worker_called_number,
                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                "label" => "Run",
                "message" => "Run"
            );

            if Base.isopen(rc2to)
                # RemoteChannel_Data_Dict["label"] = "Run";
                RemoteChannel_Data_Dict["message"] = "worker thread-2 Function < func_Monitor_file() > be run.";
                Base.put!(rc2to, RemoteChannel_Data_Dict);
            end

            # if Base.isready(rc2from)

                from2rcDict = Base.take!(rc2from);

                if from2rcDict["label"] === "error"
                    println(from2rcDict["message"]);
                end

                if from2rcDict["label"] === "success"
                    # 打印日志記錄條目;
                    # println(from2rcDict["message"]);
                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                    # log_text = from2rcDict["time"] * " process-" * from2rcDict["processID"] * " thread-" * from2rcDict["threadID"] * " task-" * from2rcDict["taskID"] * " [ " * from2rcDict["monitor_file"] * " ] -> [ " * from2rcDict["output_file"] * " ].";
                    # print(log_text * "\n");
                    input_queues_array = from2rcDict["input_queues_array"];
                    RemoteChannel_Data_Dict["input_queues_array"] = input_queues_array;
                    # output_queues_array = from2rcDict["output_queues_array"];
                    # RemoteChannel_Data_Dict["output_queues_array"] = output_queues_array;
                end

                from2rcDict = Core.nothing;
            # end

            if Base.isopen(rc3to)
                # RemoteChannel_Data_Dict["label"] = "Run";
                RemoteChannel_Data_Dict["message"] = "worker thread-3 Function < func_Monitor_input_queues() > be run.";
                Base.put!(rc3to, RemoteChannel_Data_Dict);
            end

            # if Base.isready(rc3from)

                from3rcDict = Base.take!(rc3from);

                if from3rcDict["label"] === "error"
                    println(from3rcDict["message"]);
                end

                if from3rcDict["label"] === "success"
                    # 打印日志記錄條目;
                    # println(from3rcDict["message"]);
                    log_text = Base.string(from3rcDict["time"]) * " process-" * Base.string(from3rcDict["processID"]) * " thread-" * Base.string(from3rcDict["threadID"]) * " task-" * Base.string(from3rcDict["taskID"]) * " [ " * Base.string(from3rcDict["output_queues_array"][Base.length(from3rcDict["output_queues_array"])]["monitor_file"]) * " ] -> [ " * Base.string(output_file) * " ].";
                    println(log_text);
                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                    # log_text = from3rcDict["time"] * " process-" * from3rcDict["processID"] * " thread-" * from3rcDict["threadID"] * " task-" * from3rcDict["taskID"] * " [ " * from3rcDict["monitor_file"] * " ] -> [ " * from3rcDict["output_file"] * " ].";
                    # print(log_text * "\n");
                    input_queues_array = from3rcDict["input_queues_array"];
                    RemoteChannel_Data_Dict["input_queues_array"] = input_queues_array;
                    output_queues_array = from3rcDict["output_queues_array"];
                    RemoteChannel_Data_Dict["output_queues_array"] = output_queues_array;
                    worker_queues_Dict = from3rcDict["worker_queues_Dict"];
                    RemoteChannel_Data_Dict["worker_queues_Dict"] = worker_queues_Dict;
                    total_worker_called_number = from3rcDict["total_worker_called_number"];
                    RemoteChannel_Data_Dict["total_worker_called_number"] = total_worker_called_number;
                end

                from3rcDict = Core.nothing;
            # end

            if Base.isopen(rc4to)
                # RemoteChannel_Data_Dict["label"] = "Run";
                RemoteChannel_Data_Dict["message"] = "worker thread-4 Function < func_Monitor_output_queues() > be run.";
                Base.put!(rc4to, RemoteChannel_Data_Dict);
            end

            # if Base.isready(rc4from)

                from4rcDict = Base.take!(rc4from);

                if from4rcDict["label"] === "error"
                    println(from4rcDict["message"]);
                end

                if from4rcDict["label"] === "success"
                    # 打印日志記錄條目;
                    # println(from4rcDict["message"]);
                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                    # log_text = from4rcDict["time"] * " process-" * from4rcDict["processID"] * " thread-" * from4rcDict["threadID"] * " task-" * from4rcDict["taskID"] * " [ " * from4rcDict["monitor_file"] * " ] -> [ " * from4rcDict["output_file"] * " ].";
                    # print(log_text * "\n");
                    # input_queues_array = from4rcDict["input_queues_array"];
                    # RemoteChannel_Data_Dict["input_queues_array"] = input_queues_array;
                    output_queues_array = from4rcDict["output_queues_array"];
                    RemoteChannel_Data_Dict["output_queues_array"] = output_queues_array;
                end

                from4rcDict = Core.nothing;
            # end

            RemoteChannel_Data_Dict = Core.nothing;

            begin
                # # 使用 a = Base.read(`bash -c C:/node.exe C:/Cross/test.js a=5 b=6`, Core.String) 調用 shell 語句反饋，運算處理完之後，給調用語言的回復，然後再獲取返回值;
                # # 判斷變量 to_executable 已被定義且類型取值合法，Core.isa(to_executable, Core.String) 與 Base.typeof(to_executable) === Core.String 等效;
                # # local to_executable = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe"));  # String 類型變量，上一層路徑下的Node.JS解釋器可執行檔路徑C:\nodejs\node.exe：Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的解釋器可執行文件 "..\\NodeJS\\node.exe"，Julia 解釋器可執行檔全名 println(Base.Sys.BINDIR)：C:\Julia 1.5.1\bin，;
                # # local to_executable = Core.nothing;  # 置空;
                # if Base.@isdefined(to_executable) && to_executable !== Core.nothing && Core.isa(to_executable, Core.String) && to_executable !== ""

                #     # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否存在;
                #     if Base.Filesystem.ispath(to_executable) && Base.Filesystem.isfile(to_executable)

                #         # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
                #         if Base.stat(to_executable).mode !== Core.UInt64(33206) && Base.stat(to_executable).mode !== Core.UInt64(33279)
                #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
                #             println("回調程序二進制可執行檔 [ " * to_executable * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                #             try
                #                 # 使用 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false) 函數修改文檔操作權限;
                #                 # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                #                 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                #                 println("回調程序二進制可執行檔: " * to_executable * " 操作權限成功修改爲 mode=0o777 .");

                #                 # 八進制值    說明
                #                 # 0o400      所有者可讀
                #                 # 0o200      所有者可寫
                #                 # 0o100      所有者可執行或搜索
                #                 # 0o40       群組可讀
                #                 # 0o20       群組可寫
                #                 # 0o10       群組可執行或搜索
                #                 # 0o4        其他人可讀
                #                 # 0o2        其他人可寫
                #                 # 0o1        其他人可執行或搜索
                #                 # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                #                 # 數字	說明
                #                 # 7	可讀、可寫、可執行
                #                 # 6	可讀、可寫
                #                 # 5	可讀、可執行
                #                 # 4	唯讀
                #                 # 3	可寫、可執行
                #                 # 2	只寫
                #                 # 1	只可執行
                #                 # 0	沒有許可權
                #                 # 例如，八進制值 0o765 表示：
                #                 # 1) 、所有者可以讀取、寫入和執行該文檔；
                #                 # 2) 、群組可以讀和寫入該文檔；
                #                 # 3) 、其他人可以讀取和執行該文檔；
                #                 # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                #                 # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                #             catch err
                #                 println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
                #                 println(err);
                #                 # println(err.msg);
                #                 # println(Base.typeof(err));
                #                 return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
                #             end
                #         end

                #         # 判斷文件夾權限;
                #         if !(Base.stat(to_executable).mode === Core.UInt64(33206) || Base.stat(to_executable).mode === Core.UInt64(33279))
                #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
                #             println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
                #             return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
                #         end

                #         # 判斷變量 to_script 已被定義且類型取值合法，Core.isa(to_script, Core.String) 與 Base.typeof(to_script) === Core.String 等效;
                #         # local to_script = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js"));  # String 類型變量，上一層路徑下的 JavaScript 脚本路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的被調用的脚本文檔 "../js/Ruuter.js";
                #         # local to_script = Core.nothing;  # 置空;
                #         if Base.@isdefined(to_script) && to_script !== Core.nothing && Core.isa(to_script, Core.String) && to_script !== ""
                #             # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否存在;
                #             if Base.Filesystem.ispath(to_script) && Base.Filesystem.isfile(to_script)
                #                 # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
                #                 if Base.stat(to_script).mode !== Core.UInt64(33206) && Base.stat(to_script).mode !== Core.UInt64(33279)
                #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
                #                     println("回調程序二進制可執行檔調用的脚本文檔 [ " * to_script * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                #                     try
                #                         # 使用 Base.Filesystem.chmod(to_script, mode=0o777; recursive=false) 函數修改文檔操作權限;
                #                         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                #                         Base.Filesystem.chmod(to_script, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 操作權限成功修改爲 mode=0o777 .");

                #                         # 八進制值    說明
                #                         # 0o400      所有者可讀
                #                         # 0o200      所有者可寫
                #                         # 0o100      所有者可執行或搜索
                #                         # 0o40       群組可讀
                #                         # 0o20       群組可寫
                #                         # 0o10       群組可執行或搜索
                #                         # 0o4        其他人可讀
                #                         # 0o2        其他人可寫
                #                         # 0o1        其他人可執行或搜索
                #                         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                #                         # 數字	說明
                #                         # 7	可讀、可寫、可執行
                #                         # 6	可讀、可寫
                #                         # 5	可讀、可執行
                #                         # 4	唯讀
                #                         # 3	可寫、可執行
                #                         # 2	只寫
                #                         # 1	只可執行
                #                         # 0	沒有許可權
                #                         # 例如，八進制值 0o765 表示：
                #                         # 1) 、所有者可以讀取、寫入和執行該文檔；
                #                         # 2) 、群組可以讀和寫入該文檔；
                #                         # 3) 、其他人可以讀取和執行該文檔；
                #                         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                #                         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                #                     catch err
                #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
                #                         println(err);
                #                         # println(err.msg);
                #                         # println(Base.typeof(err));
                #                         return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
                #                     end
                #                 end

                #                 # 判斷文件夾權限;
                #                 if !(Base.stat(to_script).mode === Core.UInt64(33206) || Base.stat(to_script).mode === Core.UInt64(33279))
                #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
                #                     println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
                #                     return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
                #                 end
                #             else
                #                 println("回調程序二進制可執行檔調用的脚本文檔路徑全名「to_script = " * Base.string(to_script) * "」不能被識別.");
                #                 return ["error", to_script, "Callback script code document [ to_script = " * Base.string(to_script) * " ] error, no recognition."];
                #             end

                #             textCommand = "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
                #             # Command = `bash -c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             # Command = `cmd /c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             Command = `bash -c $textCommand`;

                #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
                #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
                #             # println(Base.typeof(resultBack));
                #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
                #             println(resultBack);
                #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
                #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                #             # for x in Base.split(resultBack, "\n")
                #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                #             # end
                #             # println(backArray);

                #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             # Base.GC.gc();  # 内存回收函數 gc();

                #         else
                #             textCommand = "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
                #             # Command = `bash -c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             # Command = `cmd /c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             Command = `bash -c $textCommand`;

                #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
                #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
                #             # println(Base.typeof(resultBack));
                #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
                #             println(resultBack);
                #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
                #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                #             # for x in Base.split(resultBack, "\n")
                #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                #             # end
                #             # println(backArray);

                #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             # Base.GC.gc();  # 内存回收函數 gc();
                #         end
                #     else
                #         println("回調程序二進制可執行檔路徑全名「to_executable = " * Base.string(to_executable) * "」不能被識別.");
                #         return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] error, no recognition."];
                #     end
                # end

                # 打印日志記錄條目;
                # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # # println(Base.string(nowTime));
                # # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                # print(log_text * "\n");
                # # log_file = "";  # 日志文檔;
                # # # 同步寫入用於記錄過程的日志文檔;
                # # try
                # #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                # #     # # write(filename::AbstractString, x)
                # #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                # #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                # #     # println(numBytes);
                # #     # println(Base.stat(log_file).size);
                # #     # println(Base.stat(log_file).mtime);
                # #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # #     # println(Base.stat(log_file).ctime);
                # #     # # Base.displaysize([io::IO]) -> (lines, columns)
                # #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                # #     # # Base.countlines — Function
                # #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                # #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                # #     # println(Base.countlines(log_file, eol='\\n'));

                # #     fWIO = Base.open(log_file, "a+");
                # #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                # #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                # #     # Keyword	Description				Default
                # #     # read		open for reading		!write
                # #     # write		open for writing		truncate | append
                # #     # create	create if non-existent	!read & write | truncate | append
                # #     # truncate	truncate to zero size	!read & write
                # #     # append	seek to end				false

                # #     # Mode	Description						Keywords
                # #     # r		read							none
                # #     # w		write, create, truncate			write = true
                # #     # a		write, create, append			append = true
                # #     # r+	read, write						read = true, write = true
                # #     # w+	read, write, create, truncate	truncate = true, read = true
                # #     # a+	read, write, create, append		append = true, read = true

                # #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                # #     if Base.iswritable(fWIO)
                # #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                # #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                # #         println(numBytes);
                # #         println(Base.stat(log_file).size);
                # #         println(Base.stat(log_file).mtime);
                # #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # #         println(Base.stat(log_file).ctime);
                # #         # Base.displaysize([io::IO]) -> (lines, columns)
                # #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                # #         # Base.countlines — Function
                # #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                # #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                # #         println(Base.countlines(log_file, eol='\\n'));
                # #     end

                # #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                # #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                # #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                # #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                # #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                # #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                # #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                # #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                # #     # Base.ismarked(io);  # Return true if stream s is marked;
                # #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                # #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                # #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                # #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                # #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                # #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                # #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                # #     # Base.close(io);  # 關閉緩衝區;
                # #     # println(a)
                # #     # Base.redirect_stdout — Function
                # #     # redirect_stdout([stream]) -> (rd, wr)
                # #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                # #     # If called with the optional stream argument, then returns stream itself.
                # #     # Base.redirect_stdout — Method
                # #     # redirect_stdout(f::Function, stream)
                # #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                # #     # Base.redirect_stderr — Function
                # #     # redirect_stderr([stream]) -> (rd, wr)
                # #     # Like redirect_stdout, but for stderr.
                # #     # Base.redirect_stderr — Method
                # #     # redirect_stderr(f::Function, stream)
                # #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                # #     # Base.redirect_stdin — Function
                # #     # redirect_stdin([stream]) -> (rd, wr)
                # #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                # #     # Base.redirect_stdin — Method
                # #     # redirect_stdin(f::Function, stream)
                # #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                # # catch err
                # #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                # #     println(err);
                # #     # println(Base.typeof(err));
                # #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                # # finally
                # #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                # #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                # #     if Base.eof(fWIO)
                # #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                # #     end
                # # end
            end

            Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
        end
    end

    if isMonitorThreadsOrProcesses === "Multi-Processes"

        # Distributed.addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers;
        # Distributed.addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers;
        # Distributed.addprocs(Base.Sys.CPU_THREADS; kwargs...) -> List of process identifiers;
        # Distributed.addprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers;
        Distributed.addprocs(3);  # Base.Sys.CPU_THREADS;

        Distributed.@everywhere monitor_file, monitor_dir, do_Function, output_dir, output_file, to_executable, to_script, temp_cache_IO_data_dir, number_Worker_threads, time_sleep, read_file_do_Function, isMonitorThreadsOrProcesses, isDoTasksOrThreads;
        # Distributed.@everywhere do_Function = Base.deepcopy(do_Function);
        # Distributed.@everywhere read_file_do_Function = Base.deepcopy(read_file_do_Function);
        # Distributed.@everywhere include(Base.PROGRAM_FILE);  # Distributed.@everywhere include("./script.jl") 將當前正在執行的 Julia 脚本文檔發送到所有子進程可見並在所有子進程中載入，Base.PROGRAM_FILE 為當前正在執行的 Julia 脚本文檔絕對路徑;

        # 子進程 2 運行輪詢 func_Monitor_file 函數;
        # Distributed.@spawnat p expr
        function func_wp2(
            monitor_file::Core.String,
            # monitor_dir::Core.String,
            # do_Function,
            # output_dir::Core.String,
            # output_file::Core.String,
            # to_executable::Core.String,
            # to_script::Core.String,
            # temp_cache_IO_data_dir::Core.String,
            # number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
            time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
            # read_file_do_Function,
            # isMonitorThreadsOrProcesses::Union{Core.String, Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
            # isDoTasksOrThreads::Core.String,
            rc2to::RemoteChannel{Channel{Dict{String,Any}}},
            rc2from::RemoteChannel{Channel{Dict{String,Any}}}
        )
        # wp2 = Distributed.@spawnat 2 begin

            # 監聽文件夾，監測指定目錄下是否有新增或刪除文檔或文件夾的動作;
            input_file_NUM = Core.UInt64(0);  # 監聽到的第幾次傳入媒介文檔;

            # 創建一個自定義的函數，當計時器輪詢時調用，用以實現當指定的被監聽的用於傳輸數據的媒介文檔出現時的具體操作動作，監聽指定的硬盤用於傳數據的媒介文檔，當出現監聽的目標文檔時，激活處理函數;
            function func_Monitor_file(
                monitor_file::Core.String,
                # monitor_dir::Core.String,
                # do_Function,
                # output_dir::Core.String,
                output_file::Core.String,
                to_executable::Core.String,
                to_script::Core.String,
                temp_cache_IO_data_dir::Core.String,
                # number_Worker_threads::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
                time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
                # output_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1},
                input_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1}
            ) ::Core.Array{Core.Any, 1}

                # # print("當前協程 task: ", Base.current_task(), "\n");
                # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
                # print("當前綫程 thread 的 PID: ", Base.Threads.threadid(), "\n");
                # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
                # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
                # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
                # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
                # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
                # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
                # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
                # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
                # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
                # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
                # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
                # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
                # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

                # output_queues_array = Base.deepcopy(output_queues);
                input_queues_array = Base.deepcopy(input_queues);

                # 監聽指定的硬盤用於傳數據的媒介文檔，當出現監聽的目標文檔時，激活處理函數;
                # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介文檔是否存在，如果不存在，則中止函數退出，如果存在則判斷操作權限，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
                # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isfile(monitor_file) 方法判斷是否為文檔;
                if Base.Filesystem.ispath(monitor_file) && Base.Filesystem.isfile(monitor_file)

                    # global input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;
                    input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;

                    # 檢查指定媒介文檔的操作權限是否爲可讀并且可寫，如無可讀可寫權限，則對其修改權限;
                    if Base.stat(monitor_file).mode !== Core.UInt64(33206) && Base.stat(monitor_file).mode !== Core.UInt64(33279)
                        # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(monitor_file) 函數讀取文檔信息，使用 Base.stat(monitor_file).mode 方法提取文檔權限碼;
                        # println("用於傳值的媒介文檔 [ " * monitor_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                        try
                            # 使用 Base.Filesystem.chmod(monitor_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
                            # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                            Base.Filesystem.chmod(monitor_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                            # println("文檔: " * monitor_file * " 操作權限成功修改爲 mode=0o777 .");

                            # 八進制值    說明
                            # 0o400      所有者可讀
                            # 0o200      所有者可寫
                            # 0o100      所有者可執行或搜索
                            # 0o40       群組可讀
                            # 0o20       群組可寫
                            # 0o10       群組可執行或搜索
                            # 0o4        其他人可讀
                            # 0o2        其他人可寫
                            # 0o1        其他人可執行或搜索
                            # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                            # 數字	說明
                            # 7	可讀、可寫、可執行
                            # 6	可讀、可寫
                            # 5	可讀、可執行
                            # 4	唯讀
                            # 3	可寫、可執行
                            # 2	只寫
                            # 1	只可執行
                            # 0	沒有許可權
                            # 例如，八進制值 0o765 表示：
                            # 1) 、所有者可以讀取、寫入和執行該文檔；
                            # 2) 、群組可以讀和寫入該文檔；
                            # 3) 、其他人可以讀取和執行該文檔；
                            # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                            # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                        catch err
                            println("用於輸入數據的媒介文檔: " * monitor_file * " 無法修改操作權限爲 mode=0o777 .");
                            println(err);
                            # println(Base.typeof(err));

                            # Julia提供了許多類型的錯誤：
                            # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                            # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                            # BoundsError：在索引陣列時嘗試訪問越界元素。
                            # DivideError：這是數字除以0時的結果。
                            # DomainError：有效域之外的參數。
                            # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                            # InexactError：嘗試進行精確類型轉換失敗。
                            # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                            # LoadError：載入檔時發生錯誤。
                            # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                            # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                            # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                            # OverflowError：當操作結果太大時會發生這種情況。
                            # ParseError：解析給定運算式時出現問題。
                            # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                            # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                            # UndefRefError：未知引用。
                            # UndefVarError：對不存在的變數進行未知引用。
                            # InitError：調用模組的init方法時出現此錯誤。
                            # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                            # NullException：嘗試訪問Null值
                            # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                            # return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] change the permissions mode=0o777 fail."];
                        end
                    end

                    # 拼接生成對應的用於傳入媒介文檔 monitor_file 和傳出媒介文檔 output_file 的兩個臨時暫存監聽媒介文檔名：temp_monitor_file 和 temp_output_file;
                    # 同步移動文檔，將用於傳入數據的媒介文檔 monitor_file 從媒介文件夾 monitor_dir 移動到臨時暫存媒介文件夾 temp_cache_IO_data_dir;
                    index_NUM = "_" * Base.string(input_file_NUM);  # 傳入數據的臨時暫存文檔 temp_monitor_file 的序號尾;
                    # if Base.typeof(input_queues_array) <: Core.Array && Base.length(input_queues_array) > 0

                    #     if Core.isa(input_queues_array[length(input_queues_array)]["monitor_file"], Core.String) && input_queues_array[length(input_queues_array)]["monitor_file"] !== ""

                    #         # ("/", "home", "myuser", "example.jl") === Base.Filesystem.splitpath("/home/myuser/example.jl")
                    #         # "路徑" === Base.Filesystem.splitdir("路徑 + 文檔名 + 擴展名")[1]
                    #         # "文檔名 + 擴展名" === Base.Filesystem.splitdir("路徑 + 文檔名 + 擴展名")[2]
                    #         # "路徑" === Base.Filesystem.dirname("路徑 + 文檔名 + 擴展名")
                    #         # "文檔名 + 擴展名" === Base.Filesystem.basename("路徑 + 文檔名 + 擴展名")
                    #         # "文檔名" === Base.Filesystem.splitext("文檔名 + 擴展名")[1]
                    #         # "擴展名" === Base.Filesystem.splitext("文檔名 + 擴展名")[2]
                    #         # "/home/myuser/example.jl" === Base.Filesystem.joinpath("/home/myuser", "example.jl")
                    #         # Base.Filesystem.abspath("/home/myuser/example.jl")
                    #         # "/home/example.jl" === Base.Filesystem.normpath("/home/myuser/../example.jl")
                    #         # ("a", "b") === Base.split("a_b", '_')
                    #         # "a_b" === Base.string("a", "_", "b")

                    #         # Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"])
                    #         # Base.Filesystem.splitext(Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"]))[1]
                    #         # Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"]))[1]);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(Core.String)型變量;
                    #         if Base.occursin("_", Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"]))[1]))
                    #             index_NUM = "_" * Base.string(Base.parse(Core.UInt64, Base.convert(Core.String, Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"]))[1]), '_')[length(Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(input_queues_array[length(input_queues_array)]["monitor_file"]))[1]), '_'))])) + Core.UInt64(1));
                    #         end
                    #     end
                    # else
                    #     index_NUM = "_1";
                    # end

                    temp_monitor_file_name = Base.string(Base.Filesystem.splitext(Base.Filesystem.basename(monitor_file))[1]) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(Base.Filesystem.basename(monitor_file))[2]);
                    temp_monitor_file = Base.Filesystem.abspath(Base.Filesystem.normpath(Base.Filesystem.joinpath(temp_cache_IO_data_dir, temp_monitor_file_name)));  # 用於傳入數據的臨時暫存文檔 temp_monitor_file 路徑全名;
                    # println(temp_monitor_file);

                    temp_output_file_name = Base.string(Base.Filesystem.splitext(Base.Filesystem.basename(output_file))[1]) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(Base.Filesystem.basename(output_file))[2]);
                    temp_output_file = Base.Filesystem.abspath(Base.Filesystem.normpath(Base.Filesystem.joinpath(temp_cache_IO_data_dir, temp_output_file_name)));  # 用於傳出數據的臨時暫存文檔 temp_output_file 路徑全名;
                    # println(temp_output_file);

                    # 解析臨時暫存媒介文檔名的尾綴序號;
                    # Base.Filesystem.basename(temp_output_file)
                    # Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]
                    # Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(Core.String)型變量;
                    # Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]), '_')[length(Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]), '_'))]
                    # Base.parse(Core.UInt64, Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]), '_')[length(Base.split(Base.convert(Core.String, Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]), '_'))])

                    # 判斷用於接收傳值的臨時媒介文檔是否有重名的;
                    file_bool = (Base.Filesystem.ispath(temp_monitor_file) && Base.Filesystem.isfile(temp_monitor_file)) || (Base.Filesystem.ispath(temp_output_file) && Base.Filesystem.isfile(temp_output_file));  # 同步判斷，使用 Julia 原生模組 Base.Filesystem 的 Base.Filesystem.ispath() 方法判斷目錄或文檔是否存在以及使用 Base.Filesystem.isfile() 方法判斷是否為文檔;
                    while file_bool

                        # 遞增臨時文檔名尾綴序號;
                        # println(temp_monitor_file);
                        # # Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[2]
                        # # Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[2])
                        # # Base.Meta.parse(Core.UInt64, Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[2]))
                        # global input_file_NUM = Base.Meta.parse(Core.UInt64, Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[2]));
                        # global input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;
                        input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;
                        index_NUM = "_" * Base.string(input_file_NUM);  # 傳入數據的臨時暫存文檔 temp_monitor_file 的序號尾;
                        # # Base.Filesystem.splitext(Base.Filesystem.basename(temp_monitor_file))[1]
                        # # Base.Filesystem.splitext(temp_monitor_file)[1]
                        # # Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[1]
                        # # Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[1])

                        # 修改更新暫存的用於臨時輸入傳值的文檔名;
                        temp_monitor_file = Base.Filesystem.normpath(Base.string(Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[1])) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(temp_monitor_file)[2]));  # 用於傳入數據的臨時暫存文檔 temp_monitor_file 路徑全名;
                        # println(Base.typeof(temp_monitor_file));
                        # println(temp_monitor_file);

                        # 修改更新暫存的用於臨時輸出傳值的文檔名;
                        temp_output_file = Base.Filesystem.normpath(Base.string(Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[1])) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(temp_output_file)[2]));  # 用於傳出數據的臨時暫存文檔 temp_output_file 路徑全名;
                        # println(Base.typeof(temp_output_file));
                        # println(temp_output_file);

                        file_bool = (Base.Filesystem.ispath(temp_monitor_file) && Base.Filesystem.isfile(temp_monitor_file)) || (Base.Filesystem.ispath(temp_output_file) && Base.Filesystem.isfile(temp_output_file));  # 同步判斷，使用 Julia 原生模組 Base.Filesystem 的 Base.Filesystem.ispath() 方法判斷目錄或文檔是否存在以及使用 Base.Filesystem.isfile() 方法判斷是否為文檔;
                    end

                    # # 判斷用於輸出傳值的臨時媒介文檔是否有重名的;
                    # file_bool = (Base.Filesystem.ispath(temp_output_file) && Base.Filesystem.isfile(temp_output_file)) || (Base.Filesystem.ispath(temp_monitor_file) && Base.Filesystem.isfile(temp_monitor_file));  # 同步判斷，使用 Julia 原生模組 Base.Filesystem 的 Base.Filesystem.ispath() 方法判斷目錄或文檔是否存在以及使用 Base.Filesystem.isfile() 方法判斷是否為文檔;
                    # while file_bool

                    #     # 遞增臨時文檔名尾綴序號;
                    #     # println(temp_output_file);
                    #     # # Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[2]
                    #     # # Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[2])
                    #     # # Base.Meta.parse(Core.UInt64, Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[2]))
                    #     # global input_file_NUM = Base.Meta.parse(Core.UInt64, Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[2]));
                    #     # global input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;
                    #     input_file_NUM = input_file_NUM + Core.UInt64(1);  # 監聽到的第幾次傳入媒介文檔;
                    #     index_NUM = "_" * Base.string(input_file_NUM);  # 傳出數據的臨時暫存文檔 temp_output_file 的序號尾;
                    #     # # Base.Filesystem.splitext(Base.Filesystem.basename(temp_output_file))[1]
                    #     # # Base.Filesystem.splitext(temp_output_file)[1]
                    #     # # Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[1]
                    #     # # Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[1])

                    #     # 修改更新暫存的用於臨時輸出傳值的文檔名;
                    #     temp_output_file = Base.Filesystem.normpath(Base.string(Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_output_file)[1]), "_"; limit=2)[1])) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(temp_output_file)[2]));  # 用於傳出數據的臨時暫存文檔 temp_output_file 路徑全名;
                    #     # println(Base.typeof(temp_output_file));
                    #     # println(temp_output_file);

                    #     # 修改更新暫存的用於臨時輸入傳值的文檔名;
                    #     temp_monitor_file = Base.Filesystem.normpath(Base.string(Base.convert(Core.String, Base.rsplit(Base.convert(Core.String, Base.Filesystem.splitext(temp_monitor_file)[1]), "_"; limit=2)[1])) * Base.string(index_NUM) * Base.string(Base.Filesystem.splitext(temp_monitor_file)[2]));  # 用於傳入數據的臨時暫存文檔 temp_monitor_file 路徑全名;
                    #     # println(Base.typeof(temp_monitor_file));
                    #     # println(temp_monitor_file);

                    #     file_bool = (Base.Filesystem.ispath(temp_output_file) && Base.Filesystem.isfile(temp_output_file)) || (Base.Filesystem.ispath(temp_monitor_file) && Base.Filesystem.isfile(temp_monitor_file));  # 同步判斷，使用 Julia 原生模組 Base.Filesystem 的 Base.Filesystem.ispath() 方法判斷目錄或文檔是否存在以及使用 Base.Filesystem.isfile() 方法判斷是否為文檔;
                    # end

                    index_NUM = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                    temp_monitor_file_name = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                    temp_output_file_name = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                    file_bool = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                    # Base.GC.gc();  # 内存回收函數 gc();

                    # 同步移動更名文檔，將用於傳入數據的媒介文檔 monitor_file 從媒介文件夾 monitor_dir 移動到臨時暫存媒介文件夾 temp_cache_IO_data_dir;
                    try
                        # Base.Filesystem.mv(src::AbstractString, dst::AbstractString; force::Bool=false)
                        # Move the file, link, or directory from src to dst. force=true will first remove an existing dst. Return dst.
                        Base.Filesystem.mv(monitor_file, temp_monitor_file; force=false);  # 將文檔、鏈接或目錄從 monitor_file 更名移動到 temp_monitor_file，如果參數 force=true 將首先刪除現有的 temp_monitor_file 文檔，函數返回值為 temp_monitor_file 字符串;
                        # println("用於輸入傳值的媒介文檔: " * monitor_file * " 已經被移動更名爲: " * temp_monitor_file * " .");
                    catch err
                        println("用於輸入數據的媒介文檔: " * monitor_file * " 無法移動更名爲: " * temp_monitor_file * " .");
                        println(err);
                        # println(Base.typeof(err));
                        return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] not move."];
                    end

                    Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                    # 判斷用於接收傳值的媒介文檔 monitor_file，是否已經從硬盤刪除，即判斷用於接收傳值的媒介文檔，是否已經從媒介目錄移動到暫存目錄，並已經更名為 <原名> + "_<序號>" + <原擴展名> 硬盤刪除;
                    if Base.Filesystem.ispath(monitor_file) && Base.Filesystem.isfile(monitor_file)
                        println("用於輸入數據的媒介文檔: " * monitor_file * " 無法移動更名爲: " * temp_monitor_file * " .");
                        return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] not move."];
                    end

                    # 判斷新生成用於暫存的臨時接收傳值的媒介文檔 temp_monitor_file，是否已經創建成功，即判斷用於接收傳值的媒介文檔，是否已經從媒介目錄移動到暫存目錄，並已經更名為 <原名> + "_<序號>" + <原擴展名> 硬盤刪除;
                    if Base.Filesystem.ispath(temp_monitor_file) && Base.Filesystem.isfile(temp_monitor_file)

                        # 檢查指定用於暫存的臨時接收傳值的媒介文檔的操作權限是否爲可讀并且可寫，如無可讀可寫權限，則對其修改權限;
                        if Base.stat(temp_monitor_file).mode !== Core.UInt64(33206) && Base.stat(temp_monitor_file).mode !== Core.UInt64(33279)
                            # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(temp_monitor_file) 函數讀取文檔信息，使用 Base.stat(temp_monitor_file).mode 方法提取文檔權限碼;
                            println("用於暫存的臨時接收傳值的媒介文檔 [ " * temp_monitor_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                            try
                                # 使用 Base.Filesystem.chmod(temp_monitor_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
                                # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                Base.Filesystem.chmod(temp_monitor_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                println("文檔: " * temp_monitor_file * " 操作權限成功修改爲 mode=0o777 .");

                                # 八進制值    說明
                                # 0o400      所有者可讀
                                # 0o200      所有者可寫
                                # 0o100      所有者可執行或搜索
                                # 0o40       群組可讀
                                # 0o20       群組可寫
                                # 0o10       群組可執行或搜索
                                # 0o4        其他人可讀
                                # 0o2        其他人可寫
                                # 0o1        其他人可執行或搜索
                                # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                # 數字	說明
                                # 7	可讀、可寫、可執行
                                # 6	可讀、可寫
                                # 5	可讀、可執行
                                # 4	唯讀
                                # 3	可寫、可執行
                                # 2	只寫
                                # 1	只可執行
                                # 0	沒有許可權
                                # 例如，八進制值 0o765 表示：
                                # 1) 、所有者可以讀取、寫入和執行該文檔；
                                # 2) 、群組可以讀和寫入該文檔；
                                # 3) 、其他人可以讀取和執行該文檔；
                                # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                            catch err
                                println("用於暫存的臨時接收傳值的媒介文檔: " * temp_monitor_file * " 無法修改操作權限爲 mode=0o777 .");
                                println(err);
                                # println(Base.typeof(err));
                                # return ["error", temp_monitor_file, "document [ temp_monitor_file = " * Base.string(temp_monitor_file) * " ] change the permissions mode=0o777 fail."];
                            end
                        end

                    else
                        println("用於暫存的臨時接收傳值的媒介文檔: " * temp_monitor_file * " 無法創建.");
                        return ["error", temp_monitor_file, "document [ temp_monitor_file = " * Base.string(temp_monitor_file) * " ] not create."];
                    end

                    # 追加推入等待讀取運算的傳入數據的隊列數組末尾;
                    # input_queues_array = Core.Array{Base.Dict{Core.String, Core.Any}, 1}();  # 傳入數據等待運算的隊列數組;
                    # 聲明一個字典，隊列中的一個元素數據;
                    # Base.Dict{Core.String, Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}}()
                    worker_Data = Base.Dict{Core.String, Core.Any}(
                        # "read_file_do_Function" => read_file_do_Function,
                        "monitor_file" => temp_monitor_file,  # monitor_file;
                        "monitor_dir" => temp_cache_IO_data_dir,  # monitor_dir;
                        # "do_Function" => do_Function,  # do_Function_obj["do_Function"];
                        "output_dir" => temp_cache_IO_data_dir,  # output_dir;
                        "output_file" => temp_output_file,  # output_file，output_queues_array;
                        "to_executable" => to_executable,
                        "to_script" => to_script
                    );

                    # global input_queues_array = Base.push!(input_queues_array, worker_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                    input_queues_array = Base.push!(input_queues_array, worker_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                    # println(input_queues_array);
                    # println(length(input_queues_array));
                    # result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = input_queues_array[1]["read_file_do_Function"](input_queues_array[1]["monitor_file"], input_queues_array[1]["monitor_dir"], input_queues_array[1]["do_Function"], input_queues_array[1]["output_dir"], input_queues_array[1]["output_file"], input_queues_array[1]["to_executable"], input_queues_array[1]["to_script"], time_sleep);

                    worker_Data = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                    # Base.GC.gc();  # 内存回收函數 gc();

                    # return [monitor_file * " -> " * temp_monitor_file * " -> input_queues_array", input_queues_array, output_queues_array];
                    return ["monitor_file -> temp_monitor_file -> input_queues_array[last]", input_queues_array, output_queues_array];
                else
                    return ["The monitor_file path does not exist.", input_queues_array, output_queues_array];
                end
            end

            function func_Exit()

                from2Dict = Base.Dict{Core.String, Core.Any}(
                    # # "read_file_do_Function" => read_file_do_Function,  # to2Dict["read_file_do_Function"];
                    # "monitor_file" => to2Dict["monitor_file"], # monitor_file,
                    # "monitor_dir" => to2Dict["monitor_dir"], # monitor_dir,
                    # # "do_Function" => do_Function,  # to2Dict["do_Function"]，do_data ;
                    # "output_dir" => to2Dict["output_dir"], # output_dir,
                    # "output_file" => to2Dict["output_file"], # output_file,
                    # "temp_cache_IO_data_dir" => to2Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                    # "to_executable" => to2Dict["to_executable"], # to_executable,
                    # "to_script" => to2Dict["to_script"],  # to_script,
                    # "input_queues_array" => to2Dict["input_queues_array"],  # input_queues_array,
                    # "output_queues_array" => to2Dict["output_queues_array"],  # output_queues_array,
                    "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                    "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                    "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                    "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    "label" => "exit",
                    "message" => "Function < func_Monitor_file() > worker process-" * Base.string(Distributed.myid()) * " being exit."
                );

                Base.put!(rc2from, from2Dict);

                Base.close(rc2from);
            end
            Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

            while true

                if Base.isready(rc2to)

                    to2Dict = Base.take!(rc2to);

                    if to2Dict["label"] === "exit"
                        # break;
                        Base.exit(0);
                    end

                    if to2Dict["label"] === "Run"

                        from2Dict = Base.Dict{Core.String, Core.Any}(
                            # "read_file_do_Function" => read_file_do_Function,  # to2Dict["read_file_do_Function"];
                            "monitor_file" => to2Dict["monitor_file"], # monitor_file,
                            "monitor_dir" => to2Dict["monitor_dir"], # monitor_dir,
                            # "do_Function" => do_Function,  # to2Dict["do_Function"]，do_data ;
                            "output_dir" => to2Dict["output_dir"], # output_dir,
                            "output_file" => to2Dict["output_file"], # output_file,
                            "temp_cache_IO_data_dir" => to2Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                            "to_executable" => to2Dict["to_executable"], # to_executable,
                            "to_script" => to2Dict["to_script"],  # to_script,
                            "input_queues_array" => to2Dict["input_queues_array"],  # input_queues_array,
                            "output_queues_array" => to2Dict["output_queues_array"],  # output_queues_array,
                            "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                            "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                            "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                            "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            "label" => "func_Monitor_file",
                            "message" => "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task()))
                        );

                        if Base.Filesystem.ispath(to2Dict["monitor_file"]) && Base.Filesystem.isfile(to2Dict["monitor_file"])
                            
                            # result = func_Monitor_file(
                            #     monitor_file,
                            #     # monitor_dir,
                            #     # do_Function,
                            #     # output_dir,
                            #     output_file,
                            #     to_executable,
                            #     to_script,
                            #     temp_cache_IO_data_dir,
                            #     # number_Worker_threads,
                            #     time_sleep,
                            #     input_queues_array
                            # );

                            result = func_Monitor_file(
                                to2Dict["monitor_file"],
                                # to2Dict["monitor_dir"],
                                # do_Function, # to2Dict["do_Function"],
                                # to2Dict["output_dir"],
                                to2Dict["output_file"],
                                to2Dict["to_executable"],
                                to2Dict["to_script"],
                                to2Dict["temp_cache_IO_data_dir"],
                                # number_Worker_threads,
                                time_sleep,
                                to2Dict["input_queues_array"]
                            );

                            if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                                if result[1] !== "The monitor_file path does not exist."
                                    if Base.length(result[2]) > 0
                                        input_queues_last = result[2][Base.length(result[2])];
                                        from2Dict["monitor_file"] = input_queues_last["monitor_file"];
                                        from2Dict["monitor_dir"] = input_queues_last["monitor_dir"];
                                        from2Dict["output_file"] = input_queues_last["output_file"];
                                        from2Dict["output_dir"] = input_queues_last["output_dir"];
                                        from2Dict["to_executable"] = input_queues_last["to_executable"];
                                        from2Dict["to_script"] = input_queues_last["to_script"];
                                        from2Dict["input_queues_array"] = result[2];
                                        from2Dict["label"] = "success";  # "func_Monitor_file";
                                        nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        # println(Base.string(nowTime));
                                        log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(monitor_file) * " ] -> [ " * Base.string(input_queues_last["monitor_file"]) * " ].";
                                        from2Dict["message"] = log_text;  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_file() > success.";
                                    else
                                        from2Dict["label"] = "error";
                                        from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_file() > return input_queues_array empty.";
                                    end
                                else
                                    from2Dict["label"] = "empty";
                                    from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_file() > return [ The monitor_file path does not exist. ]";
                                end
                            end

                            if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"
                                from2Dict["label"] = "error";
                                from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * Base.string(result[3]);  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_file() > return error, or The monitor_file path does not exist.";
                            end
                        else
                            from2Dict["label"] = "empty";
                            from2Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the monitor_file path does not exist.";
                        end

                        Base.put!(rc2from, from2Dict);

                        from2Dict = Core.nothing;
                        result = Core.nothing;
                    end

                    to2Dict = Core.nothing;
                else
                    # continue;
                    # break;
                    # Base.exit(0);
                end

                Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
            end
        end
        # Distributed.remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future;
        wp2 = Distributed.remotecall(
            func_wp2,
            2,
            monitor_file,
            # monitor_dir,
            # do_Function,
            # output_dir,
            # output_file,
            # to_executable,
            # to_script,
            # temp_cache_IO_data_dir,
            # number_Worker_threads,
            time_sleep,
            # read_file_do_Function,
            # isMonitorThreadsOrProcesses,
            # isDoTasksOrThreads,
            rc2to,
            rc2from
        );
        # r2 = Base.fetch(wp2);

        # 子進程 3 運行輪詢 func_Monitor_input_queues 函數;
        # Distributed.@spawnat p expr
        function func_wp3(
            # monitor_file::Core.String,
            # monitor_dir::Core.String,
            do_Function,
            # output_dir::Core.String,
            # output_file::Core.String,
            # to_executable::Core.String,
            # to_script::Core.String,
            # temp_cache_IO_data_dir::Core.String,
            number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
            time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
            read_file_do_Function,
            # isMonitorThreadsOrProcesses::Union{Core.String, Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
            isDoTasksOrThreads::Core.String,
            rc3to::RemoteChannel{Channel{Dict{String,Any}}},
            rc3from::RemoteChannel{Channel{Dict{String,Any}}}
        )
        # wp3 = Distributed.@spawnat 3 begin

            # 創建通道(Channel);
            main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
            sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
            control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));  # 用於控制并發數目的通道，寫入一個元素相當於記錄一個啓動的子協程(task)，取出一個元素相當於一個子協程(task)執行完畢，如通道已經滿，則阻塞等待;
            # Base.put!(main_to_sub_channel, channel_message_Dict);  # 向通道(Channel)中寫入元素;
            # # Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
            # Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
            # Base.close(main_to_sub_channel);  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗;

            # isDoTasksOrThreads = "Tasks";  # "Multi-Threading";

            # 當選擇使用多協程（Task）并發運算時，在子協程（Task）中執行的函數;
            function funcTask(
                do_Function,
                read_file_do_Function,
                time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
                main_to_sub_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
                sub_to_main_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
                control_number_Queues_channel::Base.Channel{Core.UInt64}
            ) ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}

                # # print("當前協程 task: ", Base.current_task(), "\n");
                # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
                # print("當前綫程 thread 的 PID: ", Base.Threads.threadid(), "\n");
                # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
                # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
                # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
                # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
                # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
                # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
                # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
                # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
                # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
                # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
                # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
                # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
                # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

                worker_Data_Dict = Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                # worker_Data_Dict = Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;

                if Base.isa(worker_Data_Dict, Base.Dict) && Base.haskey(worker_Data_Dict, "monitor_file") && worker_Data_Dict["monitor_file"] !== Core.nothing && Base.isa(worker_Data_Dict["monitor_file"], Core.String) && worker_Data_Dict["monitor_file"] !== "" && Base.haskey(worker_Data_Dict, "output_file") && worker_Data_Dict["output_file"] !== Core.nothing && Base.isa(worker_Data_Dict["output_file"], Core.String) && worker_Data_Dict["output_file"] !== ""

                    # result = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();
                    result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = read_file_do_Function(
                        worker_Data_Dict["monitor_file"],
                        worker_Data_Dict["monitor_dir"],
                        do_Function,
                        worker_Data_Dict["output_dir"],
                        worker_Data_Dict["output_file"],
                        worker_Data_Dict["to_executable"],
                        worker_Data_Dict["to_script"],
                        time_sleep
                    );
                    # result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = worker_Data_Dict["read_file_do_Function"](
                    #     worker_Data_Dict["monitor_file"],
                    #     worker_Data_Dict["monitor_dir"],
                    #     worker_Data_Dict["do_Function"],
                    #     worker_Data_Dict["output_dir"],
                    #     worker_Data_Dict["output_file"],
                    #     worker_Data_Dict["to_executable"],
                    #     worker_Data_Dict["to_script"],
                    #     time_sleep
                    # );

                    nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));

                    if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"

                        # println("return Error: ", result[3]);  # error;

                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        # println(Base.string(nowTime));
                        # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                        # log_text = "error < " * Base.string(result[3]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(worker_Data_Dict["monitor_file"]) * " > < " * Base.string(worker_Data_Dict["output_file"]) * " >.";
                        # print(log_text * "\n");
                        # log_file = "";  # 日志文檔;
                        # # 同步寫入用於記錄過程的日志文檔;
                        # try
                        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                        #     # # write(filename::AbstractString, x)
                        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                        #     # println(numBytes);
                        #     # println(Base.stat(log_file).size);
                        #     # println(Base.stat(log_file).mtime);
                        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        #     # println(Base.stat(log_file).ctime);
                        #     # # Base.displaysize([io::IO]) -> (lines, columns)
                        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                        #     # # Base.countlines — Function
                        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                        #     # println(Base.countlines(log_file, eol='\\n'));

                        #     fWIO = Base.open(log_file, "a+");
                        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                        #     # Keyword	Description				Default
                        #     # read		open for reading		!write
                        #     # write		open for writing		truncate | append
                        #     # create	create if non-existent	!read & write | truncate | append
                        #     # truncate	truncate to zero size	!read & write
                        #     # append	seek to end				false

                        #     # Mode	Description						Keywords
                        #     # r		read							none
                        #     # w		write, create, truncate			write = true
                        #     # a		write, create, append			append = true
                        #     # r+	read, write						read = true, write = true
                        #     # w+	read, write, create, truncate	truncate = true, read = true
                        #     # a+	read, write, create, append		append = true, read = true

                        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                        #     if Base.iswritable(fWIO)
                        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                        #         println(numBytes);
                        #         println(Base.stat(log_file).size);
                        #         println(Base.stat(log_file).mtime);
                        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        #         println(Base.stat(log_file).ctime);
                        #         # Base.displaysize([io::IO]) -> (lines, columns)
                        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                        #         # Base.countlines — Function
                        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                        #         println(Base.countlines(log_file, eol='\\n'));
                        #     end

                        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                        #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                        #     # Base.ismarked(io);  # Return true if stream s is marked;
                        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                        #     # Base.close(io);  # 關閉緩衝區;
                        #     # println(a)
                        #     # Base.redirect_stdout — Function
                        #     # redirect_stdout([stream]) -> (rd, wr)
                        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                        #     # If called with the optional stream argument, then returns stream itself.
                        #     # Base.redirect_stdout — Method
                        #     # redirect_stdout(f::Function, stream)
                        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                        #     # Base.redirect_stderr — Function
                        #     # redirect_stderr([stream]) -> (rd, wr)
                        #     # Like redirect_stdout, but for stderr.
                        #     # Base.redirect_stderr — Method
                        #     # redirect_stderr(f::Function, stream)
                        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                        #     # Base.redirect_stdin — Function
                        #     # redirect_stdin([stream]) -> (rd, wr)
                        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                        #     # Base.redirect_stdin — Method
                        #     # redirect_stdin(f::Function, stream)
                        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                        # catch err
                        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                        #     println(err);
                        #     # println(Base.typeof(err));

                        #     # Julia提供了許多類型的錯誤：
                        #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                        #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                        #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                        #     # DivideError：這是數字除以0時的結果。
                        #     # DomainError：有效域之外的參數。
                        #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                        #     # InexactError：嘗試進行精確類型轉換失敗。
                        #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                        #     # LoadError：載入檔時發生錯誤。
                        #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                        #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                        #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                        #     # OverflowError：當操作結果太大時會發生這種情況。
                        #     # ParseError：解析給定運算式時出現問題。
                        #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                        #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                        #     # UndefRefError：未知引用。
                        #     # UndefVarError：對不存在的變數進行未知引用。
                        #     # InitError：調用模組的init方法時出現此錯誤。
                        #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                        #     # NullException：嘗試訪問Null值
                        #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                        # finally
                        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                        #     if Base.eof(fWIO)
                        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                        #     end
                        # end

                        result_Data_Dict = Base.Dict{Core.String, Core.Any}(
                            # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                            "monitor_file" => worker_Data_Dict["monitor_file"],  # temp_monitor_file，monitor_file;
                            "monitor_dir" => worker_Data_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir;
                            # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                            "output_dir" => worker_Data_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir;
                            "output_file" => worker_Data_Dict["output_file"],  # temp_output_file，output_file，output_queues_array;
                            "to_executable" => worker_Data_Dict["to_executable"],  # to_executable;
                            "to_script" => worker_Data_Dict["to_script"],  # to_script;
                            "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                            "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                            "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                            "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            "label" => "error",
                            "message" => "Function [ read_file_do_Function ] return error."
                        );

                        Base.put!(sub_to_main_channel, result_Data_Dict);  # 向通道(Channel)中寫入元素;
                        num = Base.take!(control_number_Queues_channel);  # 取出用於控制并發數目的通道中的元素，使主進程中可以繼續創建子進程。使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;

                        # result_Data_Dict = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                        # Base.GC.gc();  # 内存回收函數 gc();

                        return ["error", result[2], "Function [ read_file_do_Function ] return error."];
                    end

                    if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                        # result[1] === "success"

                        # 判斷用於輸出的臨時暫存媒介文檔是否創建成功，如果創建成功，則修改文檔權限;
                        # result[2] === input_queues_array[1]["output_file"] === temp_output_file === output_queues_array[1]["output_file"];
                        if Base.Filesystem.ispath(result[2]) && Base.Filesystem.isfile(result[2])
                            if Base.stat(result[2]).mode !== Core.UInt64(33206) && Base.stat(result[2]).mode !== Core.UInt64(33279)
                                # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(result[2]) 函數讀取文檔信息，使用 Base.stat(result[2]).mode 方法提取文檔權限碼;
                                # println("用於傳出數據的臨時暫存媒介文檔 [ " * result[2] * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                try
                                    # 使用 Base.Filesystem.chmod(result[2], mode=0o777; recursive=false) 函數修改文檔操作權限;
                                    # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                    Base.Filesystem.chmod(result[2], mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                    # println("文檔: " * result[2] * " 操作權限成功修改爲 mode=0o777 .");

                                    # 八進制值    說明
                                    # 0o400      所有者可讀
                                    # 0o200      所有者可寫
                                    # 0o100      所有者可執行或搜索
                                    # 0o40       群組可讀
                                    # 0o20       群組可寫
                                    # 0o10       群組可執行或搜索
                                    # 0o4        其他人可讀
                                    # 0o2        其他人可寫
                                    # 0o1        其他人可執行或搜索
                                    # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                    # 數字	說明
                                    # 7	可讀、可寫、可執行
                                    # 6	可讀、可寫
                                    # 5	可讀、可執行
                                    # 4	唯讀
                                    # 3	可寫、可執行
                                    # 2	只寫
                                    # 1	只可執行
                                    # 0	沒有許可權
                                    # 例如，八進制值 0o765 表示：
                                    # 1) 、所有者可以讀取、寫入和執行該文檔；
                                    # 2) 、群組可以讀和寫入該文檔；
                                    # 3) 、其他人可以讀取和執行該文檔；
                                    # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                    # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                catch err
                                    # println("用於傳出數據的臨時暫存媒介文檔: " * result[2] * " 無法修改操作權限爲 mode=0o777 .");
                                    # println(err);
                                    # println(err.msg);
                                    # println(Base.typeof(err));

                                    result_Data_Dict = Base.Dict{Core.String, Core.Any}(
                                        # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                                        "monitor_file" => worker_Data_Dict["monitor_file"],  # temp_monitor_file，monitor_file;
                                        "monitor_dir" => worker_Data_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir;
                                        # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                                        "output_dir" => worker_Data_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir;
                                        "output_file" => worker_Data_Dict["output_file"],  # temp_output_file，output_file，output_queues_array;
                                        "to_executable" => worker_Data_Dict["to_executable"],  # to_executable;
                                        "to_script" => worker_Data_Dict["to_script"],  # to_script;
                                        "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                        "threadID" => Base.string(Distributed.myid()),  # 子綫程（執行緒） ID;
                                        "taskID" => Base.string(Distributed.myid()),  # 子協程（任務） ID;
                                        "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        "label" => "error",
                                        "message" => "document [ temp_output_file = " * Base.string(result[2]) * " ] change the permissions mode=0o777 fail."
                                    );

                                    Base.put!(sub_to_main_channel, result_Data_Dict);  # 向通道(Channel)中寫入元素;
                                    num = Base.take!(control_number_Queues_channel);  # 取出用於控制并發數目的通道中的元素，使主進程中可以繼續創建子進程。使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;

                                    # result_Data_Dict = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                    # Base.GC.gc();  # 内存回收函數 gc();

                                    return ["error", result[2], "document [ temp_output_file = " * Base.string(result[2]) * " ] change the permissions mode=0o777 fail."];
                                end
                            end
                        else
                            # println("用於傳出數據的臨時暫存媒介文檔: " * result[2] * " 無法被創建.");

                            result_Data_Dict = Base.Dict{Core.String, Core.Any}(
                                # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                                "monitor_file" => worker_Data_Dict["monitor_file"],  # temp_monitor_file，monitor_file;
                                "monitor_dir" => worker_Data_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir;
                                # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                                "output_dir" => worker_Data_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir;
                                "output_file" => worker_Data_Dict["output_file"],  # temp_output_file，output_file，output_queues_array;
                                "to_executable" => worker_Data_Dict["to_executable"],  # to_executable;
                                "to_script" => worker_Data_Dict["to_script"],  # to_script;
                                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                "threadID" => Base.string(Distributed.myid()),  # 子綫程（執行緒） ID;
                                "taskID" => Base.string(Distributed.myid()),  # 子協程（任務） ID;
                                "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                "label" => "error",
                                "message" => "document [ temp_output_file = " * Base.string(result[2]) * " ] not create."
                            );

                            Base.put!(sub_to_main_channel, result_Data_Dict);  # 向通道(Channel)中寫入元素;
                            num = Base.take!(control_number_Queues_channel);  # 取出用於控制并發數目的通道中的元素，使主進程中可以繼續創建子進程。使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;

                            # result_Data_Dict = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                            # Base.GC.gc();  # 内存回收函數 gc();

                            return ["error", result[2], "document [ temp_output_file = " * Base.string(result[2]) * " ] not create."];
                        end

                        result_Data_Dict = Base.Dict{Core.String, Core.Any}(
                            # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                            "monitor_file" => result[3],  # temp_monitor_file，monitor_file;
                            "monitor_dir" => worker_Data_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir;
                            # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                            "output_dir" => worker_Data_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir;
                            "output_file" => result[2],  # temp_output_file，output_file，output_queues_array;
                            "to_executable" => worker_Data_Dict["to_executable"],  # to_executable;
                            "to_script" => worker_Data_Dict["to_script"],  # to_script;
                            "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                            "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                            "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                            "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            "label" => "success",
                            "message" => Base.string(result[1])
                        );

                        Base.put!(sub_to_main_channel, result_Data_Dict);  # 向通道(Channel)中寫入元素;
                        num = Base.take!(control_number_Queues_channel);  # 取出用於控制并發數目的通道中的元素，使主進程中可以繼續創建子進程。使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;

                        # # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 是否仍然存在，如果仍存在，則將用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 同步從硬盤刪除;
                        # # result[3] === input_queues_array[1]["monitor_file"] === temp_monitor_file === output_queues_array[1]["monitor_file"];
                        # if Base.Filesystem.ispath(result[3]) && Base.Filesystem.isfile(result[3])
                        #     # 讀取到輸入數據之後，同步刪除，用於接收傳值的媒介文檔;
                        #     try
                        #         # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                        #         # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                        #         Base.Filesystem.rm(result[3], force=true, recursive=false);  # 刪除給定路徑下的文檔、鏈接或空目錄，如果傳遞參數 force=true 時，則不存在的路徑不被視爲錯誤，如果傳遞參數 recursive=true 并且路徑是目錄時，則遞歸刪除所有内容;
                        #         # Base.Filesystem.rm(path::AbstractString, force::Bool=false, recursive::Bool=false)
                        #         # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                        #         # println("媒介文檔: " * result[3] * " 已被刪除.");
                        #     catch err
                        #         println("用於傳入數據的臨時暫存媒介文檔: " * result[3] * " 無法刪除.");
                        #         println(err);
                        #         # println(err.msg);
                        #         # println(Base.typeof(err));
                        #         # return ["error", result[3], "document [ temp_monitor_file = " * Base.string(result[3]) * " ] not delete."];
                        #     end

                        #     # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                        #     # # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 在已處理完數據後，是否已經從硬盤刪除;
                        #     # if Base.Filesystem.ispath(result[3]) && Base.Filesystem.isfile(result[3])
                        #     #     println("用於傳入數據的臨時暫存媒介文檔: " * result[3] * " 無法刪除.");
                        #     #     # return ["error", result[3], "document [ temp_monitor_file = " * Base.string(result[3]) * " ] not delete."];
                        #     # end
                        # end

                        # result_Data_Dict = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                        # Base.GC.gc();  # 内存回收函數 gc();

                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        # println(Base.string(nowTime));
                        # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                        # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(result[3]) * " ] -> [ " * Base.string(result[2]) * " ].";
                        # print(log_text * "\n");
                        # log_file = "";  # 日志文檔;
                        # # 同步寫入用於記錄過程的日志文檔;
                        # try
                        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                        #     # # write(filename::AbstractString, x)
                        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                        #     # println(numBytes);
                        #     # println(Base.stat(log_file).size);
                        #     # println(Base.stat(log_file).mtime);
                        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        #     # println(Base.stat(log_file).ctime);
                        #     # # Base.displaysize([io::IO]) -> (lines, columns)
                        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                        #     # # Base.countlines — Function
                        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                        #     # println(Base.countlines(log_file, eol='\\n'));

                        #     fWIO = Base.open(log_file, "a+");
                        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                        #     # Keyword	Description				Default
                        #     # read		open for reading		!write
                        #     # write		open for writing		truncate | append
                        #     # create	create if non-existent	!read & write | truncate | append
                        #     # truncate	truncate to zero size	!read & write
                        #     # append	seek to end				false

                        #     # Mode	Description						Keywords
                        #     # r		read							none
                        #     # w		write, create, truncate			write = true
                        #     # a		write, create, append			append = true
                        #     # r+	read, write						read = true, write = true
                        #     # w+	read, write, create, truncate	truncate = true, read = true
                        #     # a+	read, write, create, append		append = true, read = true

                        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                        #     if Base.iswritable(fWIO)
                        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                        #         println(numBytes);
                        #         println(Base.stat(log_file).size);
                        #         println(Base.stat(log_file).mtime);
                        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        #         println(Base.stat(log_file).ctime);
                        #         # Base.displaysize([io::IO]) -> (lines, columns)
                        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                        #         # Base.countlines — Function
                        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                        #         println(Base.countlines(log_file, eol='\\n'));
                        #     end

                        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                        #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                        #     # Base.ismarked(io);  # Return true if stream s is marked;
                        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                        #     # Base.close(io);  # 關閉緩衝區;
                        #     # println(a)
                        #     # Base.redirect_stdout — Function
                        #     # redirect_stdout([stream]) -> (rd, wr)
                        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                        #     # If called with the optional stream argument, then returns stream itself.
                        #     # Base.redirect_stdout — Method
                        #     # redirect_stdout(f::Function, stream)
                        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                        #     # Base.redirect_stderr — Function
                        #     # redirect_stderr([stream]) -> (rd, wr)
                        #     # Like redirect_stdout, but for stderr.
                        #     # Base.redirect_stderr — Method
                        #     # redirect_stderr(f::Function, stream)
                        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                        #     # Base.redirect_stdin — Function
                        #     # redirect_stdin([stream]) -> (rd, wr)
                        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                        #     # Base.redirect_stdin — Method
                        #     # redirect_stdin(f::Function, stream)
                        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                        # catch err
                        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                        #     println(err);
                        #     # println(err.msg);
                        #     # println(Base.typeof(err));
                        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                        # finally
                        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                        #     if Base.eof(fWIO)
                        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                        #     end
                        # end

                        # return ["success", result[1], result[2], result[3]];
                        return [result[1], result[2], result[3]];
                    end
                    # global input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                    # input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                else
                    return ["error", "main_to_sub_channel", "Base.typeof(Base.take!(main_to_sub_channel)) !== Base.Dict, not recognition."];
                end
            end

            # 創建一個自定義的函數，當計時器輪詢時調用，用以監聽傳入數據等待處理的任務隊列，當傳入數據等待處理的任務隊列長度大於 1 時，采用先進先出的原則，處理隊列中的任務排隊，並相應清除已經被處理過的任務元素;
            function func_Monitor_input_queues(
                # monitor_file::Core.String,
                # monitor_dir::Core.String,
                do_Function,
                # output_dir::Core.String,
                # output_file::Core.String,
                # to_executable::Core.String,
                # to_script::Core.String,
                # temp_cache_IO_data_dir::Core.String,
                number_Worker_threads::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
                time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
                read_file_do_Function,
                isDoTasksOrThreads::Core.String,
                funcTask,
                main_to_sub_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
                sub_to_main_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
                control_number_Queues_channel::Base.Channel{Core.UInt64},
                input_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1},
                output_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1},
                worker_queues_Dict::Base.Dict{Core.String, Core.Any},
                total_worker_called_number::Base.Dict{Core.String, Core.UInt64}
            ) ::Core.Array{Core.Any, 1}

                # # print("當前協程 task: ", Base.current_task(), "\n");
                # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
                # print("當前綫程 thread 的 PID: ", Base.Threads.threadid(), "\n");
                # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
                # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
                # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
                # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
                # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
                # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
                # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
                # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
                # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
                # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
                # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
                # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
                # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

                output_queues_array = Base.deepcopy(output_queues);
                input_queues_array = Base.deepcopy(input_queues);

                # 監聽待處理任務隊列數組 input_queues_array 和 空閑子綫程隊列 worker_free，當有待處理任務等待時，且有空閑子進程時，將待任務隊列中排在前面的第一個待處理任務，推入一個空閑子進程;
                if Base.typeof(input_queues_array) <: Core.Array && Base.length(input_queues_array) > 0

                    # 無并發，就在當前主進程（Master）中，處理輸入任務隊列;
                    if Core.Int8(number_Worker_threads) <= Core.Int8(0)

                        if Base.isa(input_queues_array[1], Base.Dict) && Base.haskey(input_queues_array[1], "monitor_file") && input_queues_array[1]["monitor_file"] !== Core.nothing && Base.isa(input_queues_array[1]["monitor_file"], Core.String) && input_queues_array[1]["monitor_file"] !== "" && Base.haskey(input_queues_array[1], "output_file") && input_queues_array[1]["output_file"] !== Core.nothing && Base.isa(input_queues_array[1]["output_file"], Core.String) && input_queues_array[1]["output_file"] !== ""

                            # 記錄每個綫程纍加的被調用運算的總次數;
                            # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                            # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                            if Base.haskey(total_worker_called_number, Base.string(Base.objectid(Base.current_task())))
                                # global total_worker_called_number[Base.string(Base.objectid(Base.current_task()))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(Base.current_task()))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                total_worker_called_number[Base.string(Base.objectid(Base.current_task()))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(Base.current_task()))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                            else
                                # global total_worker_called_number[Base.string(Base.objectid(Base.current_task()))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                total_worker_called_number[Base.string(Base.objectid(Base.current_task()))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            end

                            # result = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();
                            result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = read_file_do_Function(
                                input_queues_array[1]["monitor_file"],
                                input_queues_array[1]["monitor_dir"],
                                do_Function,
                                input_queues_array[1]["output_dir"],
                                input_queues_array[1]["output_file"],
                                input_queues_array[1]["to_executable"],
                                input_queues_array[1]["to_script"],
                                time_sleep
                            );
                            # result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = input_queues_array[1]["read_file_do_Function"](
                            #     input_queues_array[1]["monitor_file"],
                            #     input_queues_array[1]["monitor_dir"],
                            #     input_queues_array[1]["do_Function"],
                            #     input_queues_array[1]["output_dir"],
                            #     input_queues_array[1]["output_file"],
                            #     input_queues_array[1]["to_executable"],
                            #     input_queues_array[1]["to_script"],
                            #     time_sleep
                            # );

                            nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            # println(Base.string(nowTime));

                            if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"

                                println("return Error: ", result[3]);  # error;

                                # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                # println(Base.string(nowTime));
                                # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                # log_text = "error < " * Base.string(result[3]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(input_queues_array[1]["monitor_file"]) * " > < " * Base.string(input_queues_array[1]["output_file"]) * " >.";
                                # print(log_text * "\n");
                                # log_file = "";  # 日志文檔;
                                # # 同步寫入用於記錄過程的日志文檔;
                                # try
                                #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                #     # # write(filename::AbstractString, x)
                                #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                #     # println(numBytes);
                                #     # println(Base.stat(log_file).size);
                                #     # println(Base.stat(log_file).mtime);
                                #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                #     # println(Base.stat(log_file).ctime);
                                #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                #     # # Base.countlines — Function
                                #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                #     # println(Base.countlines(log_file, eol='\\n'));

                                #     fWIO = Base.open(log_file, "a+");
                                #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                #     # Keyword	Description				Default
                                #     # read		open for reading		!write
                                #     # write		open for writing		truncate | append
                                #     # create	create if non-existent	!read & write | truncate | append
                                #     # truncate	truncate to zero size	!read & write
                                #     # append	seek to end				false

                                #     # Mode	Description						Keywords
                                #     # r		read							none
                                #     # w		write, create, truncate			write = true
                                #     # a		write, create, append			append = true
                                #     # r+	read, write						read = true, write = true
                                #     # w+	read, write, create, truncate	truncate = true, read = true
                                #     # a+	read, write, create, append		append = true, read = true

                                #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                #     if Base.iswritable(fWIO)
                                #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                #         println(numBytes);
                                #         println(Base.stat(log_file).size);
                                #         println(Base.stat(log_file).mtime);
                                #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                #         println(Base.stat(log_file).ctime);
                                #         # Base.displaysize([io::IO]) -> (lines, columns)
                                #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                #         # Base.countlines — Function
                                #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                #         println(Base.countlines(log_file, eol='\\n'));
                                #     end

                                #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                                #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                                #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                #     # Base.ismarked(io);  # Return true if stream s is marked;
                                #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                #     # Base.close(io);  # 關閉緩衝區;
                                #     # println(a)
                                #     # Base.redirect_stdout — Function
                                #     # redirect_stdout([stream]) -> (rd, wr)
                                #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                #     # If called with the optional stream argument, then returns stream itself.
                                #     # Base.redirect_stdout — Method
                                #     # redirect_stdout(f::Function, stream)
                                #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                #     # Base.redirect_stderr — Function
                                #     # redirect_stderr([stream]) -> (rd, wr)
                                #     # Like redirect_stdout, but for stderr.
                                #     # Base.redirect_stderr — Method
                                #     # redirect_stderr(f::Function, stream)
                                #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                #     # Base.redirect_stdin — Function
                                #     # redirect_stdin([stream]) -> (rd, wr)
                                #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                #     # Base.redirect_stdin — Method
                                #     # redirect_stdin(f::Function, stream)
                                #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                # catch err
                                #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                #     println(err);
                                #     # println(Base.typeof(err));

                                #     # Julia提供了許多類型的錯誤：
                                #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                                #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                                #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                                #     # DivideError：這是數字除以0時的結果。
                                #     # DomainError：有效域之外的參數。
                                #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                                #     # InexactError：嘗試進行精確類型轉換失敗。
                                #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                                #     # LoadError：載入檔時發生錯誤。
                                #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                                #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                                #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                                #     # OverflowError：當操作結果太大時會發生這種情況。
                                #     # ParseError：解析給定運算式時出現問題。
                                #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                                #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                                #     # UndefRefError：未知引用。
                                #     # UndefVarError：對不存在的變數進行未知引用。
                                #     # InitError：調用模組的init方法時出現此錯誤。
                                #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                                #     # NullException：嘗試訪問Null值
                                #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                                #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                # finally
                                #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                #     if Base.eof(fWIO)
                                #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                #     end
                                # end
                            end

                            if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                                # result[1] === "success"

                                # 判斷用於輸出的臨時暫存媒介文檔是否創建成功，如果創建成功，則修改文檔權限;
                                # result[2] === input_queues_array[1]["output_file"] === temp_output_file === output_queues_array[1]["output_file"];
                                if Base.Filesystem.ispath(result[2]) && Base.Filesystem.isfile(result[2])
                                    if Base.stat(result[2]).mode !== Core.UInt64(33206) && Base.stat(result[2]).mode !== Core.UInt64(33279)
                                        # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(result[2]) 函數讀取文檔信息，使用 Base.stat(result[2]).mode 方法提取文檔權限碼;
                                        # println("用於傳出數據的臨時暫存媒介文檔 [ " * result[2] * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                        try
                                            # 使用 Base.Filesystem.chmod(result[2], mode=0o777; recursive=false) 函數修改文檔操作權限;
                                            # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                            Base.Filesystem.chmod(result[2], mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                            # println("文檔: " * result[2] * " 操作權限成功修改爲 mode=0o777 .");

                                            # 八進制值    說明
                                            # 0o400      所有者可讀
                                            # 0o200      所有者可寫
                                            # 0o100      所有者可執行或搜索
                                            # 0o40       群組可讀
                                            # 0o20       群組可寫
                                            # 0o10       群組可執行或搜索
                                            # 0o4        其他人可讀
                                            # 0o2        其他人可寫
                                            # 0o1        其他人可執行或搜索
                                            # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                            # 數字	說明
                                            # 7	可讀、可寫、可執行
                                            # 6	可讀、可寫
                                            # 5	可讀、可執行
                                            # 4	唯讀
                                            # 3	可寫、可執行
                                            # 2	只寫
                                            # 1	只可執行
                                            # 0	沒有許可權
                                            # 例如，八進制值 0o765 表示：
                                            # 1) 、所有者可以讀取、寫入和執行該文檔；
                                            # 2) 、群組可以讀和寫入該文檔；
                                            # 3) 、其他人可以讀取和執行該文檔；
                                            # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                            # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                        catch err
                                            println("用於傳出數據的臨時暫存媒介文檔: " * result[2] * " 無法修改操作權限爲 mode=0o777 .");
                                            println(err);
                                            # println(Base.typeof(err));
                                            # return ["error", result[2], "document [ temp_output_file = " * Base.string(result[2]) * " ] change the permissions mode=0o777 fail."];
                                        end
                                    end
                                else
                                    println("用於傳出數據的臨時暫存媒介文檔: " * result[2] * " 無法被創建.");
                                    # return ["error", result[2], "document [ temp_output_file = " * Base.string(result[2]) * " ] not create."];
                                end

                                result_Data = Base.Dict{Core.String, Core.Any}(
                                    # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                                    "monitor_file" => result[3],  # temp_monitor_file，monitor_file;
                                    "monitor_dir" => input_queues_array[1]["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir;
                                    # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                                    "output_dir" => input_queues_array[1]["output_dir"],  # temp_cache_IO_data_dir，output_dir;
                                    "output_file" => result[2],  # temp_output_file，output_file，output_queues_array;
                                    "to_executable" => input_queues_array[1]["to_executable"],  # to_executable;
                                    "to_script" => input_queues_array[1]["to_script"],  # to_script;"processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                    "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                    "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                    "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                    "time" => Base.string(nowTime)  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                );

                                # global output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                                output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                                # println(output_queues_array);
                                # println(length(output_queues_array));

                                # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 是否仍然存在，如果仍存在，則將用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 同步從硬盤刪除;
                                # result[3] === input_queues_array[1]["monitor_file"] === temp_monitor_file === output_queues_array[1]["monitor_file"];
                                if Base.Filesystem.ispath(result[3]) && Base.Filesystem.isfile(result[3])
                                    # 讀取到輸入數據之後，同步刪除，用於接收傳值的媒介文檔;
                                    try
                                        # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                                        # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                        Base.Filesystem.rm(result[3], force=true, recursive=false);  # 刪除給定路徑下的文檔、鏈接或空目錄，如果傳遞參數 force=true 時，則不存在的路徑不被視爲錯誤，如果傳遞參數 recursive=true 并且路徑是目錄時，則遞歸刪除所有内容;
                                        # Base.Filesystem.rm(path::AbstractString, force::Bool=false, recursive::Bool=false)
                                        # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                        # println("媒介文檔: " * result[3] * " 已被刪除.");
                                    catch err
                                        println("用於傳入數據的臨時暫存媒介文檔: " * result[3] * " 無法刪除.");
                                        println(err);
                                        # println(Base.typeof(err));
                                        # return ["error", result[3], "document [ temp_monitor_file = " * Base.string(result[3]) * " ] not delete."];
                                    end

                                    # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                                    # # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 在已處理完數據後，是否已經從硬盤刪除;
                                    # if Base.Filesystem.ispath(result[3]) && Base.Filesystem.isfile(result[3])
                                    #     println("用於傳入數據的臨時暫存媒介文檔: " * result[3] * " 無法刪除.");
                                    #     # return ["error", result[3], "document [ temp_monitor_file = " * Base.string(result[3]) * " ] not delete."];
                                    # end
                                end

                                result_Data = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                # Base.GC.gc();  # 内存回收函數 gc();

                                # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                # println(Base.string(nowTime));
                                # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(result[3]) * " ] -> [ " * Base.string(result[2]) * " ].";
                                # print(log_text * "\n");
                                # log_file = "";  # 日志文檔;
                                # # 同步寫入用於記錄過程的日志文檔;
                                # try
                                #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                #     # # write(filename::AbstractString, x)
                                #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                #     # println(numBytes);
                                #     # println(Base.stat(log_file).size);
                                #     # println(Base.stat(log_file).mtime);
                                #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                #     # println(Base.stat(log_file).ctime);
                                #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                #     # # Base.countlines — Function
                                #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                #     # println(Base.countlines(log_file, eol='\\n'));

                                #     fWIO = Base.open(log_file, "a+");
                                #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                #     # Keyword	Description				Default
                                #     # read		open for reading		!write
                                #     # write		open for writing		truncate | append
                                #     # create	create if non-existent	!read & write | truncate | append
                                #     # truncate	truncate to zero size	!read & write
                                #     # append	seek to end				false

                                #     # Mode	Description						Keywords
                                #     # r		read							none
                                #     # w		write, create, truncate			write = true
                                #     # a		write, create, append			append = true
                                #     # r+	read, write						read = true, write = true
                                #     # w+	read, write, create, truncate	truncate = true, read = true
                                #     # a+	read, write, create, append		append = true, read = true

                                #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                #     if Base.iswritable(fWIO)
                                #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                #         println(numBytes);
                                #         println(Base.stat(log_file).size);
                                #         println(Base.stat(log_file).mtime);
                                #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                #         println(Base.stat(log_file).ctime);
                                #         # Base.displaysize([io::IO]) -> (lines, columns)
                                #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                #         # Base.countlines — Function
                                #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                #         println(Base.countlines(log_file, eol='\\n'));
                                #     end

                                #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                                #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                                #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                #     # Base.ismarked(io);  # Return true if stream s is marked;
                                #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                #     # Base.close(io);  # 關閉緩衝區;
                                #     # println(a)
                                #     # Base.redirect_stdout — Function
                                #     # redirect_stdout([stream]) -> (rd, wr)
                                #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                #     # If called with the optional stream argument, then returns stream itself.
                                #     # Base.redirect_stdout — Method
                                #     # redirect_stdout(f::Function, stream)
                                #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                #     # Base.redirect_stderr — Function
                                #     # redirect_stderr([stream]) -> (rd, wr)
                                #     # Like redirect_stdout, but for stderr.
                                #     # Base.redirect_stderr — Method
                                #     # redirect_stderr(f::Function, stream)
                                #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                #     # Base.redirect_stdin — Function
                                #     # redirect_stdin([stream]) -> (rd, wr)
                                #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                #     # Base.redirect_stdin — Method
                                #     # redirect_stdin(f::Function, stream)
                                #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                # catch err
                                #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                #     println(err);
                                #     # println(Base.typeof(err));
                                #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                # finally
                                #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                #     if Base.eof(fWIO)
                                #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                #     end
                                # end
                            end

                            # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            # println(Base.string(nowTime));
                            # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                            # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(result[3]) * " ] -> [ " * Base.string(result[2]) * " ].";
                            # print(log_text * "\n");
                            # log_file = "";  # 日志文檔;
                            # # 同步寫入用於記錄過程的日志文檔;
                            # try
                            #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                            #     # # write(filename::AbstractString, x)
                            #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                            #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                            #     # println(numBytes);
                            #     # println(Base.stat(log_file).size);
                            #     # println(Base.stat(log_file).mtime);
                            #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            #     # println(Base.stat(log_file).ctime);
                            #     # # Base.displaysize([io::IO]) -> (lines, columns)
                            #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                            #     # # Base.countlines — Function
                            #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                            #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                            #     # println(Base.countlines(log_file, eol='\\n'));

                            #     fWIO = Base.open(log_file, "a+");
                            #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                            #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                            #     # Keyword	Description				Default
                            #     # read		open for reading		!write
                            #     # write		open for writing		truncate | append
                            #     # create	create if non-existent	!read & write | truncate | append
                            #     # truncate	truncate to zero size	!read & write
                            #     # append	seek to end				false

                            #     # Mode	Description						Keywords
                            #     # r		read							none
                            #     # w		write, create, truncate			write = true
                            #     # a		write, create, append			append = true
                            #     # r+	read, write						read = true, write = true
                            #     # w+	read, write, create, truncate	truncate = true, read = true
                            #     # a+	read, write, create, append		append = true, read = true

                            #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                            #     if Base.iswritable(fWIO)
                            #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                            #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                            #         println(numBytes);
                            #         println(Base.stat(log_file).size);
                            #         println(Base.stat(log_file).mtime);
                            #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            #         println(Base.stat(log_file).ctime);
                            #         # Base.displaysize([io::IO]) -> (lines, columns)
                            #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                            #         # Base.countlines — Function
                            #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                            #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                            #         println(Base.countlines(log_file, eol='\\n'));
                            #     end

                            #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                            #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                            #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                            #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                            #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                            #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                            #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                            #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                            #     # Base.ismarked(io);  # Return true if stream s is marked;
                            #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                            #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                            #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                            #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                            #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                            #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                            #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                            #     # Base.close(io);  # 關閉緩衝區;
                            #     # println(a)
                            #     # Base.redirect_stdout — Function
                            #     # redirect_stdout([stream]) -> (rd, wr)
                            #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                            #     # If called with the optional stream argument, then returns stream itself.
                            #     # Base.redirect_stdout — Method
                            #     # redirect_stdout(f::Function, stream)
                            #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                            #     # Base.redirect_stderr — Function
                            #     # redirect_stderr([stream]) -> (rd, wr)
                            #     # Like redirect_stdout, but for stderr.
                            #     # Base.redirect_stderr — Method
                            #     # redirect_stderr(f::Function, stream)
                            #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                            #     # Base.redirect_stdin — Function
                            #     # redirect_stdin([stream]) -> (rd, wr)
                            #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                            #     # Base.redirect_stdin — Method
                            #     # redirect_stdin(f::Function, stream)
                            #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                            # catch err
                            #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                            #     println(err);
                            #     # println(Base.typeof(err));
                            #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                            # finally
                            #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                            #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                            #     if Base.eof(fWIO)
                            #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                            #     end
                            # end

                            # global input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                            input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                        end
                    end

                    # 開啓并發，在子進程（Worker）中，處理輸入任務隊列;
                    if Core.Int8(number_Worker_threads) > Core.Int8(0)
                        
                        if isDoTasksOrThreads === "Tasks"

                            # 在 Julia 中，稱協程（Coroutine）為任務（Task）。創建任務（Task）的方式有兩種，
                            # 用構造方法：
                            # taskname = Task(f)
                            # 用構造方法 Task(f) 將一個函數對象 f 封裝成名為 taskname 的任務（Task）。此時要求函數對象 f 必須是無參數的，即沒有參數或所有參數都有預設值。假如函數對象 f 有參數，那麼 f 就變成了運算式，在傳入 Task() 前會被執行，於是傳入 Task() 的不再是函數對象而是執行結果。為解決此問題，可以定義一個 f1()=f(參數)，然後 taskname = Task(f1)。
                            # 巨集（宏）命令 @task 將一個運算式封裝成任務（Task）
                            # taskname = @task 運算式
                            # 用巨集（宏）命令 @task 將一個運算式封裝成名為 taskname 的任務（Task）。注意大小寫。
                            # 創建後，可用 istaskstarted(taskname) 函數和 istaskdone(taskname) 函數查看創建的任務（Task）是否啟動和結束。Task 有五個狀態：runnable（可被啟動）, waiting（阻塞等待中）, queued（正被調度中）, done（執行結束）, failed（執行異常結束）。在 Julia 內部有一個調度器，負責維護 task 運行佇列。用 schedule(taskname) 函數可以把 Task 加入佇列並啟動，隨後會自動返回 done 狀態，表示已完成。
                            # 對於運算式，有個「合二為一」的巨集命令：@async 運算式。它會創建 Task 並直接啟動。例如：
                            # using Distributed
                            # a=zeros(1,5)
                            # 1×5 Array{Float64,2}:
                            # 0.0  0.0  0.0  0.0  0.0
                            # @async fill!(a, 4)
                            # Task (done) @0x00000000063059f0
                            # println(a)
                            # 1×5 Array{Float64,2}:
                            # 4.0  4.0  4.0  4.0  4.0
                            # 1
                            # 2
                            # 3
                            # 4
                            # 5
                            # 6
                            # 7
                            # 8
                            # 9
                            # 10
                            # 11
                            # 12
                            # 可以在被傳給 Task() 的函數對象 f 內部使用某些命令強迫這一 Task 改變狀態，包括：
                            # Base.sleep(N)  睡眠N秒
                            # yield()  請求切換為其他 task
                            # yieldto(taskname)  請求切換為指定的task，一般不建議使用

                            # 通道、管道(Channel);
                            # Base.Channel{T=Any}(size::Int=0);
                            # 如果一個 Channel 是空的，讀取的 task（即執行 v = Base.take!(c::Channel) 的 task）會被阻塞直到有新的資料準備好了。
                            # 如果一個 Channel 是滿的，那麼寫入的 task（即執行 Base.put!(c::Channel, v) 的 task）則會被阻塞，直到 Channel 有空餘。
                            # Base.isready(c::Channel) 可以用來檢查一個 channel 中是否有已經準備好的元素，而等待一個元素準備好 則用 Base.wait(r::Future) 函數。
                            # 一個 Channel 一開始處於開啟狀態，也就是說可以被 take! 讀取和 put! 寫入。Base.close(c::Channel[, excp::Exception]) 會關閉一個 Channel，對於一個已經關閉的 Channel，put! 會失敗。
                            # Channel 可以在 for 迴圈中遍歷，此時，迴圈會一直運行直到 Channel 中有資料，遍歷過程中會取遍加入到 Channel 中的所有值。一旦 Channel關閉或者取空了，for 迴圈就會終止。
                            # c = Channel{Int}(10)
                            # foreach(i->put!(c, i), 1:3)
                            # 此時，如果直接用 for 去遍歷通道 c 中的內容，則在讀取完後會一直等待通道(Channel)中有新的資料進來，如果在控制臺REPL上運行，則會停在那裡。
                            # data = [i for i in c]
                            # 如果先把Channel關閉，再用for去遍歷，則會讀出Channel中的內容，因此此時c已經關閉，for不會再等待寫入了。
                            # close(c);
                            # data = [i for i in c]

                            # 使用 Base.bind(chnl::Channel, task::Task) 方法，將通道(Channel)的生存期與任務或叫協程(task)相關聯。當協程(task)終止時，通道(Channel)自動關閉。任務中任何未捕獲的異常都會傳播到通道(Channel)上的所有等待者。
                            # 通道(Channel)對象可以獨立於協程(task)終止顯式關閉。終止協程(task)對已關閉的通道(Channel)對象沒有影響。
                            # 當通道(Channel)綁定到多個協程(task)時，第一個終止的協程(task)將關閉通道(Channel)。當多個通道(Channel)綁定到同一個協程(task)時，協程(task)的終止將關閉所有綁定的通道(Channel)。
                            # task = Base.@async foreach(i->put!(c, i), 1:4);
                            # Base.bind(c,task);
                            # for i in c
                            #     Base.@show i
                            #     println(Base.current_task())
                            # end;
                            # i = 1
                            # i = 2
                            # i = 3
                            # i = 4
                            # Base.isopen(c)
                            # false
                            # c2 = Base.Channel{Core.Float64}(32)  # 創建一個長度爲 32，元素(item)類型爲 Float64 的通道(Channel);
                            # Base.put!(c2, 2)  # 向通道(Channel)中寫入元素;
                            # itme1 = Base.fetch(c2)  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
                            # itme1 = Base.take!(c2)  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                            # Base.close(c2)  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗，take!() 和 fetch() 爲空時，將會關閉這個通道;
                            # Base.isready(c2)

                            # # 用Channel完成多工（多任務 task）之間的資料交互
                            # # 新建兩個Channel，一個是Int型，一個是Tuple型，對於每個任務，延時一段時間後，開始執行該任務的內容，並將結果放入到results中。
                            # const jobs = Channel{Int}(32)
                            # const results = Channel{Tuple}(32)
                            # function do_work()
                            #     for job_id in jobs
                            #         exec_time = rand()
                            #         Base.sleep(exec_time)  # simulates elapsed time doing actual work typically performed externally.
                            #         put!(results, (job_id, exec_time))
                            #     end
                            # end
                            # # 向jobs中放入數據
                            # function make_jobs(n)
                            #     for i in 1:n
                            #         put!(jobs, i)
                            #     end
                            # end
                            # # 寫入12個資料
                            # n = 12
                            # @async make_jobs(n)
                            # # @async表示把後面的運算式放到Task裡，並加入到程式的執行清單中
                            # # 開四個任務來處理
                            # for i in 1:4
                            #     # start 4 tasks to process requests in parallel
                            #     @async do_work()
                            # end
                            # # 取出4個任務的執行結果
                            # @elapsed while n > 0
                            #     # print out results
                            #     job_id, exec_time = take!(results)
                            #     println("$job_id finished in $(round(exec_time; digits=2)) seconds")
                            #     global n = n - 1
                            # end
                            # # >>1 finished in 0.51 seconds
                            # # 4 finished in 0.62 seconds
                            # # 3 finished in 0.75 seconds
                            # # 2 finished in 0.81 seconds
                            # # 5 finished in 0.55 seconds
                            # # 8 finished in 0.35 seconds
                            # # 6 finished in 0.77 seconds
                            # # 9 finished in 0.38 seconds
                            # # 12 finished in 0.11 seconds
                            # # 7 finished in 0.88 seconds
                            # # 11 finished in 0.25 seconds
                            # # 10 finished in 0.75 seconds

                            input_queues_length = Base.length(input_queues_array);

                            # 使用協程(task)創建子協程執行具體動作;
                            for i in 1:input_queues_length

                                if Base.isa(input_queues_array[i], Base.Dict)

                                    # 控制並發數;
                                    # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                                    Base.put!(control_number_Queues_channel, Core.UInt64(i));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                                    worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                        # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[i]["read_file_do_Function"];
                                        "monitor_file" => input_queues_array[i]["monitor_file"],  # monitor_file;
                                        "monitor_dir" => input_queues_array[i]["monitor_dir"],  # monitor_dir;
                                        # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                        "output_dir" => input_queues_array[i]["output_dir"],  # output_dir;
                                        "output_file" => input_queues_array[i]["output_file"],  # output_file，output_queues_array;
                                        "to_executable" => input_queues_array[i]["to_executable"],
                                        "to_script" => input_queues_array[i]["to_script"]
                                    );

                                    # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                                    # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                                    Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                                    # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                                    #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                                    # end

                                    f() = funcTask(do_Function, read_file_do_Function, time_sleep, main_to_sub_channel, sub_to_main_channel, control_number_Queues_channel);
                                    workerTask = Core.Task(f);  # 創建一個協程（任務）task;
                                    workerTask.sticky = false;

                                    # # 保存每個被創建的協程(task)在一個字典中;
                                    # # 使用 Base.objectid(Base.current_task()) 方法返回當前協程（task） ID 號;
                                    # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                    # if Base.haskey(worker_queues_Dict, Base.string(Base.objectid(workerTask)))
                                    #     # global worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                    #     worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                    # else
                                    #     # global worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                    #     worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                    # end
                                    # # 記錄每個綫程纍加的被調用運算的總次數;
                                    # # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                    # if Base.haskey(total_worker_called_number, Base.string(Base.objectid(workerTask)))
                                    #     # global total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(workerTask))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                    #     total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(workerTask))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                    # else
                                    #     # global total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                    #     total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                    # end

                                    Base.schedule(workerTask);  # 用 Base.schedule(t::Task, [val]; error=false) 函數把未啓動的協程(Task)加入等待執行的隊列並啓動，隨後會自動返回 done 狀態，表示已經執行完畢;
                                    # Base.wait(workerTask);  # 阻塞主進程後面的代碼執行，直到該子協程 workerTask 運行完畢;
                                    # 用 istaskstarted(taskname) 和 istaskdone(taskname) 查看 Task 是否已經啓動和結束。Task 有五個狀態：runnable（可被啓動）, waiting（阻塞等待中）, queued（正被調度中）, done（執行結束）, failed（執行異常結束）。Julia 内部有一個調度器，負責維護 task 運行隊列;
                                end
                            end

                            # 讀出輸出通道中子協程(task)返回的結果;
                            # Base.take!(sub_to_main_channel);
                            # 這裏 for 結構本質上是一串自動執行的從通道中取出元素 take!() 的操作，和 take!() 操作一樣會移除元素。當通道 Channel 中元素取為空時，for 結構會阻塞;
                            # 使用 close(channelname) 强制關閉通道 Channel 的入口並釋放所有 put!() 和 take!() 的阻塞，此時 for 循環取完通道 Channel 中元素為空時，將不再阻塞會自行退出;
                            for result_Dict in sub_to_main_channel

                                # 記錄每個協程（Task）纍加的被調用運算的總次數;
                                # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                if Base.haskey(total_worker_called_number, Base.string(result_Dict["taskID"]))
                                    # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                    total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                else
                                    # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                    total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                end

                                if Base.isa(result_Dict, Base.Dict) && Base.haskey(result_Dict, "label") && result_Dict["label"] === "error"

                                    if Base.haskey(result_Dict, "taskID") && result_Dict["taskID"] !== Core.nothing && Base.isa(result_Dict["taskID"], Core.String) && result_Dict["taskID"] !== ""
                                        if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                            println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                            println(result_Dict["message"]);  # error;
                                        else
                                            println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                        end
                                    else
                                        if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                            println("task return error:");
                                            println(result_Dict["message"]);  # error;
                                        else
                                            println("task return error.");
                                        end
                                    end

                                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    # println(Base.string(nowTime));
                                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    # log_text = "error < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["monitor_file"]) * " > < " * Base.string(result_Dict["output_file"]) * " >.";
                                    # print(log_text * "\n");
                                    # log_file = "";  # 日志文檔;
                                    # # 同步寫入用於記錄過程的日志文檔;
                                    # try
                                    #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                    #     # # write(filename::AbstractString, x)
                                    #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                    #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                    #     # println(numBytes);
                                    #     # println(Base.stat(log_file).size);
                                    #     # println(Base.stat(log_file).mtime);
                                    #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #     # println(Base.stat(log_file).ctime);
                                    #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                    #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                    #     # # Base.countlines — Function
                                    #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                    #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                    #     # println(Base.countlines(log_file, eol='\\n'));

                                    #     fWIO = Base.open(log_file, "a+");
                                    #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                    #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                    #     # Keyword	Description				Default
                                    #     # read		open for reading		!write
                                    #     # write		open for writing		truncate | append
                                    #     # create	create if non-existent	!read & write | truncate | append
                                    #     # truncate	truncate to zero size	!read & write
                                    #     # append	seek to end				false

                                    #     # Mode	Description						Keywords
                                    #     # r		read							none
                                    #     # w		write, create, truncate			write = true
                                    #     # a		write, create, append			append = true
                                    #     # r+	read, write						read = true, write = true
                                    #     # w+	read, write, create, truncate	truncate = true, read = true
                                    #     # a+	read, write, create, append		append = true, read = true

                                    #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                    #     if Base.iswritable(fWIO)
                                    #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                    #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                    #         println(numBytes);
                                    #         println(Base.stat(log_file).size);
                                    #         println(Base.stat(log_file).mtime);
                                    #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #         println(Base.stat(log_file).ctime);
                                    #         # Base.displaysize([io::IO]) -> (lines, columns)
                                    #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                    #         # Base.countlines — Function
                                    #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                    #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                    #         println(Base.countlines(log_file, eol='\\n'));
                                    #     end

                                    #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                                    #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                                    #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                    #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                    #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                    #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                    #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                    #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                    #     # Base.ismarked(io);  # Return true if stream s is marked;
                                    #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                    #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                    #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                    #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                    #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                    #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                    #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                    #     # Base.close(io);  # 關閉緩衝區;
                                    #     # println(a)
                                    #     # Base.redirect_stdout — Function
                                    #     # redirect_stdout([stream]) -> (rd, wr)
                                    #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                    #     # If called with the optional stream argument, then returns stream itself.
                                    #     # Base.redirect_stdout — Method
                                    #     # redirect_stdout(f::Function, stream)
                                    #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                    #     # Base.redirect_stderr — Function
                                    #     # redirect_stderr([stream]) -> (rd, wr)
                                    #     # Like redirect_stdout, but for stderr.
                                    #     # Base.redirect_stderr — Method
                                    #     # redirect_stderr(f::Function, stream)
                                    #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                    #     # Base.redirect_stdin — Function
                                    #     # redirect_stdin([stream]) -> (rd, wr)
                                    #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                    #     # Base.redirect_stdin — Method
                                    #     # redirect_stdin(f::Function, stream)
                                    #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                    # catch err
                                    #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                    #     println(err);
                                    #     # println(Base.typeof(err));

                                    #     # Julia提供了許多類型的錯誤：
                                    #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                                    #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                                    #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                                    #     # DivideError：這是數字除以0時的結果。
                                    #     # DomainError：有效域之外的參數。
                                    #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                                    #     # InexactError：嘗試進行精確類型轉換失敗。
                                    #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                                    #     # LoadError：載入檔時發生錯誤。
                                    #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                                    #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                                    #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                                    #     # OverflowError：當操作結果太大時會發生這種情況。
                                    #     # ParseError：解析給定運算式時出現問題。
                                    #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                                    #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                                    #     # UndefRefError：未知引用。
                                    #     # UndefVarError：對不存在的變數進行未知引用。
                                    #     # InitError：調用模組的init方法時出現此錯誤。
                                    #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                                    #     # NullException：嘗試訪問Null值
                                    #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                                    #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                    # finally
                                    #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                    #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                    #     if Base.eof(fWIO)
                                    #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                    #     end
                                    # end
                                end

                                if Base.isa(result_Dict, Base.Dict) && Base.haskey(result_Dict, "label") && result_Dict["label"] === "success"

                                    # 判斷用於輸出的臨時暫存媒介文檔是否創建成功，如果創建成功，則修改文檔權限;
                                    # result_Dict["output_file"] === input_queues_array[1]["output_file"] === temp_output_file === output_queues_array[1]["output_file"];
                                    if Base.Filesystem.ispath(result_Dict["output_file"]) && Base.Filesystem.isfile(result_Dict["output_file"])
                                        if Base.stat(result_Dict["output_file"]).mode !== Core.UInt64(33206) && Base.stat(result_Dict["output_file"]).mode !== Core.UInt64(33279)
                                            # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(result_Dict["output_file"]) 函數讀取文檔信息，使用 Base.stat(result_Dict["output_file"]).mode 方法提取文檔權限碼;
                                            # println("用於傳出數據的臨時暫存媒介文檔 [ " * result_Dict["output_file"] * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                            try
                                                # 使用 Base.Filesystem.chmod(result_Dict["output_file"], mode=0o777; recursive=false) 函數修改文檔操作權限;
                                                # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                                Base.Filesystem.chmod(result_Dict["output_file"], mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                                # println("文檔: " * result_Dict["output_file"] * " 操作權限成功修改爲 mode=0o777 .");

                                                # 八進制值    說明
                                                # 0o400      所有者可讀
                                                # 0o200      所有者可寫
                                                # 0o100      所有者可執行或搜索
                                                # 0o40       群組可讀
                                                # 0o20       群組可寫
                                                # 0o10       群組可執行或搜索
                                                # 0o4        其他人可讀
                                                # 0o2        其他人可寫
                                                # 0o1        其他人可執行或搜索
                                                # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                                # 數字	說明
                                                # 7	可讀、可寫、可執行
                                                # 6	可讀、可寫
                                                # 5	可讀、可執行
                                                # 4	唯讀
                                                # 3	可寫、可執行
                                                # 2	只寫
                                                # 1	只可執行
                                                # 0	沒有許可權
                                                # 例如，八進制值 0o765 表示：
                                                # 1) 、所有者可以讀取、寫入和執行該文檔；
                                                # 2) 、群組可以讀和寫入該文檔；
                                                # 3) 、其他人可以讀取和執行該文檔；
                                                # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                                # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                            catch err
                                                println("用於傳出數據的臨時暫存媒介文檔: " * result_Dict["output_file"] * " 無法修改操作權限爲 mode=0o777 .");
                                                println(err);
                                                # println(err.msg);
                                                # println(Base.typeof(err));
                                                # return ["error", result_Dict["output_file"], "document [ temp_output_file = " * Base.string(result_Dict["output_file"]) * " ] change the permissions mode=0o777 fail."];
                                            end
                                        end
                                    else
                                        println("用於傳出數據的臨時暫存媒介文檔: " * result_Dict["output_file"] * " 無法被創建.");
                                        # return ["error", result_Dict["output_file"], "document [ temp_output_file = " * Base.string(result_Dict["output_file"]) * " ] not create."];
                                    end

                                    result_Data = Base.Dict{Core.String, Core.Any}(
                                        # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                                        "monitor_file" => result_Dict["monitor_file"],  # temp_monitor_file，monitor_file，input_queues_array[1]["monitor_file"];
                                        "monitor_dir" => result_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir，input_queues_array[1]["monitor_dir"];
                                        # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                                        "output_dir" => result_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir，input_queues_array[1]["output_dir"];
                                        "output_file" => result_Dict["output_file"],  # temp_output_file，output_file，output_queues_array，input_queues_array[1]["output_file"];
                                        "to_executable" => result_Dict["to_executable"],  # to_executable，input_queues_array[1]["to_executable"];
                                        "to_script" => result_Dict["to_script"],  # to_script，input_queues_array[1]["to_script"];
                                        "processID" => result_Dict["processID"],  # Base.string(Distributed.myid()),  # 子進程 ID;
                                        "threadID" => result_Dict["threadID"],  # Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                        "taskID" => result_Dict["taskID"],  # Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                        "time" => result_Dict["time"]  # Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    );

                                    # global output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                                    output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                                    # println(output_queues_array);
                                    # println(length(output_queues_array));

                                    # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 是否仍然存在，如果仍存在，則將用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 同步從硬盤刪除;
                                    # result_Dict["monitor_file"] === input_queues_array[1]["monitor_file"] === temp_monitor_file === output_queues_array[1]["monitor_file"];
                                    if Base.Filesystem.ispath(result_Dict["monitor_file"]) && Base.Filesystem.isfile(result_Dict["monitor_file"])
                                        # 讀取到輸入數據之後，同步刪除，用於接收傳值的媒介文檔;
                                        try
                                            # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                                            # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                            Base.Filesystem.rm(result_Dict["monitor_file"], force=true, recursive=false);  # 刪除給定路徑下的文檔、鏈接或空目錄，如果傳遞參數 force=true 時，則不存在的路徑不被視爲錯誤，如果傳遞參數 recursive=true 并且路徑是目錄時，則遞歸刪除所有内容;
                                            # Base.Filesystem.rm(path::AbstractString, force::Bool=false, recursive::Bool=false)
                                            # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                            # println("媒介文檔: " * result_Dict["monitor_file"] * " 已被刪除.");
                                        catch err
                                            println("用於傳入數據的臨時暫存媒介文檔: " * result_Dict["monitor_file"] * " 無法刪除.");
                                            println(err);
                                            # println(err.msg);
                                            # println(Base.typeof(err));
                                            # return ["error", result_Dict["monitor_file"], "document [ temp_monitor_file = " * Base.string(result_Dict["monitor_file"]) * " ] not delete."];
                                        end

                                        # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                                        # # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 在已處理完數據後，是否已經從硬盤刪除;
                                        # if Base.Filesystem.ispath(result_Dict["monitor_file"]) && Base.Filesystem.isfile(result_Dict["monitor_file"])
                                        #     println("用於傳入數據的臨時暫存媒介文檔: " * result_Dict["monitor_file"] * " 無法刪除.");
                                        #     # return ["error", result_Dict["monitor_file"], "document [ temp_monitor_file = " * Base.string(result_Dict["monitor_file"]) * " ] not delete."];
                                        # end
                                    end

                                    result_Data = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                    # Base.GC.gc();  # 内存回收函數 gc();

                                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    # println(Base.string(nowTime));
                                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    # log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["monitor_file"]) * " > < " * Base.string(result_Dict["output_file"]) * " >.";
                                    # print(log_text * "\n");
                                    # log_file = "";  # 日志文檔;
                                    # # 同步寫入用於記錄過程的日志文檔;
                                    # try
                                    #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                    #     # # write(filename::AbstractString, x)
                                    #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                    #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                    #     # println(numBytes);
                                    #     # println(Base.stat(log_file).size);
                                    #     # println(Base.stat(log_file).mtime);
                                    #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #     # println(Base.stat(log_file).ctime);
                                    #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                    #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                    #     # # Base.countlines — Function
                                    #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                    #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                    #     # println(Base.countlines(log_file, eol='\\n'));

                                    #     fWIO = Base.open(log_file, "a+");
                                    #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                    #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                    #     # Keyword	Description				Default
                                    #     # read		open for reading		!write
                                    #     # write		open for writing		truncate | append
                                    #     # create	create if non-existent	!read & write | truncate | append
                                    #     # truncate	truncate to zero size	!read & write
                                    #     # append	seek to end				false

                                    #     # Mode	Description						Keywords
                                    #     # r		read							none
                                    #     # w		write, create, truncate			write = true
                                    #     # a		write, create, append			append = true
                                    #     # r+	read, write						read = true, write = true
                                    #     # w+	read, write, create, truncate	truncate = true, read = true
                                    #     # a+	read, write, create, append		append = true, read = true

                                    #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                    #     if Base.iswritable(fWIO)
                                    #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                    #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                    #         println(numBytes);
                                    #         println(Base.stat(log_file).size);
                                    #         println(Base.stat(log_file).mtime);
                                    #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #         println(Base.stat(log_file).ctime);
                                    #         # Base.displaysize([io::IO]) -> (lines, columns)
                                    #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                    #         # Base.countlines — Function
                                    #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                    #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                    #         println(Base.countlines(log_file, eol='\\n'));
                                    #     end

                                    #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                                    #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                                    #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                    #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從���衝區取出的數據强制轉換爲字符串類型;
                                    #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                    #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                    #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                    #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                    #     # Base.ismarked(io);  # Return true if stream s is marked;
                                    #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                    #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                    #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                    #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                    #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                    #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                    #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                    #     # Base.close(io);  # 關閉緩衝區;
                                    #     # println(a)
                                    #     # Base.redirect_stdout — Function
                                    #     # redirect_stdout([stream]) -> (rd, wr)
                                    #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                    #     # If called with the optional stream argument, then returns stream itself.
                                    #     # Base.redirect_stdout — Method
                                    #     # redirect_stdout(f::Function, stream)
                                    #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                    #     # Base.redirect_stderr — Function
                                    #     # redirect_stderr([stream]) -> (rd, wr)
                                    #     # Like redirect_stdout, but for stderr.
                                    #     # Base.redirect_stderr — Method
                                    #     # redirect_stderr(f::Function, stream)
                                    #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                    #     # Base.redirect_stdin — Function
                                    #     # redirect_stdin([stream]) -> (rd, wr)
                                    #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                    #     # Base.redirect_stdin — Method
                                    #     # redirect_stdin(f::Function, stream)
                                    #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                    # catch err
                                    #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                    #     println(err);
                                    #     # println(Base.typeof(err));
                                    #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                    # finally
                                    #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                    #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                    #     if Base.eof(fWIO)
                                    #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                    #     end
                                    # end
                                end

                                # 使用 Base.isready(c::Channel) 函數判斷通道中元素是否已經取空，如果已經取空 Base.isready(c::Channel) 返回為 false 值，則跳出 for 循環，如果一個空通道從未寫入過元素，則 Base.isready(sub_to_main_channel) 值爲 true，因此會一直阻塞等待不會跳出循環;
                                if !Base.isready(sub_to_main_channel)
                                    break;
                                end
                            end

                            # 刪除任務隊列數組中前面已經處理過的任務元素;
                            for i in 1:input_queues_length
                                # global input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                                input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                            end
                        end

                        if Base.string(isDoTasksOrThreads) === Base.string("Multi-Threading")

                            # 必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
                            # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
                            # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
                            # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
                            # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;

                            # 通道、管道(Channel);
                            # Base.Channel{T=Any}(size::Int=0);
                            # 如果一個 Channel 是空的，讀取的 task（即執行 v = Base.take!(c::Channel) 的 task）會被阻塞直到有新的資料準備好了。
                            # 如果一個 Channel 是滿的，那麼寫入的 task（即執行 Base.put!(c::Channel, v) 的 task）則會被阻塞，直到 Channel 有空餘。
                            # Base.isready(c::Channel) 可以用來檢查一個 channel 中是否有已經準備好的元素，而等待一個元素準備好 則用 Base.wait(r::Future) 函數。
                            # 一個 Channel 一開始處於開啟狀態，也就是說可以被 take! 讀取和 put! 寫入。Base.close(c::Channel[, excp::Exception]) 會關閉一個 Channel，對於一個已經關閉的 Channel，put! 會失敗。
                            # Channel 可以在 for 迴圈中遍歷，此時，迴圈會一直運行直到 Channel 中有資料，遍歷過程中會取遍加入到 Channel 中的所有值。一旦 Channel關閉或者取空了，for 迴圈就會終止。
                            # c = Channel{Int}(10)
                            # foreach(i->put!(c, i), 1:3)
                            # 此時，如果直接用 for 去遍歷通道 c 中的內容，則在讀取完後會一直等待通道(Channel)中有新的資料進來，如果在控制臺REPL上運行，則會停在那裡。
                            # data = [i for i in c]
                            # 如果先把Channel關閉，再用for去遍歷，則會讀出Channel中的內容，因此此時c已經關閉，for不會再等待寫入了。
                            # close(c);
                            # data = [i for i in c]

                            # 使用 Base.bind(chnl::Channel, task::Task) 方法，將通道(Channel)的生存期與任務或叫協程(task)相關聯。當協程(task)終止時，通道(Channel)自動關閉。任務中任何未捕獲的異常都會傳播到通道(Channel)上的所有等待者。
                            # 通道(Channel)對象可以獨立於協程(task)終止顯式關閉。終止協程(task)對已關閉的通道(Channel)對象沒有影響。
                            # 當通道(Channel)綁定到多個協程(task)時，第一個終止的協程(task)將關閉通道(Channel)。當多個通道(Channel)綁定到同一個協程(task)時，協程(task)的終止將關閉所有綁定的通道(Channel)。
                            # task = Base.@async foreach(i->put!(c, i), 1:4);
                            # Base.bind(c,task);
                            # for i in c
                            #     Base.@show i
                            #     println(Base.current_task())
                            # end;
                            # i = 1
                            # i = 2
                            # i = 3
                            # i = 4
                            # Base.isopen(c)
                            # false
                            # c2 = Base.Channel{Core.Float64}(32)  # 創建一個長度爲 32，元素(item)類型爲 Float64 的通道(Channel);
                            # Base.put!(c2, 2)  # 向通道(Channel)中寫入元素;
                            # itme1 = Base.fetch(c2)  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
                            # itme1 = Base.take!(c2)  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                            # Base.close(c2)  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗，take!() 和 fetch() 爲空時，將會關閉這個通道;
                            # Base.isready(c2)

                            # # 用Channel完成多工（多任務 task）之間的資料交互
                            # # 新建兩個Channel，一個是Int型，一個是Tuple型，對於每個任務，延時一段時間後，開始執行該任務的內容，並將結果放入到results中。
                            # const jobs = Channel{Int}(32)
                            # const results = Channel{Tuple}(32)
                            # function do_work()
                            #     for job_id in jobs
                            #         exec_time = rand()
                            #         Base.sleep(exec_time)  # simulates elapsed time doing actual work typically performed externally.
                            #         put!(results, (job_id, exec_time))
                            #     end
                            # end
                            # # 向jobs中放入數據
                            # function make_jobs(n)
                            #     for i in 1:n
                            #         put!(jobs, i)
                            #     end
                            # end
                            # # 寫入12個資料
                            # n = 12
                            # @async make_jobs(n)
                            # # @async表示把後面的運算式放到Task裡，並加入到程式的執行清單中
                            # # 開四個任務來處理
                            # for i in 1:4
                            #     # start 4 tasks to process requests in parallel
                            #     @async do_work()
                            # end
                            # # 取出4個任務的執行結果
                            # @elapsed while n > 0
                            #     # print out results
                            #     job_id, exec_time = take!(results)
                            #     println("$job_id finished in $(round(exec_time; digits=2)) seconds")
                            #     global n = n - 1
                            # end
                            # # >>1 finished in 0.51 seconds
                            # # 4 finished in 0.62 seconds
                            # # 3 finished in 0.75 seconds
                            # # 2 finished in 0.81 seconds
                            # # 5 finished in 0.55 seconds
                            # # 8 finished in 0.35 seconds
                            # # 6 finished in 0.77 seconds
                            # # 9 finished in 0.38 seconds
                            # # 12 finished in 0.11 seconds
                            # # 7 finished in 0.88 seconds
                            # # 11 finished in 0.25 seconds
                            # # 10 finished in 0.75 seconds

                            input_queues_length = Base.length(input_queues_array);

                            # Base.Threads.@spawn expr
                            # Create and run a Task on any available thread. To wait for the task to finish, call wait on the result of this macro, or call fetch to wait and then obtain its return value.
                            # 使用 Base.Threads.@spawn 方法創建一個子綫程執行具體動作;
                            for i in 1:input_queues_length

                                if Base.isa(input_queues_array[i], Base.Dict)

                                    # 控制並發數;
                                    # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                                    Base.put!(control_number_Queues_channel, Core.UInt64(i));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                                    worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                        # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[i]["read_file_do_Function"];
                                        "monitor_file" => input_queues_array[i]["monitor_file"],  # monitor_file;
                                        "monitor_dir" => input_queues_array[i]["monitor_dir"],  # monitor_dir;
                                        # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                        "output_dir" => input_queues_array[i]["output_dir"],  # output_dir;
                                        "output_file" => input_queues_array[i]["output_file"],  # output_file，output_queues_array;
                                        "to_executable" => input_queues_array[i]["to_executable"],
                                        "to_script" => input_queues_array[i]["to_script"]
                                    );

                                    # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                                    # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                                    Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                                    # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                                    #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                                    # end

                                    # 創建一個子綫程（worker thread）;
                                    # workerThread = Base.Threads.@spawn begin
                                    #     funcTask(do_Function, read_file_do_Function, time_sleep, main_to_sub_channel, sub_to_main_channel, control_number_Queues_channel);
                                    # end
                                    workerThread = Base.Threads.@spawn funcTask(do_Function, read_file_do_Function, time_sleep, main_to_sub_channel, sub_to_main_channel, control_number_Queues_channel);
                                    # r = Base.fetch(workerThread);  # 等待讀取子綫程運行完畢後的返回值，阻塞後面的代碼執行;
                                    # Base.wait(workerThread);  # 阻塞主進程後面的代碼執行，直到該子綫程 workerThread 運行完畢;

                                    # # 保存每個被創建的綫程（worker thread）在一個字典中;
                                    # # 使用 Base.Threads.threadid() 方法返回當前綫程 ID 號;
                                    # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                    # if Base.haskey(worker_queues_Dict, Base.string(Base.Threads.threadid(workerThread)))
                                    #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                    #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                    # else
                                    #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                    #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                    # end
                                    # # 記錄每個綫程纍加的被調用運算的總次數;
                                    # # 使用 Base.Threads.threadid() 方法返回當前子綫程(thread) ID 號;
                                    # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                    # if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid(workerThread)))
                                    #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                    #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                    # else
                                    #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                    #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                    # end
                                end
                            end

                            # # Base.Threads.@threads for...end
                            # # A macro to parallelize a for-loop to run with multiple threads. This spawns nthreads() number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.
                            # # 使用 Base.Threads.@threads for...end 方法創建子綫程，多綫程并發執行 for...end 循環，在每次 for 循環中具體動作;
                            # Base.Threads.@threads for i in 1:input_queues_length

                            #     if Base.isa(input_queues_array[i], Base.Dict)

                            #         # 控制並發數;
                            #         # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                            #         Base.put!(control_number_Queues_channel, Core.UInt64(i));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                            #         worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                            #             # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[i]["read_file_do_Function"];
                            #             "monitor_file" => input_queues_array[i]["monitor_file"],  # monitor_file;
                            #             "monitor_dir" => input_queues_array[i]["monitor_dir"],  # monitor_dir;
                            #             # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                            #             "output_dir" => input_queues_array[i]["output_dir"],  # output_dir;
                            #             "output_file" => input_queues_array[i]["output_file"],  # output_file，output_queues_array;
                            #             "to_executable" => input_queues_array[i]["to_executable"],
                            #             "to_script" => input_queues_array[i]["to_script"]
                            #         );

                            #         # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                            #         # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                            #         Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                            #         # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                            #         #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                            #         # end

                            #         resultArray = funcTask(do_Function, read_file_do_Function, time_sleep, main_to_sub_channel, sub_to_main_channel, control_number_Queues_channel);
                            #         # println(resultArray);

                            #         # # 保存每個被創建的綫程（worker thread）在一個字典中;
                            #         # # 使用 Base.Threads.threadid() 方法返回當前綫程 ID 號;
                            #         # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                            #         # if Base.haskey(worker_queues_Dict, Base.string(Base.Threads.threadid(workerThread)))
                            #         #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                            #         #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                            #         # else
                            #         #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                            #         #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                            #         # end
                            #         # # 記錄每個綫程纍加的被調用運算的總次數;
                            #         # # 使用 Base.Threads.threadid() 方法返回當前子綫程(thread) ID 號;
                            #         # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                            #         # if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid(workerThread)))
                            #         #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                            #         #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                            #         # else
                            #         #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            #         #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            #         # end
                            #     end
                            # end

                            # 讀出輸出通道中子綫程(worker thread)返回的結果;
                            # Base.take!(sub_to_main_channel);
                            # 這裏 for 結構本質上是一串自動執行的從通道中取出元素 take!() 的操作，和 take!() 操作一樣會移除元素。當通道 Channel 中元素取為空時，for 結構會阻塞;
                            # 使用 close(channelname) 强制關閉通道 Channel 的入口並釋放所有 put!() 和 take!() 的阻塞，此時 for 循環取完通道 Channel 中元素為空時，將不再阻塞會自行退出;
                            for result_Dict in sub_to_main_channel

                                # 記錄每個綫程纍加的被調用運算的總次數;
                                # 使用 Base.Threads.threadid() 方法返回當前子綫程(thread) ID 號;
                                # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                if Base.haskey(total_worker_called_number, Base.string(result_Dict["threadID"]))
                                    # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                    total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                else
                                    # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                    total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                end

                                if Base.isa(result_Dict, Base.Dict) && Base.haskey(result_Dict, "label") && result_Dict["label"] === "error"

                                    if Base.haskey(result_Dict, "threadID") && result_Dict["threadID"] !== Core.nothing && Base.isa(result_Dict["threadID"], Core.String) && result_Dict["threadID"] !== ""
                                        if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                            println("worker thread-" * Base.string(result_Dict["threadID"]) * " return error:");
                                            println(result_Dict["message"]);  # error;
                                        else
                                            println("worker thread-" * Base.string(result_Dict["threadID"]) * " return error:");
                                        end
                                    else
                                        if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                            println("worker thread return error:");
                                            println(result_Dict["message"]);  # error;
                                        else
                                            println("worker thread return error.");
                                        end
                                    end

                                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    # println(Base.string(nowTime));
                                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    # log_text = "error < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["monitor_file"]) * " > < " * Base.string(result_Dict["output_file"]) * " >.";
                                    # print(log_text * "\n");
                                    # log_file = "";  # 日志文檔;
                                    # # 同步寫入用於記錄過程的日志文檔;
                                    # try
                                    #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                    #     # # write(filename::AbstractString, x)
                                    #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                    #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                    #     # println(numBytes);
                                    #     # println(Base.stat(log_file).size);
                                    #     # println(Base.stat(log_file).mtime);
                                    #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #     # println(Base.stat(log_file).ctime);
                                    #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                    #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                    #     # # Base.countlines — Function
                                    #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                    #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                    #     # println(Base.countlines(log_file, eol='\\n'));

                                    #     fWIO = Base.open(log_file, "a+");
                                    #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                    #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                    #     # Keyword	Description				Default
                                    #     # read		open for reading		!write
                                    #     # write		open for writing		truncate | append
                                    #     # create	create if non-existent	!read & write | truncate | append
                                    #     # truncate	truncate to zero size	!read & write
                                    #     # append	seek to end				false

                                    #     # Mode	Description						Keywords
                                    #     # r		read							none
                                    #     # w		write, create, truncate			write = true
                                    #     # a		write, create, append			append = true
                                    #     # r+	read, write						read = true, write = true
                                    #     # w+	read, write, create, truncate	truncate = true, read = true
                                    #     # a+	read, write, create, append		append = true, read = true

                                    #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                    #     if Base.iswritable(fWIO)
                                    #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                    #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                    #         println(numBytes);
                                    #         println(Base.stat(log_file).size);
                                    #         println(Base.stat(log_file).mtime);
                                    #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #         println(Base.stat(log_file).ctime);
                                    #         # Base.displaysize([io::IO]) -> (lines, columns)
                                    #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                    #         # Base.countlines — Function
                                    #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                    #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                    #         println(Base.countlines(log_file, eol='\\n'));
                                    #     end

                                    #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                                    #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                                    #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                    #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                    #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                    #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                    #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                    #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                    #     # Base.ismarked(io);  # Return true if stream s is marked;
                                    #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                    #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                    #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                    #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                    #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                    #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                    #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                    #     # Base.close(io);  # 關閉緩衝區;
                                    #     # println(a)
                                    #     # Base.redirect_stdout — Function
                                    #     # redirect_stdout([stream]) -> (rd, wr)
                                    #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                    #     # If called with the optional stream argument, then returns stream itself.
                                    #     # Base.redirect_stdout — Method
                                    #     # redirect_stdout(f::Function, stream)
                                    #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                    #     # Base.redirect_stderr — Function
                                    #     # redirect_stderr([stream]) -> (rd, wr)
                                    #     # Like redirect_stdout, but for stderr.
                                    #     # Base.redirect_stderr — Method
                                    #     # redirect_stderr(f::Function, stream)
                                    #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                    #     # Base.redirect_stdin — Function
                                    #     # redirect_stdin([stream]) -> (rd, wr)
                                    #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                    #     # Base.redirect_stdin — Method
                                    #     # redirect_stdin(f::Function, stream)
                                    #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                    # catch err
                                    #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                    #     println(err);
                                    #     # println(Base.typeof(err));

                                    #     # Julia提供了許多類型的錯誤：
                                    #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                                    #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                                    #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                                    #     # DivideError：這是數字除以0時的結果。
                                    #     # DomainError：有效域之外的參數。
                                    #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                                    #     # InexactError：嘗試進行精確類型轉換失敗。
                                    #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                                    #     # LoadError：載入檔時發生錯誤。
                                    #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                                    #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                                    #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                                    #     # OverflowError：當操作結果太大時會發生這種情況。
                                    #     # ParseError：解析給定運算式時出現問題。
                                    #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                                    #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                                    #     # UndefRefError：未知引用。
                                    #     # UndefVarError：對不存在的變數進行未知引用。
                                    #     # InitError：調用模組的init方法時出現此錯誤。
                                    #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                                    #     # NullException：嘗試訪問Null值
                                    #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                                    #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                    # finally
                                    #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                    #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                    #     if Base.eof(fWIO)
                                    #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                    #     end
                                    # end
                                end

                                if Base.isa(result_Dict, Base.Dict) && Base.haskey(result_Dict, "label") && result_Dict["label"] === "success"

                                    # 判斷用於輸出的臨時暫存媒介文檔是否創建成功，如果創建成功，則修改文檔權限;
                                    # result_Dict["output_file"] === input_queues_array[1]["output_file"] === temp_output_file === output_queues_array[1]["output_file"];
                                    if Base.Filesystem.ispath(result_Dict["output_file"]) && Base.Filesystem.isfile(result_Dict["output_file"])
                                        if Base.stat(result_Dict["output_file"]).mode !== Core.UInt64(33206) && Base.stat(result_Dict["output_file"]).mode !== Core.UInt64(33279)
                                            # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(result_Dict["output_file"]) 函數讀取文檔信息，使用 Base.stat(result_Dict["output_file"]).mode 方法提取文檔權限碼;
                                            # println("用於傳出數據的臨時暫存媒介文檔 [ " * result_Dict["output_file"] * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                            try
                                                # 使用 Base.Filesystem.chmod(result_Dict["output_file"], mode=0o777; recursive=false) 函數修改文檔操作權限;
                                                # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                                Base.Filesystem.chmod(result_Dict["output_file"], mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                                # println("文檔: " * result_Dict["output_file"] * " 操作權限成功修改爲 mode=0o777 .");

                                                # 八進制值    說明
                                                # 0o400      所有者可讀
                                                # 0o200      所有者可寫
                                                # 0o100      所有者可執行或搜索
                                                # 0o40       群組可讀
                                                # 0o20       群組可寫
                                                # 0o10       群組可執行或搜索
                                                # 0o4        其他人可讀
                                                # 0o2        其他人可寫
                                                # 0o1        其他人可執行或搜索
                                                # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                                # 數字	說明
                                                # 7	可讀、可寫、可執行
                                                # 6	可讀、可寫
                                                # 5	可讀、可執行
                                                # 4	唯讀
                                                # 3	可寫、可執行
                                                # 2	只寫
                                                # 1	只可執行
                                                # 0	沒有許可權
                                                # 例如，八進制值 0o765 表示：
                                                # 1) 、所有者可以讀取、寫入和執行該文檔；
                                                # 2) 、群組可以讀和寫入該文檔；
                                                # 3) 、其他人可以讀取和執行該文檔；
                                                # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                                # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                            catch err
                                                println("用於傳出數據的臨時暫存媒介文檔: " * result_Dict["output_file"] * " 無法修改操作權限爲 mode=0o777 .");
                                                println(err);
                                                # println(err.msg);
                                                # println(Base.typeof(err));
                                                # return ["error", result_Dict["output_file"], "document [ temp_output_file = " * Base.string(result_Dict["output_file"]) * " ] change the permissions mode=0o777 fail."];
                                            end
                                        end
                                    else
                                        println("用於傳出數據的臨時暫存媒介文檔: " * result_Dict["output_file"] * " 無法被創建.");
                                        # return ["error", result_Dict["output_file"], "document [ temp_output_file = " * Base.string(result_Dict["output_file"]) * " ] not create."];
                                    end

                                    result_Data = Base.Dict{Core.String, Core.Any}(
                                        # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                                        "monitor_file" => result_Dict["monitor_file"],  # temp_monitor_file，monitor_file，input_queues_array[1]["monitor_file"];
                                        "monitor_dir" => result_Dict["monitor_dir"],  # temp_cache_IO_data_dir，monitor_dir，input_queues_array[1]["monitor_dir"];
                                        # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                                        "output_dir" => result_Dict["output_dir"],  # temp_cache_IO_data_dir，output_dir，input_queues_array[1]["output_dir"];
                                        "output_file" => result_Dict["output_file"],  # temp_output_file，output_file，output_queues_array，input_queues_array[1]["output_file"];
                                        "to_executable" => result_Dict["to_executable"],  # to_executable，input_queues_array[1]["to_executable"];
                                        "to_script" => result_Dict["to_script"],  # to_script，input_queues_array[1]["to_script"];
                                        "processID" => result_Dict["processID"],  # Base.string(Distributed.myid()),  # 子進程 ID;
                                        "threadID" => result_Dict["threadID"],  # Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                        "taskID" => result_Dict["taskID"],  # Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                        "time" => result_Dict["time"]  # Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    );

                                    # global output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                                    output_queues_array = Base.push!(output_queues_array, result_Data);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                                    # println(output_queues_array);
                                    # println(length(output_queues_array));

                                    # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 是否仍然存在，如果仍存在，則將用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 同步從硬盤刪除;
                                    # result_Dict["monitor_file"] === input_queues_array[1]["monitor_file"] === temp_monitor_file === output_queues_array[1]["monitor_file"];
                                    if Base.Filesystem.ispath(result_Dict["monitor_file"]) && Base.Filesystem.isfile(result_Dict["monitor_file"])
                                        # 讀取到輸入數據之後，同步刪除，用於接收傳值的媒介文檔;
                                        try
                                            # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                                            # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                            Base.Filesystem.rm(result_Dict["monitor_file"], force=true, recursive=false);  # 刪除給定路徑下的文檔、鏈接或空目錄，如果傳遞參數 force=true 時，則不存在的路徑不被視爲錯誤，如果傳遞參數 recursive=true 并且路徑是目錄時，則遞歸刪除所有内容;
                                            # Base.Filesystem.rm(path::AbstractString, force::Bool=false, recursive::Bool=false)
                                            # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                                            # println("媒介文檔: " * result_Dict["monitor_file"] * " 已被刪除.");
                                        catch err
                                            println("用於傳入數據的臨時暫存媒介文檔: " * result_Dict["monitor_file"] * " 無法刪除.");
                                            println(err);
                                            # println(err.msg);
                                            # println(Base.typeof(err));
                                            # return ["error", result_Dict["monitor_file"], "document [ temp_monitor_file = " * Base.string(result_Dict["monitor_file"]) * " ] not delete."];
                                        end

                                        # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                                        # # 判斷用於傳入數據的臨時媒介文檔序列第一位 input_queues_array[1]["monitor_file"] 在已處理完數據後，是否已經從硬盤刪除;
                                        # if Base.Filesystem.ispath(result_Dict["monitor_file"]) && Base.Filesystem.isfile(result_Dict["monitor_file"])
                                        #     println("用於傳入數據的臨時暫存媒介文檔: " * result_Dict["monitor_file"] * " 無法刪除.");
                                        #     # return ["error", result_Dict["monitor_file"], "document [ temp_monitor_file = " * Base.string(result_Dict["monitor_file"]) * " ] not delete."];
                                        # end
                                    end

                                    result_Data = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                    # Base.GC.gc();  # 内存回收函數 gc();

                                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    # println(Base.string(nowTime));
                                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    # log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["monitor_file"]) * " > < " * Base.string(result_Dict["output_file"]) * " >.";
                                    # print(log_text * "\n");
                                    # log_file = "";  # 日志文檔;
                                    # # 同步寫入用於記錄過程的日志文檔;
                                    # try
                                    #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                    #     # # write(filename::AbstractString, x)
                                    #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                    #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                    #     # println(numBytes);
                                    #     # println(Base.stat(log_file).size);
                                    #     # println(Base.stat(log_file).mtime);
                                    #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #     # println(Base.stat(log_file).ctime);
                                    #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                    #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                    #     # # Base.countlines — Function
                                    #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                    #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                    #     # println(Base.countlines(log_file, eol='\\n'));

                                    #     fWIO = Base.open(log_file, "a+");
                                    #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                    #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                    #     # Keyword	Description				Default
                                    #     # read		open for reading		!write
                                    #     # write		open for writing		truncate | append
                                    #     # create	create if non-existent	!read & write | truncate | append
                                    #     # truncate	truncate to zero size	!read & write
                                    #     # append	seek to end				false

                                    #     # Mode	Description						Keywords
                                    #     # r		read							none
                                    #     # w		write, create, truncate			write = true
                                    #     # a		write, create, append			append = true
                                    #     # r+	read, write						read = true, write = true
                                    #     # w+	read, write, create, truncate	truncate = true, read = true
                                    #     # a+	read, write, create, append		append = true, read = true

                                    #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                    #     if Base.iswritable(fWIO)
                                    #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                    #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                    #         println(numBytes);
                                    #         println(Base.stat(log_file).size);
                                    #         println(Base.stat(log_file).mtime);
                                    #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #         println(Base.stat(log_file).ctime);
                                    #         # Base.displaysize([io::IO]) -> (lines, columns)
                                    #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                    #         # Base.countlines — Function
                                    #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                    #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                    #         println(Base.countlines(log_file, eol='\\n'));
                                    #     end

                                    #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                                    #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                                    #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                    #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                    #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                    #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                    #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                    #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                    #     # Base.ismarked(io);  # Return true if stream s is marked;
                                    #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                    #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                    #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                    #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                    #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                    #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                    #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                    #     # Base.close(io);  # 關閉緩衝區;
                                    #     # println(a)
                                    #     # Base.redirect_stdout — Function
                                    #     # redirect_stdout([stream]) -> (rd, wr)
                                    #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                    #     # If called with the optional stream argument, then returns stream itself.
                                    #     # Base.redirect_stdout — Method
                                    #     # redirect_stdout(f::Function, stream)
                                    #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                    #     # Base.redirect_stderr — Function
                                    #     # redirect_stderr([stream]) -> (rd, wr)
                                    #     # Like redirect_stdout, but for stderr.
                                    #     # Base.redirect_stderr — Method
                                    #     # redirect_stderr(f::Function, stream)
                                    #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                    #     # Base.redirect_stdin — Function
                                    #     # redirect_stdin([stream]) -> (rd, wr)
                                    #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                    #     # Base.redirect_stdin — Method
                                    #     # redirect_stdin(f::Function, stream)
                                    #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                    # catch err
                                    #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                    #     println(err);
                                    #     # println(Base.typeof(err));
                                    #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                    # finally
                                    #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                    #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                    #     if Base.eof(fWIO)
                                    #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                    #     end
                                    # end
                                end

                                # 使用 Base.isready(c::Channel) 函數判斷通道中元素是否已經取空，如果已經取空 Base.isready(c::Channel) 返回為 false 值，則跳出 for 循環，如果一個空通道從未寫入過元素，則 Base.isready(sub_to_main_channel) 值爲 true，因此會一直阻塞等待不會跳出循環;
                                if !Base.isready(sub_to_main_channel)
                                    break;
                                end
                            end

                            # 刪除任務隊列數組中前面已經處理過的任務元素;
                            for i in 1:input_queues_length
                                # global input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                                input_queues_array = Base.deleteat!(input_queues_array, 1);  # 刪除第一個元素;
                            end
                        end
                    end

                    return ["input_queues_array[1] -> temp_monitor_file -> temp_output_file -> output_queues_array[last]", input_queues_array, output_queues_array];
                else
                    return ["The input queues array empty.", input_queues_array, output_queues_array];
                end
            end

            function func_Exit()

                from3Dict = Base.Dict{Core.String, Core.Any}(
                    # # "read_file_do_Function" => read_file_do_Function,  # to3Dict["read_file_do_Function"];
                    # "monitor_file" => to3Dict["monitor_file"], # monitor_file,
                    # "monitor_dir" => to3Dict["monitor_dir"], # monitor_dir,
                    # # "do_Function" => do_Function,  # to3Dict["do_Function"]，do_data ;
                    # "output_dir" => to3Dict["output_dir"], # output_dir,
                    # "output_file" => to3Dict["output_file"], # output_file,
                    # "temp_cache_IO_data_dir" => to3Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                    # "to_executable" => to3Dict["to_executable"], # to_executable,
                    # "to_script" => to3Dict["to_script"],  # to_script,
                    # "input_queues_array" => to3Dict["input_queues_array"],  # input_queues_array,
                    # "output_queues_array" => to3Dict["output_queues_array"],  # output_queues_array,
                    "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                    "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                    "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                    "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    "label" => "exit",
                    "message" => "Function < func_Monitor_input_queues() > worker process-" * Base.string(Distributed.myid()) * " being exit."
                );

                Base.put!(rc3from, from3Dict);

                Base.close(rc3from);
            end
            Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

            while true

                if Base.isready(rc3to)

                    to3Dict = Base.take!(rc3to);
                    
                    if to3Dict["label"] === "exit"
                        # break;
                        Base.exit(0);
                    end

                    if to3Dict["label"] === "Run"

                        from3Dict = Base.Dict{Core.String, Core.Any}(
                            # "read_file_do_Function" => to3Dict["read_file_do_Function"], # read_file_do_Function,
                            "monitor_file" => to3Dict["monitor_file"], # monitor_file,
                            "monitor_dir" => to3Dict["monitor_dir"], # monitor_dir,
                            # "do_Function" => to3Dict["do_Function"], # do_Function, # do_data ;
                            "output_dir" => to3Dict["output_dir"], # output_dir,
                            "output_file" => to3Dict["output_file"], # output_file,
                            "temp_cache_IO_data_dir" => to3Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                            "to_executable" => to3Dict["to_executable"], # to_executable,
                            "to_script" => to3Dict["to_script"],  # to_script,
                            "input_queues_array" => to3Dict["input_queues_array"],  # input_queues_array,
                            "output_queues_array" => to3Dict["output_queues_array"],  # output_queues_array,
                            "worker_queues_Dict" => to3Dict["worker_queues_Dict"],
                            "total_worker_called_number" => to3Dict["total_worker_called_number"],
                            "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                            "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                            "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                            "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            "label" => "func_Monitor_input_queues",
                            "message" => "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task()))
                        );

                        # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.Task}();
                        # # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
                        # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
                        worker_queues_Dict = Base.deepcopy(to3Dict["worker_queues_Dict"]);
                        total_worker_called_number = Base.deepcopy(to3Dict["total_worker_called_number"]);

                        if Base.typeof(to3Dict["input_queues_array"]) <: Core.Array && Base.length(to3Dict["input_queues_array"]) > 0
                            if Base.typeof(to3Dict["output_queues_array"]) <: Core.Array

                                # result = func_Monitor_input_queues(
                                #     # monitor_file,
                                #     # monitor_dir,
                                #     do_Function,
                                #     # output_dir,
                                #     # output_file,
                                #     # to_executable,
                                #     # to_script,
                                #     # temp_cache_IO_data_dir,
                                #     number_Worker_threads,
                                #     time_sleep,
                                #     read_file_do_Function,
                                #     isDoTasksOrThreads,
                                #     funcTask,
                                #     main_to_sub_channel,
                                #     sub_to_main_channel,
                                #     control_number_Queues_channel,
                                #     input_queues_array,
                                #     output_queues_array,
                                #     worker_queues_Dict,
                                #     total_worker_called_number
                                # );

                                result = func_Monitor_input_queues(
                                    # to3Dict["monitor_file"], # monitor_file,
                                    # to3Dict["monitor_dir"], # monitor_dir,
                                    do_Function, # to3Dict["do_Function"],
                                    # to3Dict["output_dir"], # output_dir,
                                    # to3Dict["output_file"], # output_file,
                                    # to3Dict["to_executable"], # to_executable,
                                    # to3Dict["to_script"], # to_script,
                                    # to3Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                                    number_Worker_threads,
                                    time_sleep,
                                    read_file_do_Function, # to3Dict["read_file_do_Function"],
                                    isDoTasksOrThreads,
                                    funcTask, # to3Dict["funcTask"],
                                    main_to_sub_channel,
                                    sub_to_main_channel,
                                    control_number_Queues_channel,
                                    to3Dict["input_queues_array"], # input_queues_array,
                                    to3Dict["output_queues_array"], # output_queues_array,
                                    worker_queues_Dict,
                                    total_worker_called_number
                                );

                                if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                                    if result[1] === "The input queues array empty."
                                        from3Dict["label"] = "empty";
                                        from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_input_queues() > return [ The input queues array empty. ]";
                                        from3Dict["worker_queues_Dict"] = worker_queues_Dict;
                                        from3Dict["total_worker_called_number"] = total_worker_called_number;
                                    else
                                        if Base.length(result[3]) > 0
                                            output_queues_last = result[3][Base.length(result[3])];
                                            from3Dict["monitor_file"] = output_queues_last["monitor_file"];
                                            from3Dict["monitor_dir"] = output_queues_last["monitor_dir"];
                                            from3Dict["output_file"] = output_queues_last["output_file"];
                                            from3Dict["output_dir"] = output_queues_last["output_dir"];
                                            from3Dict["to_executable"] = output_queues_last["to_executable"];
                                            from3Dict["to_script"] = output_queues_last["to_script"];
                                            from3Dict["input_queues_array"] = result[2];
                                            from3Dict["output_queues_array"] = result[3];
                                            from3Dict["worker_queues_Dict"] = worker_queues_Dict;
                                            from3Dict["total_worker_called_number"] = total_worker_called_number;
                                            from3Dict["label"] = "success";  # "func_Monitor_input_queues";
                                            # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                            # println(Base.string(nowTime));
                                            # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_last["monitor_file"]) * " ] -> [ " * Base.string(output_queues_last["output_file"]) * " ].";
                                            log_text = Base.string(output_queues_last["time"]) * " process-" * Base.string(output_queues_last["processID"]) * " thread-" * Base.string(output_queues_last["threadID"]) * " task-" * Base.string(output_queues_last["taskID"]) * " [ " * Base.string(output_queues_last["monitor_file"]) * " ] -> [ " * Base.string(output_queues_last["output_file"]) * " ].";
                                            from3Dict["message"] = log_text;  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_input_queues() > success.";
                                        else
                                            from3Dict["label"] = "error";
                                            from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_input_queues() > return output_queues_array empty.";
                                        end
                                    end
                                end

                                if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"
                                    from3Dict["label"] = "error";
                                    from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * Base.string(result[3]);  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_input_queues() > return error, or The input queues array empty.";
                                end
                            else
                                from3Dict["label"] = "error";
                                from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the output_queues_array not Core.Array, Base.typeof(output_queues_array) <: Core.Array is false.";
                            end
                        else
                            from3Dict["label"] = "empty";
                            from3Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the input_queues_array empty.";
                        end

                        Base.put!(rc3from, from3Dict);

                        from3Dict = Core.nothing;
                        result = Core.nothing;
                    end

                    to3Dict = Core.nothing;
                else
                    # continue;
                    # break;
                    # Base.exit(0);
                end

                Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
            end
        end
        wp3 = Distributed.remotecall(
            func_wp3,
            3,
            # monitor_file,
            # monitor_dir,
            do_Function,
            # output_dir,
            # output_file,
            # to_executable,
            # to_script,
            # temp_cache_IO_data_dir,
            number_Worker_threads,
            time_sleep,
            read_file_do_Function,
            # isMonitorThreadsOrProcesses,
            isDoTasksOrThreads,
            rc3to,
            rc3from
        );
        # r3 = Base.fetch(wp3);

        # 子進程 4 運行輪詢 func_Monitor_output_queues 函數;
        # Distributed.@spawnat p expr
        function func_wp4(
            monitor_file::Core.String,
            monitor_dir::Core.String,
            # do_Function,
            output_dir::Core.String,
            output_file::Core.String,
            to_executable::Core.String,
            to_script::Core.String,
            # temp_cache_IO_data_dir::Core.String,
            # number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
            time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
            # read_file_do_Function,
            # isMonitorThreadsOrProcesses::Union{Core.String, Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
            # isDoTasksOrThreads::Core.String,
            rc4to::RemoteChannel{Channel{Dict{String,Any}}},
            rc4from::RemoteChannel{Channel{Dict{String,Any}}}
        )
        # wp4 = Distributed.@spawnat 4 begin

            # 創建一個自定義的函數，當計時器輪詢時調用，用以監聽傳出數據等待處理的任務隊列，當傳出數據等待處理的任務隊列長度大於 1 時，采用先進先出的原則，處理隊列中的任務排隊，並相應清除已經被處理過的任務元素;
            function func_Monitor_output_queues(
                # monitor_file::Core.String,
                # monitor_dir::Core.String,
                # do_Function,
                # output_dir::Core.String,
                output_file::Core.String,
                # to_executable::Core.String,
                # to_script::Core.String,
                # temp_cache_IO_data_dir::Core.String,
                # number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
                # time_sleep::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8},
                input_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1},
                output_queues::Core.Array{Base.Dict{Core.String, Core.Any}, 1}
            ) ::Core.Array{Core.Any, 1}

                # # print("當前協程 task: ", Base.current_task(), "\n");
                # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
                # print("當前綫程 thread 的 PID: ", Base.Threads.threadid(), "\n");
                # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
                # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
                # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
                # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
                # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
                # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
                # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
                # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
                # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
                # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
                # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
                # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
                # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

                output_queues_array = Base.deepcopy(output_queues);
                input_queues_array = Base.deepcopy(input_queues);

                # 監聽待傳出數據結果隊列數組 output_queues_array，當有用於傳出數據的媒介目錄 output_dir 中不在含有 output_file 時，將待傳出數據結果隊列數組 output_queues_array 中排在前面的第一個結果文檔，更名移人用於傳出數據的媒介目錄 output_dir 中;
                if length(output_queues_array) > 0

                    output_queues_1_Dict = Base.Dict{Core.String, Core.Any}();  #  聲明一個空的字典類型的變量，承接 output_queues_array 數組中的一個元素;
                    output_queues_1_Dict = output_queues_array[1];

                    # 判斷用於輸出傳值的媒介文檔，是否已經存在且是否為文檔，如果已存在則從硬盤刪除，然後重新創建並寫入新值;
                    if Base.Filesystem.ispath(output_file) && Base.Filesystem.isfile(output_file)
                        # println("用於輸出傳值的媒介文檔: " * output_file * " 已經存在.");
                        return ["The output_file already exists.", input_queues_array, output_queues_array];
                    else
                        # # global output_queues_array = Base.deleteat!(output_queues_array, 1);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        output_queues_array = Base.deleteat!(output_queues_array, 1);  # 使用 Base.push!() 函數在數組末尾追加推入新元素，使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        # # println(input_queues_array);
                        # # println(length(input_queues_array));
                        # # result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = input_queues_array[1]["read_file_do_Function"](input_queues_array[1]["monitor_file"], input_queues_array[1]["monitor_dir"], input_queues_array[1]["do_Function"], input_queues_array[1]["output_dir"], input_queues_array[1]["output_file"], input_queues_array[1]["to_executable"], input_queues_array[1]["to_script"], time_sleep);

                        # 監聽指定的硬盤用於傳數據的媒介文檔，當出現監聽的目標文檔時，激活處理函數;
                        # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介文檔是否存在，如果不存在，則中止函數退出，如果存在則判斷操作權限，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
                        # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isfile(monitor_file) 方法判斷是否為文檔;
                        if !(Base.Filesystem.ispath(output_queues_1_Dict["output_file"]) && Base.Filesystem.isfile(output_queues_1_Dict["output_file"]))
                            # output_queues_1_Dict["output_file"] === output_queues_array[1]["output_file"]
                            # # global output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                            # output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                            return ["document < temp_output_file = " * Base.string(output_queues_1_Dict["output_file"]) * " > not exists.", input_queues_array, output_queues_array];
                        end

                        if Base.Filesystem.ispath(output_queues_1_Dict["output_file"]) && Base.Filesystem.isfile(output_queues_1_Dict["output_file"])

                            # 檢查文檔操作權限，修改爲可讀、可寫權限，# output_queues_1_Dict["output_file"] === output_queues_array[1]["output_file"];
                            if Base.stat(output_queues_1_Dict["output_file"]).mode !== Core.UInt64(33206) && Base.stat(output_queues_1_Dict["output_file"]).mode !== Core.UInt64(33279)
                                # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(output_queues_1_Dict["output_file"]) 函數讀取文檔信息，使用 Base.stat(output_queues_1_Dict["output_file"]).mode 方法提取文檔權限碼;
                                # println("用於傳值的媒介文檔 [ " * output_queues_1_Dict["output_file"] * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                try
                                    # 使用 Base.Filesystem.chmod(output_queues_1_Dict["output_file"], mode=0o777; recursive=false) 函數修改文檔操作權限;
                                    # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                    Base.Filesystem.chmod(output_queues_1_Dict["output_file"], mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                    # println("文檔: " * output_queues_1_Dict["output_file"] * " 操作權限成功修改爲 mode=0o777 .");

                                    # 八進制值    說明
                                    # 0o400      所有者可讀
                                    # 0o200      所有者可寫
                                    # 0o100      所有者可執行或搜索
                                    # 0o40       群組可讀
                                    # 0o20       群組可寫
                                    # 0o10       群組可執行或搜索
                                    # 0o4        其他人可讀
                                    # 0o2        其他人可寫
                                    # 0o1        其他人可執行或搜索
                                    # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                    # 數字	說明
                                    # 7	可讀、可寫、可執行
                                    # 6	可讀、可寫
                                    # 5	可讀、可執行
                                    # 4	唯讀
                                    # 3	可寫、可執行
                                    # 2	只寫
                                    # 1	只可執行
                                    # 0	沒有許可權
                                    # 例如，八進制值 0o765 表示：
                                    # 1) 、所有者可以讀取、寫入和執行該文檔；
                                    # 2) 、群組可以讀和寫入該文檔；
                                    # 3) 、其他人可以讀取和執行該文檔；
                                    # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                    # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                catch err
                                    println("用於輸出數據的臨時暫存媒介文檔: " * output_queues_1_Dict["output_file"] * " 無法修改操作權限爲 mode=0o777 .");
                                    println(err);
                                    # println(err.msg);
                                    # println(Base.typeof(err));
                                    # # global output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                                    # output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                                    return ["document < temp_output_file = " * Base.string(output_queues_1_Dict["output_file"]) * " > change the permissions mode=0o777 fail.", input_queues_array, output_queues_array];
                                end
                            end

                            # 同步移動更名文檔，將用於傳出數據的臨時暫存媒介文檔 temp_output_file 從臨時暫存媒介文件夾 temp_cache_IO_data_dir 移動到輸出數據的媒介文件夾 output_dir 並更名為正式輸出數據的媒介文檔 output_file;
                            try
                                # Base.Filesystem.mv(src::AbstractString, dst::AbstractString; force::Bool=false)
                                # Move the file, link, or directory from src to dst. force=true will first remove an existing dst. Return dst.
                                Base.Filesystem.mv(output_queues_1_Dict["output_file"], output_file; force=false);  # 將文檔、鏈接或目錄從 output_queues_1_Dict["output_file"] 更名移動到 output_file，如果參數 force=true 將首先刪除現有的 output_file 文檔，函數返回值為 output_file 字符串;
                                # println("用於輸出傳值的臨時暫存媒介文檔: " * output_queues_1_Dict["output_file"] * " 已經被移動更名爲用於傳出數據的正式媒介文檔: " * output_file * " .");
                            catch err
                                println("用於輸出數據的臨時暫存媒介文檔: " * output_queues_1_Dict["output_file"] * " 無法移動更名爲用於傳出數據的正式媒介文檔: " * output_file * " .");
                                println(err);
                                # println(Base.typeof(err));
                                # # global output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                                # output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                                return ["document < temp_output_file = " * Base.string(output_queues_1_Dict["output_file"]) * " > not move to < " * Base.string(output_file) * " >.", input_queues_array, output_queues_array];
                            end

                            # Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;

                            # # 判斷用於輸出傳值的臨時暫存媒介文檔 output_queues_1_Dict["output_file"]，是否已經從硬盤刪除，即判斷用於輸出傳值的臨時暫存媒介文檔，是否已經從臨時暫存媒介目錄 temp_cache_IO_data_dir 移動到用於輸出的正式媒介目錄 output_dir，並已經更名為 output_file;
                            # if Base.Filesystem.ispath(output_queues_1_Dict["output_file"]) && Base.Filesystem.isfile(output_queues_1_Dict["output_file"])
                            #     println("用於輸出數據的臨時暫存媒介文檔: " * output_queues_1_Dict["output_file"] * " 無法移動更名爲用於傳出數據的正式媒介文檔: " * output_file * " .");
                            #     return ["error", output_queues_1_Dict["output_file"], "document [ temp_output_file = " * Base.string(output_queues_1_Dict["output_file"]) * " ] not move."];
                            # end

                            # 判斷新生成用於輸出傳值的正式媒介文檔 output_file，是否已經創建成功，即判斷用於輸出傳值的臨時暫存媒介文檔 temp_output_file，是否已經從臨時暫存媒介目錄 temp_cache_IO_data_dir 移動到用於輸出的正式媒介目錄 output_dir，並已經更名為 output_file;
                            if Base.Filesystem.ispath(output_file) && Base.Filesystem.isfile(output_file)

                                # # 檢查指定用於輸出傳值的正式媒介文檔 output_file 的操作權限是否爲可讀并且可寫，如無可讀可寫權限，則對其修改權限;
                                # if Base.stat(output_file).mode !== Core.UInt64(33206) && Base.stat(output_file).mode !== Core.UInt64(33279)
                                #     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(output_file) 函數讀取文檔信息，使用 Base.stat(output_file).mode 方法提取文檔權限碼;
                                #     # println("用於輸出傳值的正式媒介文檔 [ " * output_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                #     try
                                #         # 使用 Base.Filesystem.chmod(output_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
                                #         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                #         Base.Filesystem.chmod(output_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                #         # println("文檔: " * output_file * " 操作權限成功修改爲 mode=0o777 .");

                                #         # 八進制值    說明
                                #         # 0o400      所有者可讀
                                #         # 0o200      所有者可寫
                                #         # 0o100      所有者可執行或搜索
                                #         # 0o40       群組可讀
                                #         # 0o20       群組可寫
                                #         # 0o10       群組可執行或搜索
                                #         # 0o4        其他人可讀
                                #         # 0o2        其他人可寫
                                #         # 0o1        其他人可執行或搜索
                                #         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                #         # 數字	說明
                                #         # 7	可讀、可寫、可執行
                                #         # 6	可讀、可寫
                                #         # 5	可讀、可執行
                                #         # 4	唯讀
                                #         # 3	可寫、可執行
                                #         # 2	只寫
                                #         # 1	只可執行
                                #         # 0	沒有許可權
                                #         # 例如，八進制值 0o765 表示：
                                #         # 1) 、所有者可以讀取、寫入和執行該文檔；
                                #         # 2) 、群組可以讀和寫入該文檔；
                                #         # 3) 、其他人可以讀取和執行該文檔；
                                #         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                #         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                #     catch err
                                #         println("用於輸出傳值的媒介文檔: " * output_file * " 無法修改操作權限爲 mode=0o777 .");
                                #         println(err);
                                #         # println(Base.typeof(err));
                                #         # # global output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                                #         # output_queues_array = Base.deleteat!(output_queues_array, 1);  # 刪除第一個元素;
                                #         # return ["error", output_file, "document [ output_file = " * Base.string(output_file) * " ] change the permissions mode=0o777 fail."];
                                #     end
                                # end


                                # # 使用 a = Base.read(`bash -c C:/node.exe C:/Cross/test.js a=5 b=6`, Core.String) 調用 shell 語句反饋，運算處理完之後，給調用語言的回復，然後再獲取返回值;
                                # # 判斷變量 to_executable 已被定義且類型取值合法，Core.isa(to_executable, Core.String) 與 Base.typeof(to_executable) === Core.String 等效;
                                # # local to_executable = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe"));  # String 類型變量，上一層路徑下的Node.JS解釋器可執行檔路徑C:\nodejs\node.exe：Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的解釋器可執行文件 "..\\NodeJS\\node.exe"，Julia 解釋器可執行檔全名 println(Base.Sys.BINDIR)：C:\Julia 1.5.1\bin，;
                                # # local to_executable = Core.nothing;  # 置空;
                                # if Base.@isdefined(to_executable) && to_executable !== Core.nothing && Core.isa(to_executable, Core.String) && to_executable !== ""

                                #     # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否存在;
                                #     if Base.Filesystem.ispath(to_executable) && Base.Filesystem.isfile(to_executable)

                                #         # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
                                #         if Base.stat(to_executable).mode !== Core.UInt64(33206) && Base.stat(to_executable).mode !== Core.UInt64(33279)
                                #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
                                #             println("回調程序二進制可執行檔 [ " * to_executable * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                #             try
                                #                 # 使用 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false) 函數修改文檔操作權限;
                                #                 # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                #                 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                #                 println("回調程序二進制可執行檔: " * to_executable * " 操作權限成功修改爲 mode=0o777 .");

                                #                 # 八進制值    說明
                                #                 # 0o400      所有者可讀
                                #                 # 0o200      所有者可寫
                                #                 # 0o100      所有者可執行或搜索
                                #                 # 0o40       群組可讀
                                #                 # 0o20       群組可寫
                                #                 # 0o10       群組可執行或搜索
                                #                 # 0o4        其他人可讀
                                #                 # 0o2        其他人可寫
                                #                 # 0o1        其他人可執行或搜索
                                #                 # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                #                 # 數字	說明
                                #                 # 7	可讀、可寫、可執行
                                #                 # 6	可讀、可寫
                                #                 # 5	可讀、可執行
                                #                 # 4	唯讀
                                #                 # 3	可寫、可執行
                                #                 # 2	只寫
                                #                 # 1	只可執行
                                #                 # 0	沒有許可權
                                #                 # 例如，八進制值 0o765 表示：
                                #                 # 1) 、所有者可以讀取、寫入和執行該文檔；
                                #                 # 2) 、群組可以讀和寫入該文檔；
                                #                 # 3) 、其他人可以讀取和執行該文檔；
                                #                 # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                #                 # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                #             catch err
                                #                 println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
                                #                 println(err);
                                #                 # println(err.msg);
                                #                 # println(Base.typeof(err));
                                #                 return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
                                #             end
                                #         end

                                #         # 判斷文件夾權限;
                                #         if !(Base.stat(to_executable).mode === Core.UInt64(33206) || Base.stat(to_executable).mode === Core.UInt64(33279))
                                #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
                                #             println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
                                #             return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
                                #         end

                                #         # 判斷變量 to_script 已被定義且類型取值合法，Core.isa(to_script, Core.String) 與 Base.typeof(to_script) === Core.String 等效;
                                #         # local to_script = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js"));  # String 類型變量，上一層路徑下的 JavaScript 脚本路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的被調用的脚本文檔 "../js/Ruuter.js";
                                #         # local to_script = Core.nothing;  # 置空;
                                #         if Base.@isdefined(to_script) && to_script !== Core.nothing && Core.isa(to_script, Core.String) && to_script !== ""
                                #             # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否存在;
                                #             if Base.Filesystem.ispath(to_script) && Base.Filesystem.isfile(to_script)
                                #                 # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
                                #                 if Base.stat(to_script).mode !== Core.UInt64(33206) && Base.stat(to_script).mode !== Core.UInt64(33279)
                                #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
                                #                     println("回調程序二進制可執行檔調用的脚本文檔 [ " * to_script * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                                #                     try
                                #                         # 使用 Base.Filesystem.chmod(to_script, mode=0o777; recursive=false) 函數修改文檔操作權限;
                                #                         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                                #                         Base.Filesystem.chmod(to_script, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                                #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 操作權限成功修改爲 mode=0o777 .");

                                #                         # 八進制值    說明
                                #                         # 0o400      所有者可讀
                                #                         # 0o200      所有者可寫
                                #                         # 0o100      所有者可執行或搜索
                                #                         # 0o40       群組可讀
                                #                         # 0o20       群組可寫
                                #                         # 0o10       群組可執行或搜索
                                #                         # 0o4        其他人可讀
                                #                         # 0o2        其他人可寫
                                #                         # 0o1        其他人可執行或搜索
                                #                         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                                #                         # 數字	說明
                                #                         # 7	可讀、可寫、可執行
                                #                         # 6	可讀、可寫
                                #                         # 5	可讀、可執行
                                #                         # 4	唯讀
                                #                         # 3	可寫、可執行
                                #                         # 2	只寫
                                #                         # 1	只可執行
                                #                         # 0	沒有許可權
                                #                         # 例如，八進制值 0o765 表示：
                                #                         # 1) 、所有者可以讀取、寫入和執行該文檔；
                                #                         # 2) 、群組可以讀和寫入該文檔；
                                #                         # 3) 、其他人可以讀取和執行該文檔；
                                #                         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                                #                         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                                #                     catch err
                                #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
                                #                         println(err);
                                #                         # println(err.msg);
                                #                         # println(Base.typeof(err));
                                #                         return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
                                #                     end
                                #                 end

                                #                 # 判斷文件夾權限;
                                #                 if !(Base.stat(to_script).mode === Core.UInt64(33206) || Base.stat(to_script).mode === Core.UInt64(33279))
                                #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
                                #                     println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
                                #                     return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
                                #                 end
                                #             else
                                #                 println("回調程序二進制可執行檔調用的脚本文檔路徑全名「to_script = " * Base.string(to_script) * "」不能被識別.");
                                #                 return ["error", to_script, "Callback script code document [ to_script = " * Base.string(to_script) * " ] error, no recognition."];
                                #             end

                                #             textCommand = "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
                                #             # Command = `bash -c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                                #             # Command = `cmd /c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                                #             Command = `bash -c $textCommand`;

                                #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
                                #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
                                #             # println(Base.typeof(resultBack));
                                #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
                                #             println(resultBack);
                                #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
                                #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                                #             # for x in Base.split(resultBack, "\n")
                                #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                                #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                                #             # end
                                #             # println(backArray);

                                #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                #             # Base.GC.gc();  # 内存回收函數 gc();

                                #         else
                                #             textCommand = "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
                                #             # Command = `bash -c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                                #             # Command = `cmd /c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                                #             Command = `bash -c $textCommand`;

                                #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令��能成功運行，則抛出 ErrorException 錯誤;
                                #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
                                #             # println(Base.typeof(resultBack));
                                #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
                                #             println(resultBack);
                                #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
                                #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                                #             # for x in Base.split(resultBack, "\n")
                                #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                                #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                                #             # end
                                #             # println(backArray);

                                #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                #             # Base.GC.gc();  # 内存回收函數 gc();
                                #         end
                                #     else
                                #         println("回調程序二進制可執行檔路徑全名「to_executable = " * Base.string(to_executable) * "」不能被識別.");
                                #         return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] error, no recognition."];
                                #     end
                                # end


                                # 打印日志記錄條目;
                                # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                # # println(Base.string(nowTime));
                                # # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                                # print(log_text * "\n");
                                # # log_file = "";  # 日志文檔;
                                # # # 同步寫入用於記錄過程的日志文檔;
                                # # try
                                # #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                # #     # # write(filename::AbstractString, x)
                                # #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                # #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                # #     # println(numBytes);
                                # #     # println(Base.stat(log_file).size);
                                # #     # println(Base.stat(log_file).mtime);
                                # #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                # #     # println(Base.stat(log_file).ctime);
                                # #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                # #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                # #     # # Base.countlines — Function
                                # #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                # #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                # #     # println(Base.countlines(log_file, eol='\\n'));

                                # #     fWIO = Base.open(log_file, "a+");
                                # #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                # #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                # #     # Keyword	Description				Default
                                # #     # read		open for reading		!write
                                # #     # write		open for writing		truncate | append
                                # #     # create	create if non-existent	!read & write | truncate | append
                                # #     # truncate	truncate to zero size	!read & write
                                # #     # append	seek to end				false

                                # #     # Mode	Description						Keywords
                                # #     # r		read							none
                                # #     # w		write, create, truncate			write = true
                                # #     # a		write, create, append			append = true
                                # #     # r+	read, write						read = true, write = true
                                # #     # w+	read, write, create, truncate	truncate = true, read = true
                                # #     # a+	read, write, create, append		append = true, read = true

                                # #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                # #     if Base.iswritable(fWIO)
                                # #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                # #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                # #         println(numBytes);
                                # #         println(Base.stat(log_file).size);
                                # #         println(Base.stat(log_file).mtime);
                                # #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                # #         println(Base.stat(log_file).ctime);
                                # #         # Base.displaysize([io::IO]) -> (lines, columns)
                                # #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                # #         # Base.countlines — Function
                                # #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                # #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                # #         println(Base.countlines(log_file, eol='\\n'));
                                # #     end

                                # #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                                # #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                                # #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                # #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                # #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                # #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                # #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                # #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                # #     # Base.ismarked(io);  # Return true if stream s is marked;
                                # #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                # #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                # #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                # #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                # #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                # #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                # #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                # #     # Base.close(io);  # 關閉緩衝區;
                                # #     # println(a)
                                # #     # Base.redirect_stdout — Function
                                # #     # redirect_stdout([stream]) -> (rd, wr)
                                # #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                # #     # If called with the optional stream argument, then returns stream itself.
                                # #     # Base.redirect_stdout — Method
                                # #     # redirect_stdout(f::Function, stream)
                                # #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                # #     # Base.redirect_stderr — Function
                                # #     # redirect_stderr([stream]) -> (rd, wr)
                                # #     # Like redirect_stdout, but for stderr.
                                # #     # Base.redirect_stderr — Method
                                # #     # redirect_stderr(f::Function, stream)
                                # #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                # #     # Base.redirect_stdin — Function
                                # #     # redirect_stdin([stream]) -> (rd, wr)
                                # #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                # #     # Base.redirect_stdin — Method
                                # #     # redirect_stdin(f::Function, stream)
                                # #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                # # catch err
                                # #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                # #     println(err);
                                # #     # println(Base.typeof(err));
                                # #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                # # finally
                                # #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                # #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                # #     if Base.eof(fWIO)
                                # #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                # #     end
                                # # end
                            else
                                # println("用於輸出傳值的媒介文檔: " * output_file * " 無法創建.");
                                # return ["error", output_file, "document [ output_file = " * Base.string(output_file) * " ] not create."];
                            end
                        end

                        return ["output_queues_array[1] -> temp_output_file -> output_file", input_queues_array, output_queues_array];
                    end
                else
                    return ["The output queues array empty.", input_queues_array, output_queues_array];
                end
            end

            function func_Exit()

                from4Dict = Base.Dict{Core.String, Core.Any}(
                    # # "read_file_do_Function" => read_file_do_Function,  # to4Dict["read_file_do_Function"];
                    # "monitor_file" => to4Dict["monitor_file"], # monitor_file,
                    # "monitor_dir" => to4Dict["monitor_dir"], # monitor_dir,
                    # # "do_Function" => do_Function,  # to4Dict["do_Function"]，do_data ;
                    # "output_dir" => to4Dict["output_dir"], # output_dir,
                    # "output_file" => to4Dict["output_file"], # output_file,
                    # "temp_cache_IO_data_dir" => to4Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                    # "to_executable" => to4Dict["to_executable"], # to_executable,
                    # "to_script" => to4Dict["to_script"],  # to_script,
                    # "input_queues_array" => to4Dict["input_queues_array"],  # input_queues_array,
                    # "output_queues_array" => to4Dict["output_queues_array"],  # output_queues_array,
                    "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                    "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                    "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                    "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    "label" => "exit",
                    "message" => "Function < func_Monitor_output_queues() > worker process-" * Base.string(Distributed.myid()) * " being exit."
                );

                Base.put!(rc4from, from4Dict);

                Base.close(rc4from);
            end
            Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

            while true

                if Base.isready(rc4to)

                    to4Dict = Base.take!(rc4to);

                    if to4Dict["label"] === "exit"
                        # break;
                        Base.exit(0);
                    end

                    if to4Dict["label"] === "Run"

                        if Base.isa(to4Dict, Base.Dict) && Base.haskey(to4Dict, "output_queues_array") && Base.typeof(to4Dict["output_queues_array"]) <: Core.Array && Base.length(to4Dict["output_queues_array"]) > 0 && Base.isa(to4Dict["output_queues_array"][1], Base.Dict) && Base.haskey(to4Dict["output_queues_array"][1], "output_file") && Base.isa(to4Dict["output_queues_array"][1]["output_file"], Core.String) && to4Dict["output_queues_array"][1]["output_file"] !== ""
                            tempOutputFile = to4Dict["output_queues_array"][1]["output_file"];
                        else
                            tempOutputFile = "";
                        end

                        from4Dict = Base.Dict{Core.String, Core.Any}(
                            # "read_file_do_Function" => read_file_do_Function,  # to4Dict["read_file_do_Function"];
                            "monitor_file" => to4Dict["monitor_file"], # monitor_file,
                            "monitor_dir" => to4Dict["monitor_dir"], # monitor_dir,
                            # "do_Function" => do_Function,  # to4Dict["do_Function"]，do_data ;
                            "output_dir" => to4Dict["output_dir"], # output_dir,
                            "output_file" => to4Dict["output_file"], # output_file,
                            "temp_cache_IO_data_dir" => to4Dict["temp_cache_IO_data_dir"], # temp_cache_IO_data_dir,
                            "to_executable" => to4Dict["to_executable"], # to_executable,
                            "to_script" => to4Dict["to_script"],  # to_script,
                            "input_queues_array" => to4Dict["input_queues_array"],  # input_queues_array,
                            "output_queues_array" => to4Dict["output_queues_array"],  # output_queues_array,
                            "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                            "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                            "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                            "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                            "label" => "func_Monitor_output_queues",
                            "message" => "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task()))
                        );

                        if Base.typeof(to4Dict["output_queues_array"]) <: Core.Array && Base.length(to4Dict["output_queues_array"]) > 0
                            if Base.typeof(to4Dict["input_queues_array"]) <: Core.Array
                                
                                result = func_Monitor_output_queues(
                                    # to4Dict["monitor_file"],  # monitor_file,
                                    # to4Dict["monitor_dir"],  # monitor_dir,
                                    # do_Function,  # to4Dict["do_Function"],
                                    # to4Dict["output_dir"],  # output_dir,
                                    to4Dict["output_file"],  # output_file,
                                    # to4Dict["to_executable"],  # to_executable,
                                    # to4Dict["to_script"],  # to_script,
                                    # to4Dict["temp_cache_IO_data_dir"],  # temp_cache_IO_data_dir,
                                    # number_Worker_threads,
                                    # time_sleep,
                                    to4Dict["input_queues_array"],  # input_queues_array,
                                    to4Dict["output_queues_array"]  # output_queues_array
                                );

                                if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] !== "error"
                                    if result[1] === "The output queues array empty."
                                        from4Dict["label"] = "empty";
                                        from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_output_queues() > return [ " * Base.string(result[1]) * " ]";
                                    elseif result[1] === "The output_file already exists."
                                        from4Dict["label"] = "output_file_exists";
                                        from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_output_queues() > return [ " * Base.string(result[1]) * " ]";
                                    elseif result[1] === "output_queues_array[1] -> temp_output_file -> output_file"
                                        from4Dict["monitor_file"] = monitor_file;
                                        from4Dict["monitor_dir"] = monitor_dir;
                                        from4Dict["output_file"] = output_file;
                                        from4Dict["output_dir"] = output_dir;
                                        from4Dict["to_executable"] = to_executable;
                                        from4Dict["to_script"] = to_script;
                                        from4Dict["input_queues_array"] = result[2];
                                        from4Dict["output_queues_array"] = result[3];
                                        from4Dict["label"] = "success";  # "func_Monitor_output_queues";
                                        nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        # println(Base.string(nowTime));
                                        # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(to4Dict["output_queues_array"][Base.length(to4Dict["output_queues_array"])]["output_file"]) * " ] -> [ " * Base.string(output_file) * " ].";
                                        log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(tempOutputFile) * " ] -> [ " * Base.string(output_file) * " ].";
                                        from4Dict["message"] = log_text;  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_output_queues() > success.";
                                    else
                                        from4Dict["input_queues_array"] = result[2];
                                        from4Dict["output_queues_array"] = result[3];
                                        from4Dict["label"] = "error";
                                        from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " Function < func_Monitor_output_queues() > return [ " * Base.string(result[1]) * " ]";
                                    end
                                end

                                if Base.typeof(result) <: Core.Array && Base.length(result) > 0 && result[1] === "error"
                                    from4Dict["label"] = "error";
                                    from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * Base.string(result[3]);  # "worker process-" * Base.string(Distributed.myid()) * " Function < func_Monitor_output_queues() > return error, or The output queues array empty.";
                                end
                            else
                                from4Dict["label"] = "error";
                                from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the input_queues_array not Core.Array, Base.typeof(input_queues_array) <: Core.Array is false.";
                            end
                        else
                            from4Dict["label"] = "empty";
                            from4Dict["message"] = "worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " receving the output_queues_array empty.";
                        end

                        Base.put!(rc4from, from4Dict);

                        from4Dict = Core.nothing;
                        result = Core.nothing;
                    end
                
                    to4Dict = Core.nothing;
                else
                    # continue;
                    # break;
                    # Base.exit(0);
                end

                Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
            end
        end
        wp4 = Distributed.remotecall(
            func_wp4,
            4,
            monitor_file,
            monitor_dir,
            # do_Function,
            output_dir,
            output_file,
            to_executable,
            to_script,
            # temp_cache_IO_data_dir,
            # number_Worker_threads,
            time_sleep,
            # read_file_do_Function,
            # isMonitorThreadsOrProcesses,
            # isDoTasksOrThreads,
            rc4to,
            rc4from
        );
        # r4 = Base.fetch(wp4);

        while true

            RemoteChannel_Data_Dict = Base.Dict{Core.String, Core.Any}(
                # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
                "monitor_file" => monitor_file,
                "monitor_dir" => monitor_dir,
                # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
                "output_dir" => output_dir,
                "output_file" => output_file,
                "temp_cache_IO_data_dir" => temp_cache_IO_data_dir,
                "to_executable" => to_executable,
                "to_script" => to_script,
                "input_queues_array" => input_queues_array,
                "output_queues_array" => output_queues_array,
                "worker_queues_Dict" => worker_queues_Dict,
                "total_worker_called_number" => total_worker_called_number,
                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                "label" => "Run",
                "message" => "Run"
            );

            if Base.isopen(rc2to)
                # RemoteChannel_Data_Dict["label"] = "Run";
                RemoteChannel_Data_Dict["message"] = "worker process-2 Function < func_Monitor_file() > be run.";
                Base.put!(rc2to, RemoteChannel_Data_Dict);
            end

            if Base.isready(rc2from)

                from2rcDict = Base.take!(rc2from);

                if from2rcDict["label"] === "error"
                    println(from2rcDict["message"]);
                end

                if from2rcDict["label"] === "success"
                    # 打印日志記錄條目;
                    # println(from2rcDict["message"]);
                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                    # log_text = from2rcDict["time"] * " process-" * from2rcDict["processID"] * " thread-" * from2rcDict["threadID"] * " task-" * from2rcDict["taskID"] * " [ " * from2rcDict["monitor_file"] * " ] -> [ " * from2rcDict["output_file"] * " ].";
                    # print(log_text * "\n");
                    input_queues_array = from2rcDict["input_queues_array"];
                    RemoteChannel_Data_Dict["input_queues_array"] = input_queues_array;
                    # output_queues_array = from2rcDict["output_queues_array"];
                    # RemoteChannel_Data_Dict["output_queues_array"] = output_queues_array;
                end

                from2rcDict = Core.nothing;
            end

            if Base.isopen(rc3to)
                # RemoteChannel_Data_Dict["label"] = "Run";
                RemoteChannel_Data_Dict["message"] = "worker process-3 Function < func_Monitor_input_queues() > be run.";
                Base.put!(rc3to, RemoteChannel_Data_Dict);
            end

            if Base.isready(rc3from)

                from3rcDict = Base.take!(rc3from);

                if from3rcDict["label"] === "error"
                    println(from3rcDict["message"]);
                end

                if from3rcDict["label"] === "success"
                    # 打印日志記錄條目;
                    # println(from3rcDict["message"]);
                    log_text = Base.string(from3rcDict["time"]) * " process-" * Base.string(from3rcDict["processID"]) * " thread-" * Base.string(from3rcDict["threadID"]) * " task-" * Base.string(from3rcDict["taskID"]) * " [ " * Base.string(from3rcDict["output_queues_array"][Base.length(from3rcDict["output_queues_array"])]["monitor_file"]) * " ] -> [ " * Base.string(output_file) * " ].";
                    println(log_text);
                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                    # log_text = from3rcDict["time"] * " process-" * from3rcDict["processID"] * " thread-" * from3rcDict["threadID"] * " task-" * from3rcDict["taskID"] * " [ " * from3rcDict["monitor_file"] * " ] -> [ " * from3rcDict["output_file"] * " ].";
                    # print(log_text * "\n");
                    input_queues_array = from3rcDict["input_queues_array"];
                    RemoteChannel_Data_Dict["input_queues_array"] = input_queues_array;
                    output_queues_array = from3rcDict["output_queues_array"];
                    RemoteChannel_Data_Dict["output_queues_array"] = output_queues_array;
                    worker_queues_Dict = from3rcDict["worker_queues_Dict"];
                    RemoteChannel_Data_Dict["worker_queues_Dict"] = worker_queues_Dict;
                    total_worker_called_number = from3rcDict["total_worker_called_number"];
                    RemoteChannel_Data_Dict["total_worker_called_number"] = total_worker_called_number;
                end

                from3rcDict = Core.nothing;
            end

            if Base.isopen(rc4to)
                # RemoteChannel_Data_Dict["label"] = "Run";
                RemoteChannel_Data_Dict["message"] = "worker process-4 Function < func_Monitor_output_queues() > be run.";
                Base.put!(rc4to, RemoteChannel_Data_Dict);
            end

            if Base.isready(rc4from)

                from4rcDict = Base.take!(rc4from);

                if from4rcDict["label"] === "error"
                    println(from4rcDict["message"]);
                end

                if from4rcDict["label"] === "success"
                    # 打印日志記錄條目;
                    # println(from4rcDict["message"]);
                    # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * Base.string(output_queues_1_Dict["monitor_file"]) * " ] -> [ " * Base.string(output_queues_1_Dict["output_file"]) * " ].";
                    # log_text = from4rcDict["time"] * " process-" * from4rcDict["processID"] * " thread-" * from4rcDict["threadID"] * " task-" * from4rcDict["taskID"] * " [ " * from4rcDict["monitor_file"] * " ] -> [ " * from4rcDict["output_file"] * " ].";
                    # print(log_text * "\n");
                    # input_queues_array = from4rcDict["input_queues_array"];
                    # RemoteChannel_Data_Dict["input_queues_array"] = input_queues_array;
                    output_queues_array = from4rcDict["output_queues_array"];
                    RemoteChannel_Data_Dict["output_queues_array"] = output_queues_array;
                end

                from4rcDict = Core.nothing;
            end

            RemoteChannel_Data_Dict = Core.nothing;

            begin
                # # 使用 a = Base.read(`bash -c C:/node.exe C:/Cross/test.js a=5 b=6`, Core.String) 調用 shell 語句反饋，運算處理完之後，給調用語言的回復，然後再獲取返回值;
                # # 判斷變量 to_executable 已被定義且類型取值合法，Core.isa(to_executable, Core.String) 與 Base.typeof(to_executable) === Core.String 等效;
                # # local to_executable = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe"));  # String 類型變量，上一層路徑下的Node.JS解釋器可執行檔路徑C:\nodejs\node.exe：Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的解釋器可執行文件 "..\\NodeJS\\node.exe"，Julia 解釋器可執行檔全名 println(Base.Sys.BINDIR)：C:\Julia 1.5.1\bin，;
                # # local to_executable = Core.nothing;  # 置空;
                # if Base.@isdefined(to_executable) && to_executable !== Core.nothing && Core.isa(to_executable, Core.String) && to_executable !== ""

                #     # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否存在;
                #     if Base.Filesystem.ispath(to_executable) && Base.Filesystem.isfile(to_executable)

                #         # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
                #         if Base.stat(to_executable).mode !== Core.UInt64(33206) && Base.stat(to_executable).mode !== Core.UInt64(33279)
                #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
                #             println("回調程序二進制可執行檔 [ " * to_executable * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                #             try
                #                 # 使用 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false) 函數修改文檔操作權限;
                #                 # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                #                 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                #                 println("回調程序二進制可執行檔: " * to_executable * " 操作權限成功修改爲 mode=0o777 .");

                #                 # 八進制值    說明
                #                 # 0o400      所有者可讀
                #                 # 0o200      所有者可寫
                #                 # 0o100      所有者可執行或搜索
                #                 # 0o40       群組可讀
                #                 # 0o20       群組可寫
                #                 # 0o10       群組可執行或搜索
                #                 # 0o4        其他人可讀
                #                 # 0o2        其他人可寫
                #                 # 0o1        其他人可執行或搜索
                #                 # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                #                 # 數字	說明
                #                 # 7	可讀、可寫、可執行
                #                 # 6	可讀、可寫
                #                 # 5	可讀、可執行
                #                 # 4	唯讀
                #                 # 3	可寫、可執行
                #                 # 2	只寫
                #                 # 1	只可執行
                #                 # 0	沒有許可權
                #                 # 例如，八進制值 0o765 表示：
                #                 # 1) 、所有者可以讀取、寫入和執行該文檔；
                #                 # 2) 、群組可以讀和寫入該文檔；
                #                 # 3) 、其他人可以讀取和執行該文檔；
                #                 # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                #                 # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                #             catch err
                #                 println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
                #                 println(err);
                #                 # println(err.msg);
                #                 # println(Base.typeof(err));
                #                 return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
                #             end
                #         end

                #         # 判斷文件夾權限;
                #         if !(Base.stat(to_executable).mode === Core.UInt64(33206) || Base.stat(to_executable).mode === Core.UInt64(33279))
                #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
                #             println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
                #             return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
                #         end

                #         # 判斷變量 to_script 已被定義且類型取值合法，Core.isa(to_script, Core.String) 與 Base.typeof(to_script) === Core.String 等效;
                #         # local to_script = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js"));  # String 類型變量，上一層路徑下的 JavaScript 脚本路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的被調用的脚本文檔 "../js/Ruuter.js";
                #         # local to_script = Core.nothing;  # 置空;
                #         if Base.@isdefined(to_script) && to_script !== Core.nothing && Core.isa(to_script, Core.String) && to_script !== ""
                #             # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否存在;
                #             if Base.Filesystem.ispath(to_script) && Base.Filesystem.isfile(to_script)
                #                 # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
                #                 if Base.stat(to_script).mode !== Core.UInt64(33206) && Base.stat(to_script).mode !== Core.UInt64(33279)
                #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
                #                     println("回調程序二進制可執行檔調用的脚本文檔 [ " * to_script * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
                #                     try
                #                         # 使用 Base.Filesystem.chmod(to_script, mode=0o777; recursive=false) 函數修改文檔操作權限;
                #                         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                #                         Base.Filesystem.chmod(to_script, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 操作權限成功修改爲 mode=0o777 .");

                #                         # 八進制值    說明
                #                         # 0o400      所有者可讀
                #                         # 0o200      所有者可寫
                #                         # 0o100      所有者可執行或搜索
                #                         # 0o40       群組可讀
                #                         # 0o20       群組可寫
                #                         # 0o10       群組可執行或搜索
                #                         # 0o4        其他人可讀
                #                         # 0o2        其他人可寫
                #                         # 0o1        其他人可執行或搜索
                #                         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                #                         # 數字	說明
                #                         # 7	可讀、可寫、可執行
                #                         # 6	可讀、可寫
                #                         # 5	可讀、可執行
                #                         # 4	唯讀
                #                         # 3	可寫、可執行
                #                         # 2	只寫
                #                         # 1	只可執行
                #                         # 0	沒有許可權
                #                         # 例如，八進制值 0o765 表示：
                #                         # 1) 、所有者可以讀取、寫入和執行該文檔；
                #                         # 2) 、群組可以讀和寫入該文檔；
                #                         # 3) 、其他人可以讀取和執行該文檔；
                #                         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                #                         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

                #                     catch err
                #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
                #                         println(err);
                #                         # println(err.msg);
                #                         # println(Base.typeof(err));
                #                         return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
                #                     end
                #                 end

                #                 # 判斷文件夾權限;
                #                 if !(Base.stat(to_script).mode === Core.UInt64(33206) || Base.stat(to_script).mode === Core.UInt64(33279))
                #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
                #                     println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
                #                     return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
                #                 end
                #             else
                #                 println("回調程序二進制可執行檔調用的脚本文檔路徑全名「to_script = " * Base.string(to_script) * "」不能被識別.");
                #                 return ["error", to_script, "Callback script code document [ to_script = " * Base.string(to_script) * " ] error, no recognition."];
                #             end

                #             textCommand = "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
                #             # Command = `bash -c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             # Command = `cmd /c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             Command = `bash -c $textCommand`;

                #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
                #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
                #             # println(Base.typeof(resultBack));
                #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
                #             println(resultBack);
                #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
                #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                #             # for x in Base.split(resultBack, "\n")
                #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                #             # end
                #             # println(backArray);

                #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             # Base.GC.gc();  # 内存回收函數 gc();

                #         else
                #             textCommand = "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
                #             # Command = `bash -c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             # Command = `cmd /c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
                #             Command = `bash -c $textCommand`;

                #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
                #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
                #             # println(Base.typeof(resultBack));
                #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
                #             println(resultBack);
                #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
                #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                #             # for x in Base.split(resultBack, "\n")
                #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                #             # end
                #             # println(backArray);

                #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                #             # Base.GC.gc();  # 内存回收函數 gc();
                #         end
                #     else
                #         println("回調程序二進制可執行檔路徑全名「to_executable = " * Base.string(to_executable) * "」不能被識別.");
                #         return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] error, no recognition."];
                #     end
                # end

                # 打印日志記錄條目;
                # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # # println(Base.string(nowTime));
                # # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                # log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(output_queues_1_Dict["monitor_file"]) * " > < " * Base.string(output_queues_1_Dict["output_file"]) * " >.";
                # print(log_text * "\n");
                # # log_file = "";  # 日志文檔;
                # # # 同步寫入用於記錄過程的日志文檔;
                # # try
                # #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                # #     # # write(filename::AbstractString, x)
                # #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                # #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                # #     # println(numBytes);
                # #     # println(Base.stat(log_file).size);
                # #     # println(Base.stat(log_file).mtime);
                # #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # #     # println(Base.stat(log_file).ctime);
                # #     # # Base.displaysize([io::IO]) -> (lines, columns)
                # #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                # #     # # Base.countlines — Function
                # #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                # #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                # #     # println(Base.countlines(log_file, eol='\\n'));

                # #     fWIO = Base.open(log_file, "a+");
                # #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                # #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                # #     # Keyword	Description				Default
                # #     # read		open for reading		!write
                # #     # write		open for writing		truncate | append
                # #     # create	create if non-existent	!read & write | truncate | append
                # #     # truncate	truncate to zero size	!read & write
                # #     # append	seek to end				false

                # #     # Mode	Description						Keywords
                # #     # r		read							none
                # #     # w		write, create, truncate			write = true
                # #     # a		write, create, append			append = true
                # #     # r+	read, write						read = true, write = true
                # #     # w+	read, write, create, truncate	truncate = true, read = true
                # #     # a+	read, write, create, append		append = true, read = true

                # #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                # #     if Base.iswritable(fWIO)
                # #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                # #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                # #         println(numBytes);
                # #         println(Base.stat(log_file).size);
                # #         println(Base.stat(log_file).mtime);
                # #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                # #         println(Base.stat(log_file).ctime);
                # #         # Base.displaysize([io::IO]) -> (lines, columns)
                # #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                # #         # Base.countlines — Function
                # #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                # #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                # #         println(Base.countlines(log_file, eol='\\n'));
                # #     end

                # #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                # #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                # #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                # #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                # #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                # #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                # #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                # #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                # #     # Base.ismarked(io);  # Return true if stream s is marked;
                # #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                # #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                # #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                # #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                # #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                # #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                # #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                # #     # Base.close(io);  # 關閉緩衝區;
                # #     # println(a)
                # #     # Base.redirect_stdout — Function
                # #     # redirect_stdout([stream]) -> (rd, wr)
                # #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                # #     # If called with the optional stream argument, then returns stream itself.
                # #     # Base.redirect_stdout — Method
                # #     # redirect_stdout(f::Function, stream)
                # #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                # #     # Base.redirect_stderr — Function
                # #     # redirect_stderr([stream]) -> (rd, wr)
                # #     # Like redirect_stdout, but for stderr.
                # #     # Base.redirect_stderr — Method
                # #     # redirect_stderr(f::Function, stream)
                # #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                # #     # Base.redirect_stdin — Function
                # #     # redirect_stdin([stream]) -> (rd, wr)
                # #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                # #     # Base.redirect_stdin — Method
                # #     # redirect_stdin(f::Function, stream)
                # #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                # # catch err
                # #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                # #     println(err);
                # #     # println(Base.typeof(err));
                # #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                # # finally
                # #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                # #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                # #     if Base.eof(fWIO)
                # #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                # #     end
                # # end
            end

            Base.sleep(time_sleep);  # 程序休眠，單位為秒，0.02;
        end
    end

    # # 創建一個自定義的回調函數，當計時器輪詢時調用，監聽指定的硬盤用於傳數據的媒介文檔，當出現監聽的目標文檔時，激活處理函數;
    # function func_Monitor(timer)
    #     println("當前進程編號: process-" * Base.string(process.pid) * " thread-" * Base.string(require('worker_threads').threadId));
    #     return [result, output_queues_array, input_queues_array];
    # end
    # delay_s = Core.Real(2);
    # interval_s = Core.Real(0.2);  # 計時器輪詢間隔時長，單位秒;
    # timer_ticker = Core.nothing;  # 循環延時監聽指定文檔是否被創建的計時器對象句柄，用於取消循環 timer_ticker = Base.Timer(func_Monitor_file, delay_s; interval=interval_s) 和 close(timer_ticker);
    # # println(Base.isopen(timer_ticker));  # 返回值 Bool，查看計時器是否仍然處於活動狀態;
    # timer_ticker = Base.Timer(func_Monitor, delay_s; interval=interval_s);  # 創建並啓動計時器，監聽指定文檔是否被創建;
    # # println(typeof(timer_ticker));
    # # println(timer_ticker);
    # # println(Base.isopen(timer_ticker));  # 返回值 Bool，查看計時器是否仍然處於活動狀態;
    # Base.wait(timer_ticker);
    # Base.sleep(5);
    # Base.close(timer_ticker);  # 清除延時監聽動作;
    # # println(Base.isopen(timer_ticker));  # 返回值 Bool，查看計時器是否仍然處於活動狀態;

    return [Base.string(Distributed.myid()), monitor_file, output_file]; # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
end

function monitor_file_Run(;
    is_monitor::Core.Bool = false,  # 用於判別是執行一次，還是啓動監聽服務，持續監聽目標文檔，false 值表示只執行一次，true 值表示啓動監聽服務器看守進程持續監聽;
    monitor_file::Core.String = Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary", "intermediary_write_NodeJS.txt"),  # 用於接收傳值的媒介文檔;
    monitor_dir::Core.String = Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary"),  # 用於輸入傳值的媒介目錄，當前路徑 Base.@__DIR__;
    do_Function = (argument) -> begin argument; end,  # 用於接收執行數據處理功能的函數;
    output_dir::Core.String = Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary"),  # 用於輸出傳值的媒介目錄，當前路徑 Base.@__DIR__;
    output_file::Core.String = Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary", "intermediary_write_Julia.txt"),  # 用於輸出傳值的媒介文檔;
    to_executable::Core.String = Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node,exe"),  # 用於對返回數據執行功能的解釋器二進制可執行檔;
    to_script::Core.String = Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js"),  # 用於對返回數據執行功能的被調用的脚本文檔;
    temp_cache_IO_data_dir::Core.String = Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary"),  # 用於暫存傳入傳出數據的臨時媒介文件夾，當前路徑 Base.@__DIR__;
    number_Worker_threads::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.UInt8(Base.Sys.CPU_THREADS),  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目;
    time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0.02),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
    read_file_do_Function = read_file_do_Function,  # 從指定的硬盤文檔讀取數據字符串，並調用相應的數據處理函數處理數據，然後將處理得到的結果再寫入指定的硬盤文檔;
    monitor_file_do_Function = monitor_file_do_Function,  # 自動監聽指定的硬盤文檔，當硬盤指定目錄出現指定監聽的文檔時，就調用讀文檔處理數據函數;
    isMonitorThreadsOrProcesses::Core.Union{Core.String, Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = "0",  # 0 || "0" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
    isDoTasksOrThreads::Core.String = "Tasks" # "Tasks" || "Multi-Threading"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
) ::Core.Array{Core.Any, 1}

    # # print("當前協程 task: ", Base.current_task(), "\n");
    # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
    # print("當前綫程 thread 的 ID: ", Base.Threads.threadid(), "\n");
    # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
    # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
    # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
    # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
    # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
    # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
    # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
    # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
    # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
    # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
    # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
    # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
    # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

    # println(Base.Sys.CPU_THREADS)  # 4 可用 CPU 數;
    # println(Base.Filesystem.ispath(Base.Filesystem.pwd()))  # true 判斷目錄是否存在;
    # println(Base.Sys.BINDIR)  # C:\Program Files\Julia 1.5.1\bin;
    # println(Base.PROGRAM_FILE)  # c:\Users\china\Documents\Node.js\Criss\jl\tempCodeRunnerFile.jl;
    # println(Base.Filesystem.basename(Base.Filesystem.pwd()))  # Criss;
    # # "File_Directory_and_Path";
    # println(Base.Filesystem.homedir())  # C:\Users\china;
    # println(Base.Filesystem.pwd())  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath("."))  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js\Criss;
    # # 获取路径的目录;
    # println(Base.Filesystem.dirname(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js;
    # # "/Users/juliauser/Functions_Scripts_Codes_Pipelines/Julia_Codes";
    # # 路径的末端分割;
    # println(Base.Filesystem.splitdir(Base.Filesystem.pwd()));
    # # ("c:\\Users\\china\\Documents\\Node.js", "Criss");
    # # 路径的合成;
    # println(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "temp", "intermediary_write_NodeJS.txt"));  # c:\Users\china\Documents\Node.js\temp\intermediary_write_NodeJS.txt;
    # # Base.Filesystem.cd()  # 更換工作目錄;
    # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl"))
    # # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl").mode) # 返回值為 Core.UInt64 類型數值，例如 Core.UInt64(33206);

    if is_monitor === true

        function func_Exit()

            # if isMonitorThreadsOrProcesses === "Multi-Processes" || isMonitorThreadsOrProcesses === "Multi-Threading"

            #     RemoteChannel_Data_Dict = Base.Dict{Core.String, Core.Any}(
            #         # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
            #         "monitor_file" => monitor_file,
            #         "monitor_dir" => monitor_dir,
            #         # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
            #         "output_dir" => output_dir,
            #         "output_file" => output_file,
            #         "temp_cache_IO_data_dir" => temp_cache_IO_data_dir,
            #         "to_executable" => to_executable,
            #         "to_script" => to_script,
            #         "input_queues_array" => input_queues_array,
            #         "output_queues_array" => output_queues_array,
            #         "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
            #         "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
            #         "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
            #         "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            #         "label" => "exit",
            #         "message" => "exit worker process."
            #     );

            #     if Base.isopen(rc2to)
            #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_file() > worker process-2 be exit.";
            #         Base.put!(rc2to, RemoteChannel_Data_Dict);
            #         Base.close(rc2to);
            #     end

            #     if Base.isopen(rc3to)
            #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_input_queues() > worker process-3 be exit.";
            #         Base.put!(rc3to, RemoteChannel_Data_Dict);
            #         Base.close(rc3to);
            #     end

            #     if Base.isopen(rc4to)
            #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_output_queues() > worker process-4 be exit.";
            #         Base.put!(rc4to, RemoteChannel_Data_Dict);
            #         Base.close(rc4to);
            #     end

            #     RemoteChannel_Data_Dict = Core.nothing;

            #     if Base.isready(rc2from)
            #         # from2rcDict = Base.take!(rc2from);
            #         for from2rcDict in rc2from
            #             # input_queues_array = from2rcDict["input_queues_array"];
            #             # output_queues_array = from2rcDict["output_queues_array"];
            #             if from2rcDict["label"] === "exit"
            #                 println(from2rcDict["message"]);
            #             end
            #         end
            #         # from2rcDict = Core.nothing;
            #     end

            #     if Base.isready(rc3from)
            #         # from3rcDict = Base.take!(rc3from);
            #         for from3rcDict in rc3from
            #             # input_queues_array = from3rcDict["input_queues_array"];
            #             # output_queues_array = from3rcDict["output_queues_array"];
            #             if from3rcDict["label"] === "exit"
            #                 println(from3rcDict["message"]);
            #             end
            #         end
            #         # from3rcDict = Core.nothing;
            #     end

            #     if Base.isready(rc4from)
            #         # from4rcDict = Base.take!(rc4from);
            #         for from4rcDict in rc4from
            #             # input_queues_array = from4rcDict["input_queues_array"];
            #             # output_queues_array = from4rcDict["output_queues_array"];
            #             if from4rcDict["label"] === "exit"
            #                 println(from4rcDict["message"]);
            #             end
            #         end
            #         # from4rcDict = Core.nothing;
            #     end
            # end
        end
        Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

        worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.Task}()，保存每個創建的子進程的字典;
        # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
        total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
        resultArray::Core.Array{Core.Any, 1} = ["", "", total_worker_called_number];

        # 監聽 'SIGINT' 信號，當 Julia 進程接收到 'SIGINT' 信號時，會觸發該事件;
        # 'SIGHUP' 信號在 Windows 平臺上當控制臺使用鍵盤輸入 [ Ctrl ] + [ c ] 窗口被關閉時會被觸發，在其它平臺上在相似的條件下也會被觸發;
        # 修改 Julia 解釋器 jl_exit_on_sigint 模組的變量 Cint 的值為 0（預設值為 1），使在執行代碼脚本文檔的時候，接收到鍵盤 Ctrl + c 信號，抛出 Core.UndefVarError 錯誤;
        # 預設的只有在控制臺交互的時候，解釋器 jl_exit_on_sigint 模組的變量 Cint 的值預設值為 0，在接收到鍵盤 Ctrl + c 信號時，會抛出 Core.UndefVarError 錯誤；
        # 但是在執行代碼脚本文檔的時候，解釋器 jl_exit_on_sigint 模組的變量 Cint 的值預設值為 1，，在接收到鍵盤 Ctrl + c 信號時，并不會抛出 Core.UndefVarError 錯誤；
        ccall(:jl_exit_on_sigint, Cvoid, (Cint,), 0);  # 修改 Julia 解釋器 jl_exit_on_sigint 模組的變量 Cint 的值為 0（預設值為 1），使在執行代碼脚本文檔的時候，接收到鍵盤 Ctrl + c 信號，抛出 Core.UndefVarError 錯誤;
        try
            println("進程: process-" * Base.string(Distributed.myid()) * " , 執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在監聽目錄「 " * Base.string(Base.Filesystem.abspath(monitor_dir)) * " 」文檔「 " * Base.string(Base.Filesystem.abspath(monitor_file)) * " 」 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on directory [ " * Base.string(Base.Filesystem.abspath(monitor_dir)) * " ] file [ " * Base.string(Base.Filesystem.abspath(monitor_file)) * " ] ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            println("Cache directory [ " * Base.string(Base.Filesystem.abspath(temp_cache_IO_data_dir)) * " ].");
            println("Export at the directory [ " * Base.string(Base.Filesystem.abspath(output_dir)) * " ] file [ " * Base.string(Base.Filesystem.abspath(output_file)) * " ].");
            println("Import data interface JSON String: {\"Client_say\":\"這裏是需要傳入的數據字符串 this is import string data\"}.");
            println("Export data interface JSON String: {\"Server_say\":\"這裏是處理後傳出的數據字符串 this is export string data\"}.");
            println("Keyboard Enter [ Ctrl ] + [ c ] to close.");
            println("鍵盤輸入 [ Ctrl ] + [ c ] 中止運行.");
            print("\n");

            # result = Array{Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}(Core.nothing, 3);
            result = monitor_file_do_Function(
                monitor_file,
                monitor_dir,
                do_Function,
                output_dir,
                output_file,
                to_executable,
                to_script,
                temp_cache_IO_data_dir,
                number_Worker_threads,
                time_sleep,
                read_file_do_Function;
                isMonitorThreadsOrProcesses=isMonitorThreadsOrProcesses,
                isDoTasksOrThreads=isDoTasksOrThreads,
                worker_queues_Dict=worker_queues_Dict,
                total_worker_called_number=total_worker_called_number
            );

            if Base.typeof(result) <: Core.Array
                # && Base.length(result) >= 3

                # resultArray::Core.Array{Core.Any, 1} = ["", "", total_worker_called_number];
                resultArray = result;
                # resultArray[1] = result[1];
                # resultArray[2] = result[2];
                # resultArray[3] = result[3];
                # println(typeof(resultArray));
                # println(resultArray[1]);
                # println(resultArray[2]);
                # println(resultArray[3]);
            elseif Base.@isdefined(result)
                resultArray = ["error", result, total_worker_called_number];
            else
                resultArray = ["error", "", total_worker_called_number];
            end

        catch myException
            # println(Base.typeof(myException));
            # println(myException);
            # println(myException.msg);
            # 使用 Core.isa(myException, Core.InterruptException) 函數判斷 myException 的類型是否爲 Core.InterruptException;
            if Core.isa(myException, Core.InterruptException)

                print("\n");
                # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                println("[ Ctrl ] + [ c ] received, will be stop the file monitor server.");

                # 打印進程被調用數目;
                if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                    # if isDoTasksOrThreads === "Multi-Processes"

                    #     # Base.haskey(collection, key) -> Bool
                    #     # workNum = "worker";
                    #     for k in Base.keys(total_worker_called_number)
                    #         println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                    #         # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                    #     end
                    #     # println(workNum);

                    # elseif isDoTasksOrThreads === "Multi-Threading" || isDoTasksOrThreads === "Tasks"

                    #     # Base.haskey(collection, key) -> Bool
                    #     # workNum = "worker";
                    #     for k in Base.keys(total_worker_called_number)
                    #         println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                    #         # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                    #     end
                    #     # println(workNum);

                    # end

                    total_worker_called_number = Core.nothing;
                end

                # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                    # Base.haskey(collection, key) -> Bool
                    # for k in Base.keys(worker_queues_Dict)
                    #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                    # end

                    worker_queues_Dict = Core.nothing;
                end

                # 清空用於暫存輸入輸出數據的臨時媒介文件夾 temp_cache_IO_data_dir;
                if temp_cache_IO_data_dir !== output_dir && Base.Filesystem.ispath(temp_cache_IO_data_dir) && Base.Filesystem.isdir(temp_cache_IO_data_dir) && Base.length(Base.Filesystem.readdir(temp_cache_IO_data_dir)) > 0

                    # println("Clear the temporary interface directory [ $temp_cache_IO_data_dir ].");
                    println("Clear the temporary interface directory [ " * temp_cache_IO_data_dir * " ].");

                    # # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                    # # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                    # Base.Filesystem.rm(temp_cache_IO_data_dir; force=false, recursive=true);  # 參數 force=true 表示如果路徑不存在也不會被視爲錯誤，。參數 recursive=true 且如果路徑為目錄，則遞歸刪除目錄下所有内容;
                    # Base.Filesystem.mkpath(temp_cache_IO_data_dir, mode=0o777);  # 同步遞歸創建目錄，返回值(return) path;

                    for f in Base.Filesystem.readdir(temp_cache_IO_data_dir)
                        # println(Base.Filesystem.joinpath(temp_cache_IO_data_dir, f));

                        # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                        # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                        Base.Filesystem.rm(Base.Filesystem.joinpath(temp_cache_IO_data_dir, f); force=false, recursive=true);
                    end
                end

                # 清空用於輸入數據的媒介文件夾 monitor_dir;
                if monitor_dir !== output_dir && Base.Filesystem.ispath(monitor_dir) && Base.Filesystem.isdir(monitor_dir) && Base.length(Base.Filesystem.readdir(monitor_dir)) > 0

                    # println("Clear the import data interface directory [ $monitor_dir ].");
                    println("Clear the import data interface directory [ " * monitor_dir * " ].");

                    # # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                    # # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                    # Base.Filesystem.rm(monitor_dir; force=false, recursive=true);  # 參數 force=true 表示如果路徑不存在也不會被視爲錯誤，。參數 recursive=true 且如果路徑為目錄，則遞歸刪除目錄下所有内容;
                    # Base.Filesystem.mkpath(monitor_dir, mode=0o777);  # 同步遞歸創建目錄，返回值(return) path;

                    for f in Base.Filesystem.readdir(monitor_dir)
                        # println(Base.Filesystem.joinpath(monitor_dir, f));

                        # Base.Filesystem.rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
                        # Delete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.
                        Base.Filesystem.rm(Base.Filesystem.joinpath(monitor_dir, f); force=false, recursive=true);
                    end
                end

                println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                # Base.exit(0);
                return resultArray;
            else
                println(myException);
            end
        end

        # return resultArray;
    else

        # # 判斷傳入的參數用於傳入數據的媒介文檔路徑全名 monitor_file 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(monitor_file) 判斷 monitor_file 變量是否已經被定義過;
        # if !Base.@isdefined(monitor_file) || monitor_file === "" || monitor_file === Core.nothing
        #     # local monitor_file = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary", "intermediary_write_NodeJS.txt"));  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(monitor_dir, "Intermediary", "intermediary_write_NodeJS.txt")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於接收傳值的媒介文檔 "../Intermediary/intermediary_write_NodeJS.txt";
        #     # local monitor_file = Core.nothing;  # 置空;
        #     println("用於傳入數據的媒介文檔路徑全名「monitor_file ∈ ", Base.typeof(monitor_file), "」不能被識別.");
        #     return ["error", monitor_file, "argument [ monitor_file = " * Base.string(monitor_file) * " ] typeof error, no defined."];  # "用於傳入數據的媒介文檔路徑全名「monitor_file = " * Base.string(Base.typeof(monitor_file)) * "」不能被識別.";
        # elseif !Core.isa(monitor_file, Core.String)
        #     # 使用 Core.isa(monitor_file, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(monitor_file) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(monitor_file) === Core.String 方法判別 monitor_file 變量的類型是否為字符串 Core.String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        #     println("用於傳入數據的媒介文檔路徑全名「monitor_file ∈ ", Base.typeof(monitor_file), "」不合法，只接受輸入文檔路徑全名字符串.");
        #     return ["error", monitor_file, "argument [ monitor_file = " * Base.string(monitor_file) * " ] typeof error, not String."];  # ["error", monitor_file, "用於傳入數據的媒介文檔路徑全名「monitor_file = " * Base.string(Base.typeof(monitor_file)) * "」不合法，只接受輸入文檔路徑全名字符串."];
        # end

        # # 判斷傳入的參數用於傳出數據的媒介文檔路徑全名 output_file 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(output_file) 判斷 output_file 變量是否已經被定義過;
        # if !Base.@isdefined(output_file) || output_file === "" || output_file === Core.nothing
        #     # local output_file = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary", "intermediary_write_Julia.txt"));  # Core.String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(output_dir, "Intermediary", "intermediary_write_Julia.txt")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介文檔 "../Intermediary/intermediary_write_Julia.txt";
        #     # local output_file = Core.nothing;  # 置空;
        #     println("用於傳出數據的媒介文檔路徑全名「output_file ∈ ", Base.typeof(output_file), "」不能被識別.");
        #     return ["error", output_file, "argument [ output_file = " * Base.string(output_file) * " ] typeof error, no defined."];  # "用於傳出數據的媒介文檔路徑全名「output_file = " * Base.string(Base.typeof(output_file)) * "」不能被識別.";
        # elseif !Core.isa(output_file, Core.String)
        #     # 使用 Core.isa(output_file, String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(output_file) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(output_file) === Core.String 方法判別 output_file 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        #     println("用於傳出數據的媒介文檔路徑全名「output_file ∈ ", Base.typeof(output_file), "」不合法，只接受輸入文檔路徑全名字符串.");
        #     return ["error", output_file, "argument [ output_file = " * Base.string(output_file) * " ] typeof error, not String."];  # ["error", output_file, "用於傳出數據的媒介文檔路徑全名「output_file = " * Base.string(Base.typeof(output_file)) * "」不合法，只接受輸入文檔路徑全名字符串."];
        # end

        # # 判斷傳入的參數用於傳入數據的媒介目錄（文件夾）monitor_dir 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(monitor_dir) 判斷 monitor_dir 變量是否已經被定義過;
        # if !Base.@isdefined(monitor_dir) || monitor_dir === "" || monitor_dir === Core.nothing
        #     # local monitor_dir = Base.string(Base.Filesystem.splitdir(monitor_file)[1]);  # Core.String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸入傳值的媒介目錄 "../Intermediary/";
        #     monitor_dir = Base.string(Base.Filesystem.splitdir(monitor_file)[1]);  # Core.String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸入傳值的媒介目錄 "../Intermediary/";
        #     # Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組;
        #     # local monitor_dir = Core.nothing;  # 置空;
        #     println("用於傳入數據的媒介目錄（文件夾）「monitor_dir ∈ ", Base.typeof(monitor_dir), "」不能被識別.");
        #     # return ["error", monitor_dir, "argument [ monitor_dir = " * Base.string(monitor_dir) * " ] typeof error, no defined."];  # "用於傳入數據的媒介目錄（文件夾）「monitor_dir = " * Base.string(Base.typeof(monitor_dir)) * "」不能被識別.";
        # elseif !Core.isa(monitor_dir, Core.String)
        #     # 使用 Core.isa(monitor_dir, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(monitor_dir) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(monitor_dir) === Core.String 方法判別 monitor_dir 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        #     println("用於傳入數據的媒介目錄（文件夾）「monitor_dir ∈ ", Base.typeof(monitor_dir), "」不合法，只接受輸入文檔路徑全名字符串.");
        #     return ["error", monitor_dir, "argument [ monitor_dir = " * Base.string(monitor_dir) * " ] typeof error, not String."];  # "用於傳入數據的媒介目錄（文件夾）「monitor_dir = " * Base.string(Base.typeof(monitor_dir)) * "」不合法，只接受輸入目錄（文件夾）全名字符串.";
        # elseif monitor_dir !== Base.string(Base.Filesystem.splitdir(monitor_file)[1])
        #     # # 使用 Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組，Base.Filesystem.splitdir(monitor_file) 將 monitor_file 拆分爲 (輸入媒介目錄, 輸入媒介文檔名) 兩部分;
        #     # println("用於傳入數據的媒介目錄（文件夾）「monitor_dir ∈ ", Base.typeof(monitor_dir), "」不合法，與 monitor_file 文檔所在目錄不同.");
        #     # return ["error", monitor_dir, "argument [ monitor_dir = " * Base.string(monitor_dir) * " ] typeof error, not content monitor_file."];  # "用於傳入數據的媒介目錄（文件夾）「monitor_dir = " * Base.string(Base.typeof(monitor_dir)) * "」不合法，與 monitor_file 文檔所在目錄不同.";
        # end

        # # 判斷傳入的參數用於傳出數據的媒介目錄（文件夾）output_dir 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(output_dir) 判斷 output_dir 變量是否已經被定義過;
        # if !Base.@isdefined(output_dir) || output_dir === "" || output_dir === Core.nothing
        #     # local output_dir = Base.string(Base.Filesystem.splitdir(output_file)[1]);  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介目錄 "../Intermediary/";
        #     output_dir = Base.string(Base.Filesystem.splitdir(output_file)[1]);  # String 類型變量，上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介目錄 "../Intermediary/";
        #     # Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組;
        #     # local output_dir = Core.nothing;  # 置空;
        #     println("用於傳出數據的媒介目錄（文件夾）「output_dir ∈ ", Base.typeof(output_dir), "」不能被識別.");
        #     # return ["error", output_dir, "argument [ output_dir = " * Base.string(output_dir) * " ] typeof error, no defined."];  # "用於傳出數據的媒介目錄（文件夾）「output_dir = " * Base.string(Base.typeof(output_dir)) * "」不能被識別.";
        # elseif !Core.isa(output_dir, Core.String)
        #     # 使用 Core.isa(output_dir, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(output_dir) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(output_dir) === Core.String 方法判別 output_dir 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        #     println("用於傳出數據的媒介目錄（文件夾）「output_dir ∈ ", Base.typeof(output_dir), "」不合法，只接受輸入文檔路徑全名字符串.");
        #     return ["error", output_dir, "argument [ output_dir = " * Base.string(output_dir) * " ] typeof error, not String."];  # "用於傳出數據的媒介目錄（文件夾）「output_dir = " * Base.string(Base.typeof(output_dir)) * "」不合法，只接受輸入目錄（文件夾）全名字符串.";
        # elseif output_dir !== Base.string(Base.Filesystem.splitdir(output_file)[1])
        #     # # 使用 Base.Filesystem.splitdir() 函數表示拆分路徑字符串為組件數組，Base.Filesystem.splitdir(output_file) 將 output_file 拆分爲 (輸出媒介目錄, 輸出媒介文檔名) 兩部分;
        #     # println("用於傳出數據的媒介目錄（文件夾）「output_dir ∈ ", Base.typeof(output_dir), "」不合法，與 output_file 文檔所在目錄不同.");
        #     # return ["error", output_dir, "argument [ output_dir = " * Base.string(output_dir) * " ] typeof error, not content output_file."];  # "用於傳出數據的媒介目錄（文件夾）「output_dir = " * Base.string(Base.typeof(output_dir)) * "」不合法，與 output_file 文檔所在目錄不同.";
        # end

        # # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介目錄（文件夾）是否存在，如果不存在，則創建目錄，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
        # # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isdir(monitor_dir) 方法判斷是否為目錄（文件夾）;
        # if !(Base.Filesystem.ispath(monitor_dir) && Base.Filesystem.isdir(monitor_dir))
        #     println("用於傳值的媒介文件夾 [ " * monitor_dir * " ] 不存在.");
        #     return ["error", monitor_dir, "path [ monitor_dir = " * Base.string(monitor_dir) * " ] not existence."];
        # elseif Base.stat(monitor_dir).mode !== Core.UInt64(16822) && Base.stat(monitor_dir).mode !== Core.UInt64(16895)
        #     # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(monitor_dir) 函數讀取文檔信息，使用 Base.stat(monitor_dir).mode 方法提取文檔權限碼;
        #     # println("用於傳值的媒介文件夾 [ " * monitor_dir * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
        #     try
        #         # 使用 Base.Filesystem.chmod(monitor_dir, mode=0o777; recursive=true) 函數修改文檔操作權限;
        #         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
        #         Base.Filesystem.chmod(monitor_dir, mode=0o777; recursive=true);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
        #         # println("目錄: " * monitor_dir * " 操作權限成功修改爲 mode=0o777 .");

        #         # 八進制值    說明
        #         # 0o400      所有者可讀
        #         # 0o200      所有者可寫
        #         # 0o100      所有者可執行或搜索
        #         # 0o40       群組可讀
        #         # 0o20       群組可寫
        #         # 0o10       群組可執行或搜索
        #         # 0o4        其他人可讀
        #         # 0o2        其他人可寫
        #         # 0o1        其他人可執行或搜索
        #         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
        #         # 數字	說明
        #         # 7	可讀、可寫、可執行
        #         # 6	可讀、可寫
        #         # 5	可讀、可執行
        #         # 4	唯讀
        #         # 3	可寫、可執行
        #         # 2	只寫
        #         # 1	只可執行
        #         # 0	沒有許可權
        #         # 例如，八進制值 0o765 表示：
        #         # 1) 、所有者可以讀取、寫入和執行該文檔；
        #         # 2) 、群組可以讀和寫入該文檔；
        #         # 3) 、其他人可以讀取和執行該文檔；
        #         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
        #         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

        #     catch err
        #         println("用於輸入數據的媒介文件夾: " * monitor_dir * " 無法修改操作權限爲 mode=0o777 .");
        #         println(err);
        #         # println(Base.typeof(err));
        #         return ["error", monitor_dir, "path [ monitor_dir = " * Base.string(monitor_dir) * " ] change the permissions mode=0o777 fail."];
        #     end
        # end

        # if !(Base.Filesystem.ispath(output_dir) && Base.Filesystem.isdir(output_dir))
        #     println("用於傳值的媒介文件夾 [ " * output_dir * " ] 不存在.");
        #     return ["error", output_dir, "path [ output dir = " * Base.string(output_dir) * " ] not existence."];
        # elseif Base.stat(output_dir).mode !== Core.UInt64(16822) && Base.stat(output_dir).mode !== Core.UInt64(16895)
        #     # 十進制 16822 等於八進制 40666，十進制 16895 等於八進制 40777，修改文件夾權限，使用 Base.stat(output_dir) 函數讀取文檔信息，使用 Base.stat(output_dir).mode 方法提取文檔權限碼;
        #     # println("用於傳值的媒介文件夾 [ " * output_dir * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
        #     try
        #         # 使用 Base.Filesystem.chmod(output_dir, mode=0o777; recursive=true) 函數修改文檔操作權限;
        #         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
        #         Base.Filesystem.chmod(output_dir, mode=0o777; recursive=true);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
        #         # println("目錄: " * output_dir * " 操作權限成功修改爲 mode=0o777 .");

        #         # 八進制值    說明
        #         # 0o400      所有者可讀
        #         # 0o200      所有者可寫
        #         # 0o100      所有者可執行或搜索
        #         # 0o40       群組可讀
        #         # 0o20       群組可寫
        #         # 0o10       群組可執行或搜索
        #         # 0o4        其他人可讀
        #         # 0o2        其他人可寫
        #         # 0o1        其他人可執行或搜索
        #         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
        #         # 數字	說明
        #         # 7	可讀、可寫、可執行
        #         # 6	可讀、可寫
        #         # 5	可讀、可執行
        #         # 4	唯讀
        #         # 3	可寫、可執行
        #         # 2	只寫
        #         # 1	只可執行
        #         # 0	沒有許可權
        #         # 例如，八進制值 0o765 表示：
        #         # 1) 、所有者可以讀取、寫入和執行該文檔；
        #         # 2) 、群組可以讀和寫入該文檔；
        #         # 3) 、其他人可以讀取和執行該文檔；
        #         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
        #         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

        #     catch err
        #         println("用於輸出數據的媒介文件夾: " * output_dir * " 無法修改操作權限爲 mode=0o777 .");
        #         println(err);
        #         # println(err.msg);
        #         # println(Base.typeof(err));
        #         return ["error", output_dir, "path [ output dir = " * Base.string(output_dir) * " ] change the permissions mode=0o777 fail."];
        #     end
        # end

        # # 可以先改變工作目錄到 static 路徑;
        # println("Starting directory: ", Base.Filesystem.abspath(Base.Filesystem.pwd()));  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
        # try
        #     Base.Filesystem.cd(monitor_dir);  # 更換工作目錄;
        # catch err
        #     println(err);

        #     Julia提供了許多類型的錯誤：
        #     ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
        #     AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
        #     BoundsError：在索引陣列時嘗試訪問越界元素。
        #     DivideError：這是數字除以0時的結果。
        #     DomainError：有效域之外的參數。
        #     EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
        #     InexactError：嘗試進行精確類型轉換失敗。
        #     KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
        #     LoadError：載入檔時發生錯誤。
        #     MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
        #     OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
        #     ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
        #     OverflowError：當操作結果太大時會發生這種情況。
        #     ParseError：解析給定運算式時出現問題。
        #     StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
        #     SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
        #     UndefRefError：未知引用。
        #     UndefVarError：對不存在的變數進行未知引用。
        #     InitError：調用模組的init方法時出現此錯誤。
        #     ErrorException：發生錯誤InterruptException：計算中發生外部中斷
        #     NullException：嘗試訪問Null值
        #     ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤
        # end
        # 同步讀取指定文件夾的内容 Base.Filesystem.readdir();

        # 使用 Julia 原生的基礎模組 Base 中的 Base.Filesystem 模塊中的 Base.Filesystem.ispath() 函數判斷指定的用於傳入數據的媒介文檔是否存在，如果不存在，則中止函數退出，如果存在則判斷操作權限，並為所有者和組用戶提供讀、寫、執行權限，默認模式為 0o777;
        # 同步判斷，使用 Julia 原生模組 Base.Filesystem.isfile(monitor_file) 方法判斷是否為文檔;
        if !(Base.Filesystem.ispath(monitor_file) && Base.Filesystem.isfile(monitor_file))
            println("用於輸入數據的媒介文檔: " * monitor_file * " 無法識別或不存在.");
            return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] not recognition."];
        elseif Base.stat(monitor_file).mode !== Core.UInt64(33206) && Base.stat(monitor_file).mode !== Core.UInt64(33279)
            # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(monitor_file) 函數讀取文檔信息，使用 Base.stat(monitor_file).mode 方法提取文檔權限碼;
            # println("用於傳值的媒介文檔 [ " * monitor_file * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
            try
                # 使用 Base.Filesystem.chmod(monitor_file, mode=0o777; recursive=false) 函數修改文檔操作權限;
                # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
                Base.Filesystem.chmod(monitor_file, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
                # println("文檔: " * monitor_file * " 操作權限成功修改爲 mode=0o777 .");

                # 八進制值    說明
                # 0o400      所有者可讀
                # 0o200      所有者可寫
                # 0o100      所有者可執行或搜索
                # 0o40       群組可讀
                # 0o20       群組可寫
                # 0o10       群組可執行或搜索
                # 0o4        其他人可讀
                # 0o2        其他人可寫
                # 0o1        其他人可執行或搜索
                # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
                # 數字	說明
                # 7	可讀、可寫、可執行
                # 6	可讀、可寫
                # 5	可讀、可執行
                # 4	唯讀
                # 3	可寫、可執行
                # 2	只寫
                # 1	只可執行
                # 0	沒有許可權
                # 例如，八進制值 0o765 表示：
                # 1) 、所有者可以讀取、寫入和執行該文檔；
                # 2) 、群組可以讀和寫入該文檔；
                # 3) 、其他人可以讀取和執行該文檔；
                # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
                # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

            catch err
                println("用於輸入數據的媒介文檔: " * monitor_file * " 無法修改操作權限爲 mode=0o777 .");
                println(err);
                # println(Base.typeof(err));
                return ["error", monitor_file, "document [ monitor file = " * Base.string(monitor_file) * " ] change the permissions mode=0o777 fail."];
            end
        end

        # result = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();
        result = read_file_do_Function(
            monitor_file,
            monitor_dir,
            do_Function,
            output_dir,
            output_file,
            to_executable,
            to_script,
            time_sleep
        );
        # println(result);

        resultArray = ["error", "read_file_do_Function", "function < read_file_do_Function() > run error."];  # ::Core.Array{Core.Any, 1} = ["error", "read_file_do_Function", "function < read_file_do_Function() > run error."];
        if Base.typeof(result) <: Core.Array && Base.length(result) >= 3

            if result[1] === "error"
                println("函數 read_file_do_Function() 運行錯誤.");
                # println("function < read_file_do_Function() > return error.");
                return [result[1], result[2], "function < read_file_do_Function() > return error -> " * Base.string(result[3])];
            end

            # resultArray::Core.Array{Core.Any, 1} = ["", "", total_worker_called_number];
            resultArray = result;
            # resultArray[1] = result[1];
            # resultArray[2] = result[2];
            # resultArray[3] = result[3];
            # println(typeof(resultArray));
            # println(resultArray[1]);
            # println(resultArray[2]);
            # println(resultArray[3]);
        end

        # 使用 a = Base.read(`bash -c C:/node.exe C:/Cross/test.js a=5 b=6`, Core.String) 調用 shell 語句反饋，運算處理完之後，給調用語言的回復，然後再獲取返回值;
        if Base.Filesystem.ispath(output_file) && Base.Filesystem.isfile(output_file)

            # # 判斷變量 to_executable 已被定義且類型取值合法，Core.isa(to_executable, Core.String) 與 Base.typeof(to_executable) === Core.String 等效;
            # # local to_executable = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe"));  # String 類型變量，上一層路徑下的Node.JS解釋器可執行檔路徑C:\nodejs\node.exe：Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node.exe")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的解釋器可執行文件 "..\\NodeJS\\node.exe"，Julia 解釋器可執行檔全名 println(Base.Sys.BINDIR)：C:\Julia 1.5.1\bin，;
            # # local to_executable = Core.nothing;  # 置空;
            # if Base.@isdefined(to_executable) && to_executable !== Core.nothing && Core.isa(to_executable, Core.String) && to_executable !== ""

            #     # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否存在;
            #     if Base.Filesystem.ispath(to_executable) && Base.Filesystem.isfile(to_executable)

            #         # 同步判斷，反饋目標解釋器可執行檔 to_executable 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
            #         if Base.stat(to_executable).mode !== Core.UInt64(33206) && Base.stat(to_executable).mode !== Core.UInt64(33279)
            #             # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
            #             println("回調程序二進制可執行檔 [ " * to_executable * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
            #             try
            #                 # 使用 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false) 函數修改文檔操作權限;
            #                 # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
            #                 Base.Filesystem.chmod(to_executable, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
            #                 # println("回調程序二進制可執行檔: " * to_executable * " 操作權限成功修改爲 mode=0o777 .");

            #                 # 八進制值    說明
            #                 # 0o400      所有者可讀
            #                 # 0o200      所有者可寫
            #                 # 0o100      所有者可執行或搜索
            #                 # 0o40       群組可讀
            #                 # 0o20       群組可寫
            #                 # 0o10       群組可執行或搜索
            #                 # 0o4        其他人可讀
            #                 # 0o2        其他人可寫
            #                 # 0o1        其他人可執行或搜索
            #                 # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
            #                 # 數字	說明
            #                 # 7	可讀、可寫、可執行
            #                 # 6	可讀、可寫
            #                 # 5	可讀、可執行
            #                 # 4	唯讀
            #                 # 3	可寫、可執行
            #                 # 2	只寫
            #                 # 1	只可執行
            #                 # 0	沒有許可權
            #                 # 例如，八進制值 0o765 表示：
            #                 # 1) 、所有者可以讀取、寫入和執行該文檔；
            #                 # 2) 、群組可以讀和寫入該文檔；
            #                 # 3) 、其他人可以讀取和執行該文檔；
            #                 # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
            #                 # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

            #             catch err
            #                 println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
            #                 println(err);
            #                 # println(err.msg);
            #                 # println(Base.typeof(err));
            #                 return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
            #             end
            #         end

            #         # # 判斷可執行檔 to_executable 權限是否修改成功;
            #         # if !(Base.stat(to_executable).mode === Core.UInt64(33206) || Base.stat(to_executable).mode === Core.UInt64(33279))
            #         #     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_executable) 函數讀取文檔信息，使用 Base.stat(to_executable).mode 方法提取文檔權限碼;
            #         #     println("回調程序二進制可執行檔: " * to_executable * " 無法修改操作權限爲 mode=0o777 .");
            #         #     return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] change the permission Execute mode=0o777 fail."];
            #         # end

            #         # 判斷變量 to_script 已被定義且類型取值合法，Core.isa(to_script, Core.String) 與 Base.typeof(to_script) === Core.String 等效;
            #         # local to_script = Base.string(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js"));  # String 類型變量，上一層路徑下的 JavaScript 脚本路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的被調用的脚本文檔 "../js/Ruuter.js";
            #         # local to_script = Core.nothing;  # 置空;
            #         if Base.@isdefined(to_script) && to_script !== Core.nothing && Core.isa(to_script, Core.String) && to_script !== ""
            #             # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否存在;
            #             if Base.Filesystem.ispath(to_script) && Base.Filesystem.isfile(to_script)
            #                 # 同步判斷，反饋目標解釋器可執行檔調用的脚本文檔 to_script 是否可執行，如果不可執行，則嘗試修改權限爲 mode=0o777 或 mode=0o666 ;
            #                 if Base.stat(to_script).mode !== Core.UInt64(33206) && Base.stat(to_script).mode !== Core.UInt64(33279)
            #                     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
            #                     println("回調程序二進制可執行檔調用的脚本文檔 [ " * to_script * " ] 操作權限不爲 mode=0o777 或 mode=0o666 .");
            #                     try
            #                         # 使用 Base.Filesystem.chmod(to_script, mode=0o777; recursive=false) 函數修改文檔操作權限;
            #                         # Base.Filesystem.chmod(path::AbstractString, mode::Integer; recursive::Bool=false)  # Return path;
            #                         Base.Filesystem.chmod(to_script, mode=0o777; recursive=false);  # recursive=true 表示遞歸修改文件夾下所有文檔權限;
            #                         # println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 操作權限成功修改爲 mode=0o777 .");

            #                         # 八進制值    說明
            #                         # 0o400      所有者可讀
            #                         # 0o200      所有者可寫
            #                         # 0o100      所有者可執行或搜索
            #                         # 0o40       群組可讀
            #                         # 0o20       群組可寫
            #                         # 0o10       群組可執行或搜索
            #                         # 0o4        其他人可讀
            #                         # 0o2        其他人可寫
            #                         # 0o1        其他人可執行或搜索
            #                         # 構造 mode 更簡單的方法是使用三個八進位數字的序列（例如 765），最左邊的數位（示例中的 7）指定文檔所有者的許可權，中間的數字（示例中的 6）指定群組的許可權，最右邊的數字（示例中的 5）指定其他人的許可權；
            #                         # 數字	說明
            #                         # 7	可讀、可寫、可執行
            #                         # 6	可讀、可寫
            #                         # 5	可讀、可執行
            #                         # 4	唯讀
            #                         # 3	可寫、可執行
            #                         # 2	只寫
            #                         # 1	只可執行
            #                         # 0	沒有許可權
            #                         # 例如，八進制值 0o765 表示：
            #                         # 1) 、所有者可以讀取、寫入和執行該文檔；
            #                         # 2) 、群組可以讀和寫入該文檔；
            #                         # 3) 、其他人可以讀取和執行該文檔；
            #                         # 當使用期望的文檔模式的原始數字時，任何大於 0o777 的值都可能導致不支持一致的特定於平臺的行為，因此，諸如 S_ISVTX、 S_ISGID 或 S_ISUID 之類的常量不會在 fs.constants 中公開；
            #                         # 注意，在 Windows 系統上，只能更改寫入許可權，並且不會實現群組、所有者或其他人的許可權之間的區別；

            #                     catch err
            #                         println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
            #                         println(err);
            #                         # println(err.msg);
            #                         # println(Base.typeof(err));
            #                         return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
            #                     end
            #                 end

            #                 # # 判斷代碼脚本文檔 to_script 權限是否修改成功;
            #                 # if !(Base.stat(to_script).mode === Core.UInt64(33206) || Base.stat(to_script).mode === Core.UInt64(33279))
            #                 #     # 十進制 33206 等於八進制 100666，十進制 33279 等於八進制 100777，修改文件夾權限，使用 Base.stat(to_script) 函數讀取文檔信息，使用 Base.stat(to_script).mode 方法提取文檔權限碼;
            #                 #     println("回調程序二進制可執行檔調用的脚本文檔: " * to_script * " 無法修改操作權限爲 mode=0o777 .");
            #                 #     return ["error", to_script, "Script code document [ to_script = " * Base.string(to_script) * " ] change the permission Execute mode=0o777 fail."];
            #                 # end
            #             else
            #                 println("回調程序二進制可執行檔調用的脚本文檔路徑全名「to_script = " * Base.string(to_script) * "」不能被識別.");
            #                 return ["error", to_script, "Callback script code document [ to_script = " * Base.string(to_script) * " ] error, no recognition."];
            #             end

            #             textCommand = "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
            #             # Command = `bash -c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
            #             # Command = `cmd /c "$to_executable $to_script output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
            #             Command = `bash -c $textCommand`;

            #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
            #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
            #             # println(Base.typeof(resultBack));
            #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
            #             println(resultBack);
            #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
            #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
            #             # for x in Base.split(resultBack, "\n")
            #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
            #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
            #             # end
            #             # println(backArray);

            #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            #             # Base.GC.gc();  # 内存回收函數 gc();

            #         else
            #             textCommand = "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file";
            #             # Command = `bash -c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
            #             # Command = `cmd /c "$to_executable output_dir=$output_dir output_file=$output_file monitor_dir=$monitor_dir monitor_file=$monitor_file"`;
            #             Command = `bash -c $textCommand`;

            #             # resultBack = run(Command);  # run(Command) 返回值為 Core.nothing，如果外部命令未能成功運行，則抛出 ErrorException 錯誤;
            #             resultBack = Base.read(Command, Core.String);  # 自動 fork 創建一個子進程運行 textCommand 並讀取返回值;
            #             # println(Base.typeof(resultBack));
            #             # println(Base.chomp(resultBack));  # Base.chomp() 刪除字符串的單個尾隨換行符"\n";
            #             println(resultBack);
            #             # # resultBackArr = Base.split(resultBack, "\n");  # 將讀取到的返回值字符串按換行符分割為字符串數組;
            #             # backArray = Core.Array{Core.Union{Core.nothing, Bool, Float64, Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
            #             # for x in Base.split(resultBack, "\n")
            #             #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
            #             #     Base.push!(backArray, x);  # 使用 push! 函數在數組末尾追加推入新元素;
            #             # end
            #             # println(backArray);

            #             textCommand = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            #             Command = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            #             resultBack = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            #             # Base.GC.gc();  # 内存回收函數 gc();
            #         end
            #     else
            #         println("回調程序二進制可執行檔路徑全名「to_executable = " * Base.string(to_executable) * "」不能被識別.");
            #         return ["error", to_executable, "Callback execute document [ to_executable = " * Base.string(to_executable) * " ] error, no recognition."];
            #     end
            # end


            nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            # println(Base.string(nowTime));
            log_text = Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " [ " * monitor_file * " ] -> [ " * output_file * " ].";
            print(log_text * "\n");
            # log_file = "";  # 日志文檔;
            # # 同步寫入用於記錄過程的日志文檔;
            # try
            #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
            #     # # write(filename::AbstractString, x)
            #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
            #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
            #     # println(numBytes);
            #     # println(Base.stat(log_file).size);
            #     # println(Base.stat(log_file).mtime);
            #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            #     # println(Base.stat(log_file).ctime);
            #     # # Base.displaysize([io::IO]) -> (lines, columns)
            #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
            #     # # Base.countlines — Function
            #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
            #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
            #     # println(Base.countlines(log_file, eol='\\n'));

            #     fWIO = Base.open(log_file, "a+");
            #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
            #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

            #     # Keyword	Description				Default
            #     # read		open for reading		!write
            #     # write		open for writing		truncate | append
            #     # create	create if non-existent	!read & write | truncate | append
            #     # truncate	truncate to zero size	!read & write
            #     # append	seek to end				false

            #     # Mode	Description						Keywords
            #     # r		read							none
            #     # w		write, create, truncate			write = true
            #     # a		write, create, append			append = true
            #     # r+	read, write						read = true, write = true
            #     # w+	read, write, create, truncate	truncate = true, read = true
            #     # a+	read, write, create, append		append = true, read = true

            #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
            #     if Base.iswritable(fWIO)
            #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
            #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
            #         println(numBytes);
            #         println(Base.stat(log_file).size);
            #         println(Base.stat(log_file).mtime);
            #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            #         println(Base.stat(log_file).ctime);
            #         # Base.displaysize([io::IO]) -> (lines, columns)
            #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
            #         # Base.countlines — Function
            #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
            #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
            #         println(Base.countlines(log_file, eol='\\n'));
            #     end

            #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
            #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
            #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
            #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
            #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
            #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
            #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
            #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
            #     # Base.ismarked(io);  # Return true if stream s is marked;
            #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
            #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
            #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
            #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
            #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
            #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
            #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
            #     # Base.close(io);  # 關閉緩衝區;
            #     # println(a)
            #     # Base.redirect_stdout — Function
            #     # redirect_stdout([stream]) -> (rd, wr)
            #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
            #     # If called with the optional stream argument, then returns stream itself.
            #     # Base.redirect_stdout — Method
            #     # redirect_stdout(f::Function, stream)
            #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
            #     # Base.redirect_stderr — Function
            #     # redirect_stderr([stream]) -> (rd, wr)
            #     # Like redirect_stdout, but for stderr.
            #     # Base.redirect_stderr — Method
            #     # redirect_stderr(f::Function, stream)
            #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
            #     # Base.redirect_stdin — Function
            #     # redirect_stdin([stream]) -> (rd, wr)
            #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
            #     # Base.redirect_stdin — Method
            #     # redirect_stdin(f::Function, stream)
            #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

            # catch err
            #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
            #     println(err);
            #     # println(Base.typeof(err));
            #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

            # finally
            #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
            #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
            #     if Base.eof(fWIO)
            #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
            #     end
            # end

            # nowTime = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            # log_text = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
            # Base.GC.gc();  # 内存回收函數 gc();

            # return ["success", response_data_String, output_file, monitor_file];
            return resultArray;  # [result[1], result[2], result[3]];
        else
            println("用於輸出數據的媒介文檔: " * output_file * " 無法被創建.");
            return ["error", output_file, "document [ output file = " * Base.string(output_file) * " ] not create."];
        end
    end
end

# # 使用示例;
# is_monitor = false;  # true; # Boolean，用於判別是執行一次，還是啓動監聽服務，持續監聽目標文檔，false 值表示只執行一次，true 值表示啓動監聽服務器看守進程持續監聽;
# monitor_dir = "C:/Criss/temp";  # 上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__，用於輸入傳值的媒介目錄 "../Intermediary/";
# monitor_file = "C:/Criss/temp/intermediary_write_NodeJS.txt";  # 上一層路徑下的temp路徑 Base.Filesystem.joinpath(monitor_dir, "intermediary_write_NodeJS.txt")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於接收傳值的媒介文檔 "../Intermediary/intermediary_write_NodeJS.txt";
# output_dir = "C:/Criss/temp";  # 上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__，用於輸出傳值的媒介目錄 "../Intermediary/";
# output_file = "C:/Criss/temp/intermediary_write_Julia.txt";  # 上一層路徑下的temp路徑 Base.Filesystem.joinpath(output_dir, "intermediary_write_Julia.txt")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於輸出傳值的媒介文檔 "../Intermediary/intermediary_write_Julia.txt";
# temp_cache_IO_data_dir = "C:/Criss/temp";  # 上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__，一個唯一的用於暫存傳入傳出數據的臨時媒介文件夾 "C:\Users\china\AppData\Local\Temp\temp_cache_IO_data_dir\";
# do_Function = do_data;  # (argument) -> begin argument; end; 匿名函數對象，用於接收執行數據處理功能的函數 "do_data";
# to_executable = "";  # C:/Progra~1/nodejs/node.exe";  # 上一層路徑下的Node.JS解釋器可執行檔路徑C:\nodejs\node.exe：Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "NodeJS", "node,exe")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的解釋器可執行文件 "..\\NodeJS\\node.exe"，Julia 解釋器可執行檔全名 println(Base.Sys.BINDIR)：C:\Julia 1.5.1\bin，;
# to_script = "";  # "C:/Users/china/Documents/Node.js/Criss/jl/test.js";  # 上一層路徑下的 JavaScript 脚本路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "js", "Ruuter.js")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，用於對返回數據執行功能的被調用的脚本文檔 "../js/Ruuter.js";
# time_sleep = Core.Float16(0.02);  # Core.Float64(0.02)，監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒，自定義函數檢查輸入合規性 CheckString(delay, 'positive_integer');
# number_Worker_threads = Core.UInt8(0);  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
# isMonitorThreadsOrProcesses = 0;  # "Multi-Threading"; # "Multi-Processes"; # 選擇監聽動作的函數的并發層級（多協程、多綫程、多進程）;
# # 當 isMonitorThreadsOrProcesses = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
# # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
# # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
# # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
# # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;
# isDoTasksOrThreads = "Tasks";  # "Multi-Threading"; # 選擇具體執行功能的函數的并發層級（多協程、多綫程、多進程）;
# # 當 isDoTasksOrThreads = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
# # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
# # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl

# # a = Array{Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}(Core.nothing, 3);
# a = monitor_file_Run(
#     is_monitor=is_monitor,  # 用於判別是執行一次，還是啓動監聽服務，持續監聽目標文檔，false 值表示只執行一次，true 值表示啓動監聽服務器看守進程持續監聽;
#     monitor_file=monitor_file,  # 用於接收傳值的媒介文檔;
#     monitor_dir=monitor_dir,  # 用於輸入傳值的媒介目錄;
#     do_Function=do_Function,  # 用於接收執行數據處理功能的函數;
#     output_dir=output_dir,  # 用於輸出傳值的媒介目錄;
#     output_file=output_file,  # 用於輸出傳值的媒介文檔;
#     to_executable=to_executable,  # 用於對返回數據執行功能的解釋器二進制可執行檔;
#     to_script=to_script,  # 用於對返回數據執行功能的被調用的脚本文檔;
#     temp_cache_IO_data_dir=temp_cache_IO_data_dir,  # 用於暫存傳入傳出數據的臨時媒介文件夾;
#     number_Worker_threads=number_Worker_threads,  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目;
#     time_sleep=time_sleep,  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
#     read_file_do_Function=read_file_do_Function,  # 從指定的硬盤文檔讀取數據字符串，並調用相應的數據處理函數處理數據，然後將處理得到的結果再寫入指定的硬盤文檔;
#     monitor_file_do_Function=monitor_file_do_Function,  # 自動監聽指定的硬盤文檔，當硬盤指定目錄出現指定監聽的文檔時，就調用讀文檔處理數據函數;
#     isMonitorThreadsOrProcesses=isMonitorThreadsOrProcesses,  # 0 || "0" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
#     isDoTasksOrThreads=isDoTasksOrThreads # "Tasks" || "Multi-Threading"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
# );
# # println(typeof(a))
# println(a[1])
# println(a[2])
# println(a[3])






# # 示例函數，處理從客戶端 GET 或 POST 請求的信息，然後返回處理之後的結果JSON對象字符串數據;
# # "service" functions to actually do the work;
# function do_Request(request_Dict::Base.Dict{Core.String, Core.Any})::Core.String
#     println(request_Dict);

#     request_POST_String::Core.String = "";  # request_Dict["request_body_String"];  # 客戶端發送 post 請求時的請求體數據;
#     request_POST_bytes_Array::Core.Union{Base.IOStream, Base.IOBuffer, Core.Nothing, Core.String, Core.Array{Core.UInt8, 1}, Base.Vector{UInt8}} = Base.IOBuffer();  # Core.Array{Core.UInt8, 1}();  # Core.Array{Core.UInt8, 1}();  # ::Core.Union{Base.Vector{Core.UInt8}, Core.String, Base.IOBuffer};
#     request_POST_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}();
#     request_Url::Core.String = "";  # request_Dict["Target"];  # 客戶端發送請求的 url 字符串 "/index.html?a=1&b=2#idStr";
#     request_Path::Core.String = "";  # request_Dict["request_Path"];  # 客戶端發送請求的路徑 "/index.html";
#     request_Url_Query_String::Core.String = "";  # request_Dict["request_Url_Query_String"];  # 客戶端發送請求 url 中的查詢字符串 "a=1&b=2";
#     request_Url_Query_Dict = Base.Dict{Core.String, Core.Any}();  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);
#     request_Authorization::Core.String = "";  # request_Dict["Authorization"];  # 客戶端發送請求的用戶名密碼驗證字符串;
#     request_Cookie::Core.String = "";  # request_Dict["Cookie"];  # 客戶端發送請求的 Cookie 值字符串;
#     request_Nikename::Core.String = "";  # request_Dict["request_Nikename"];  # 客戶端發送請求的驗證昵稱值字符串;
#     request_Password::Core.String = "";  # request_Dict["request_Password"];  # 客戶端發送請求的驗證密碼值字符串;
#     # request_time::Core.String = "";  # request_Dict["time"];  # 客戶端發送請求的 time 值字符串;
#     # request_Date::Core.String = "";  # request_Dict["Date"];  # 客戶端發送請求的日期值字符串;
#     request_IP::Core.String = "";  # request_Dict["request_IP"];  # 客戶端發送請求的 IP 地址字符串;
#     # request_Method::Core.String = "";  # request_Dict["request_Method"];  # 客戶端發送請求的方法值字符串 "get"、"post";
#     # request_Protocol::Core.String = "";  # request_Dict["request_Protocol"];  # 客戶端發送請求的協議值字符串 "HTTP/1.1:"、"https:";
#     request_User_Agent::Core.String = "";  # request_Dict["User-Agent"];  # 客戶端發送請求的客戶端名字值字符串;
#     request_From::Core.String = "";  # request_Dict["From"];  # 客戶端發送請求的來源值字符串;
#     request_Host::Core.String = "";  # request_Dict["Host"];  # 客戶端發送請求的服務器名字和埠號值字符串 "127.0.0.1:8000"、"localhost:8000";
#     if Base.length(request_Dict) > 0
#         # Base.isa(request_Dict, Base.Dict)

#         if Base.haskey(request_Dict, "request_body_String")
#             request_POST_String = request_Dict["request_body_String"];  # 客戶端發送 post 請求時的請求體數據;
#         end
#         if Base.haskey(request_Dict, "request_body_bytes_Array")
#             request_POST_bytes_Array = request_Dict["request_body_bytes_Array"];  # 客戶端發送 post 請求時的請求體數據;
#         end
#         if Base.haskey(request_Dict, "request_body_Dict")
#             request_POST_Dict = request_Dict["request_body_Dict"];  # 客戶端發送 post 請求時的請求體數據;
#         end
#         if Base.haskey(request_Dict, "request_Url")
#             request_Url = request_Dict["request_Url"];  # 客戶端發送請求的 url 字符串 "/index.html?a=1&b=2#idStr";
#         elseif Base.haskey(request_Dict, "Target")
#             request_Url = request_Dict["Target"];  # 客戶端發送請求的 url 字符串 "/index.html?a=1&b=2#idStr";
#         else
#         end
#         if Base.haskey(request_Dict, "request_Path")
#             request_Path = request_Dict["request_Path"];  # 客戶端發送請求的路徑 "/index.html";
#         end
#         if Base.haskey(request_Dict, "request_Url_Query_String")
#             request_Url_Query_String = request_Dict["request_Url_Query_String"];  # 客戶端發送請求 url 中的查詢字符串 "a=1&b=2";
#         end
#         if Base.haskey(request_Dict, "request_Url_Query_Dict") && Base.isa(request_Dict["request_Url_Query_Dict"], Base.Dict)
#             request_Url_Query_Dict = request_Dict["request_Url_Query_Dict"];  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);
#         end
#         if Base.haskey(request_Dict, "Host")
#             request_Host = request_Dict["Host"];  # 客戶端發送請求的目標服務器主機名和埠號字符串，127.0.0.7:8000;
#         end
#         if Base.haskey(request_Dict, "Authorization")
#             request_Authorization = request_Dict["Authorization"];  # 客戶端發送請求的用戶名密碼驗證字符串;
#         end
#         if Base.haskey(request_Dict, "Cookie")
#             request_Cookie = request_Dict["Cookie"];  # 客戶端發送請求的 Cookie 值字符串;
#         end
#         if Base.haskey(request_Dict, "request_Nikename")
#             request_Nikename = request_Dict["request_Nikename"];  # 客戶端發送請求的驗證昵稱值字符串;
#         end
#         if Base.haskey(request_Dict, "request_Password")
#             request_Password = request_Dict["request_Password"];  # 客戶端發送請求的驗證密碼值字符串;
#         end
#         # if Base.haskey(request_Dict, "time")
#         #     request_time = request_Dict["time"];  # 客戶端發送請求的 time 值字符串;
#         # end
#         # if Base.haskey(request_Dict, "Date")
#         #     request_Date = request_Dict["Date"];  # 客戶端發送請求的日期值字符串;
#         # end
#         if Base.haskey(request_Dict, "request_IP")
#             request_IP = request_Dict["request_IP"];  # 客戶端發送請求的 IP 地址字符串;
#         end
#         # if Base.haskey(request_Dict, "request_Method")
#         #     request_Method = request_Dict["request_Method"];  # 客戶端發送請求的方法值字符串 "get"、"post";
#         # end
#         # if Base.haskey(request_Dict, "request_Protocol")
#         #     request_Protocol = request_Dict["request_Protocol"];  # 客戶端發送請求的協議值字符串 "http:"、"https:";
#         # end
#         if Base.haskey(request_Dict, "User-Agent")
#             request_User_Agent = request_Dict["User-Agent"];  # 客戶端發送請求的客戶端名字值字符串;
#         end
#         if Base.haskey(request_Dict, "From")
#             request_From = request_Dict["From"];  # 客戶端發送請求的來源值字符串;
#         end
#         # if Base.haskey(request_Dict, "Host")
#         #     request_Host = request_Dict["Host"];  # 客戶端發送請求的服務器名字值字符串 "127.0.0.1"、"localhost";
#         # end
#     end

#     if Base.length(request_Dict) === 0 || !Base.haskey(request_Dict, "Host") || request_Host === ""

#         if Base.haskey(request_Dict, "request_IP") && request_IP !== ""
#             if Base.typeof(host) === Sockets.IPv6
#                 request_Host = Base.string("[", Base.string(request_IP), "]:", Base.string(port));  # 客戶端發送請求的目標服務器主機名和埠號字符串，[::1]:8000;
#             elseif Base.typeof(host) === Sockets.IPv4
#                 request_Host = Base.string(Base.string(request_IP), ":", Base.string(port));  # 客戶端發送請求的目標服務器主機名和埠號字符串，127.0.0.1:8000;
#             else
#             end
#         # else
#         #     if Base.typeof(host) === Sockets.IPv6
#         #         if Base.string(host) === "localhost" || Base.string(host) === "::" || Base.string(host) === "0" || Base.string(host) === "::0" || Base.string(host) === "::1"
#         #             request_Host = Base.string("[::1]:", Base.string(port));  # 客戶端發送請求的目標服務器主機名和埠號字符串，[::1]:8000;
#         #         else
#         #             request_Host = Base.string("[", Base.string(host), "]:", Base.string(port));  # 客戶端發送請求的目標服務器主機名和埠號字符串，[::1]:8000;
#         #         end
#         #     elseif Base.typeof(host) === Sockets.IPv4
#         #         if Base.string(host) === "localhost" || Base.string(host) === "0.0.0.0" || Base.string(host) === "127.0.0.1"
#         #             request_Host = Base.string("127.0.0.1:", Base.string(port));  # 客戶端發送請求的目標服務器主機名和埠號字符串，[::1]:8000;
#         #         else
#         #             request_Host = Base.string(Base.string(host), ":", Base.string(port));  # 客戶端發送請求的目標服務器主機名和埠號字符串，127.0.0.1:8000;
#         #         end
#         #     else
#         #     end
#         end
#     end
#     println(request_Host);

#     # 將客戶端請求 url 中的查詢字符串值解析為 Julia 字典類型;
#     # request_Url_Query_Dict = Base.Dict{Core.String, Core.Any}();  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);
#     if Base.isa(request_Url_Query_String, Core.String) && request_Url_Query_String !== ""
#         if Base.occursin('&', request_Url_Query_String)
#             # url_Query_Array = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空1維數組，可以使用 Base.push! 函數在數組末尾追加推入新元素;
#             # url_Query_Array = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
#             # 函數 Base.split(request_Url_Query_String, '&') 表示用等號字符'&'分割字符串為數組;
#             for XXX in Base.split(request_Url_Query_String, '&')
#                 temp = Base.strip(XXX);  # Base.strip(str) 去除字符串首尾兩端的空格;
#                 temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
#                 # temp = Base.string(temp);
#                 if Base.isa(temp, Core.String) && Base.occursin('=', temp)
#                     tempKey = Base.split(temp, '=')[1];
#                     tempKey = Base.strip(tempKey);
#                     tempKey = Base.convert(Core.String, tempKey);
#                     tempKey = Base.string(tempKey);
#                     # tempKey = Core.String(Base64.base64decode(tempKey));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
#                     # # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
#                     # # Base64.base64decode("base64_Str");  # 解碼;
#                     tempValue = Base.split(temp, '=')[2];
#                     tempValue = Base.strip(tempValue);
#                     tempValue = Base.convert(Core.String, tempValue);
#                     tempValue = Base.string(tempValue);
#                     # tempValue = Core.String(Base64.base64decode(tempValue));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
#                     # # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
#                     # # Base64.base64decode("base64_Str");  # 解碼;
#                     request_Url_Query_Dict[Base.string(tempKey)] = Base.string(tempValue);
#                 else
#                     request_Url_Query_Dict[Base.string(temp)] = Base.string("");
#                 end
#             end
#         else
#             if Base.isa(request_Url_Query_String, Core.String) && Base.occursin('=', request_Url_Query_String)
#                 tempKey = Base.split(request_Url_Query_String, '=')[1];
#                 tempKey = Base.strip(tempKey);
#                 tempKey = Base.convert(Core.String, tempKey);
#                 tempKey = Base.string(tempKey);
#                 # tempKey = Core.String(Base64.base64decode(tempKey));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
#                 # # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
#                 # # Base64.base64decode("base64_Str");  # 解碼;
#                 tempValue = Base.split(request_Url_Query_String, '=')[2];
#                 tempValue = Base.strip(tempValue);
#                 tempValue = Base.convert(Core.String, tempValue);
#                 tempValue = Base.string(tempValue);
#                 # tempValue = Core.String(Base64.base64decode(tempValue));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
#                 # # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
#                 # # Base64.base64decode("base64_Str");  # 解碼;
#                 request_Url_Query_Dict[Base.string(tempKey)] = Base.string(tempValue);
#             else
#                 request_Url_Query_Dict[Base.string(request_Url_Query_String)] = Base.string("");
#             end
#         end
#     end
#     println(request_Url_Query_Dict);

#     # 將客戶端 post 請求發送的字符串數據解析為 Julia 字典（Dict）對象;
#     request_data_Dict = Base.Dict{Core.String, Core.Any}();  # 聲明一個空字典，客戶端 post 請求發送的字符串數據解析為 Julia 字典（Dict）對象;
#     # request_data_Dict = Core.nothing;
#     if Base.isa(request_POST_String, Core.String) && request_POST_String !== ""
#         # # 使用自定義函數isStringJSON(request_POST_String)判斷讀取到的請求體數據 request_POST_String 是否為JSON格式的字符串;
#         # if isStringJSON(request_POST_String)
#             # 將 Julia 字典（Dict）對象轉換為 JSON 字符串;
#             # request_data_Dict = JSON.parse(request_POST_String);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象;
#             # request_POST_String = JSON.json(request_data_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
#             request_data_Dict = JSONparse(request_POST_String);  # 使用自定義函數 JSONparse() 將請求 Post 字符串解析為 Julia 字典（Dict）對象類型;
#         # else
#         #     request_data_Dict["Client_say"] = request_POST_String;  # Base.Dict(request_POST_String);  # Base.Dict("aa" => 1, "bb" => 2, "cc" => 3);
#         # end
#     end
#     println(request_data_Dict);

#     response_body_Dict = Base.Dict{Core.String, Core.Any}();  # 函數返回值，聲明一個空字典;
#     response_body_String::Core.String = "";

#     # 需要先加載 Julia 原生的 Dates 模組：using Dates;
#     # 函數 Dates.now() 返回當前日期時間對象 2021-06-28T12:12:50.544，使用 Base.string(Dates.now()) 方法，可以返回當前日期時間字符串 2021-06-28T12:12:50.544。
#     # 函數 Dates.time() 當前日期時間的 Unix 值 1.652232489777e9，UNIX 時間，或稱爲 POSIX 時間，是 UNIX 或類 UNIX 系統使用的時間表示方式：從 UTC 1970 年 1 月 1 日 0 時 0 分 0 秒起至現在的縂秒數，不考慮閏秒。
#     # 函數 Dates.unix2datetime(Dates.time()) 將 Unix 時間轉化爲日期（時間）對象，使用 Base.string(Dates.unix2datetime(Dates.time())) 方法，可以返回當前日期時間字符串 2021-06-28T12:12:50。
#     return_file_creat_time = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
#     # println(Base.string(Dates.now()))

#     response_body_Dict["request_Url"] = Base.string(request_Url);  # Base.Dict("Target" => Base.string(request_Url));
#     # response_body_Dict["request_Path"] = Base.string(request_Path);  # Base.Dict("request_Path" => Base.string(request_Path));
#     # response_body_Dict["request_Url_Query_String"] = Base.string(request_Url_Query_String);  # Base.Dict("request_Url_Query_String" => Base.string(request_Url_Query_String));
#     # response_body_Dict["request_POST"] = Base.string(request_POST_String);  # Base.Dict("request_POST" => Base.string(request_POST_String));
#     response_body_Dict["request_Authorization"] = Base.string(request_Authorization);  # Base.Dict("request_Authorization" => Base.string(request_Authorization));
#     response_body_Dict["request_Cookie"] = Base.string(request_Cookie);  # Base.Dict("request_Cookie" => Base.string(request_Cookie));
#     # response_body_Dict["request_Nikename"] = Base.string(request_Nikename);  # Base.Dict("request_Nikename" => Base.string(request_Nikename));
#     # response_body_Dict["request_Password"] = Base.string(request_Password);  # Base.Dict("request_Password" => Base.string(request_Password));
#     response_body_Dict["time"] = Base.string(return_file_creat_time);  # Base.Dict("request_POST" => Base.string(request_POST_String), "time" => string(return_file_creat_time));
#     # response_body_Dict["Server_Authorization"] = Base.string(key);  # "username:password"，Base.Dict("Server_Authorization" => Base.string(key));
#     response_body_Dict["Server_say"] = Base.string(request_POST_String);  # Base.Dict("Server_say" => Base.string(request_POST_String));
#     response_body_Dict["error"] = Base.string("");  # Base.Dict("Server_say" => Base.string(request_POST_String));
#     println(response_body_Dict);

#     response_body_String = JSONstring(response_body_Dict);  # 使用自定義函數 JSONstring() 將 Julia 的字典對象轉換爲 JSON 字符串;
#     # response_body_String = JSON.json(response_body_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
#     println(response_body_String);

#     response_body_String = JSONstring(request_Dict);  # 使用自定義函數 JSONstring() 將 Julia 的字典對象轉換爲 JSON 字符串;
#     println(response_body_String);

#     return response_body_String;
# end


# TCP_Server() 函數的遺留問題：
# 1、在正常使用 root@localhost:~# ./julia.exe ./test.jl 啓動的脚本，如何在代碼中，啓動 Julia 的多綫程模式（export JULIA_NUM_THREADS=4）？
# 從而避免當 isMonitorThreadsOrProcesses = "Multi-Threading" 或 isConcurrencyHierarchy = "Tasks" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
# 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
# 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
# println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
# println(Base.Threads.threadid()); # 查看當前綫程 ID 號;

# 2、在多進程（using Distributed;Distributed.@everywhere using Distributed;Distributed.addprocs(1);）時，如何將主進程中的函數，作爲參數，複製到子進程中可見可執行？
# main-process function f1
# main-process function f2(f1) -> worker-process function f3(f1) -> worker-process function f1
# 1)、向主进程中函数 f2 传入参数 ~ 函数 f1，执行 f2。
# 2)、主进程中函数 f2 创建子进程，并将参数（函数 f1）传递到子进程中可用，在子进程中声明函数 f3，使用 f3 调用参数（函数 f1）运行。
# 3)、最终形成，在子进程中执行，传入的参数（函数 f1）的效果。
# using Distributed;
# Distributed.@everywhere using Distributed;
# function f1(Str::Core.String)::Core.String
#     Str = Str * " worker process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task()));
#     return Str;
# end
# function f2(a::Core.String, f1Var)
#     println(a);
#     Distributed.addprocs(1);
#     function func_wp2(b::Core.String, wp2f1Var)
#         println(b);
#         function f3(c::Core.String, wp2f3Var)
#             println(c);
#             println(wp2f3Var("f3 -> f1"));
#         end
#         f3("f3 -> f1 run", wp2f1Var);
#     end
#     Distributed.remotecall(
#         func_wp2,
#         2,
#         "f2 remotecall",
#         f1Var
#     );
#     # # Base.Threads.@spawn
#     # # Create and run a Task on any available thread. To wait for the task to finish, call wait on the result of this macro, or call fetch to wait and then obtain its return value.
#     # # Values can be interpolated into @spawn via $, which copies the value directly into the constructed underlying closure. This allows you to insert the value of a variable, isolating the asynchronous code from changes to the variable's value in the current task.
#     # # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
#     # wp = Base.Threads.@spawn func_wp2(
#     #     "f2 remotecall",
#     #     f1Var
#     # );
# end
# f2("mainProc-f2 run", f1);

# https://www.w3cschool.cn/julia/6rkw1jfj.html
# TCP_Server_「Sockets.Sockets.listen」;
function TCP_Server(
    host::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4},  # Sockets.IPv6(0) or Sockets.IPv6("::1") or "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
    port::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String};  # 0 ~ 65535，監聽埠號（端口）;
    do_Function = (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Request";
    key::Core.String = ":",  # "username:password",  # 自定義的訪問網站簡單驗證用戶名和密碼;
    session::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => TCP_Server.key),  # 保存網站的 Session 數據;
    number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.UInt8(0),  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
    time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
    isConcurrencyHierarchy::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
    # worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
    total_worker_called_number::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
)::Core.Array{Core.Any, 1}
    # ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}

    # # print("當前協程 task: ", Base.current_task(), "\n");
    # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
    # print("當前綫程 thread 的 ID: ", Base.Threads.threadid(), "\n");
    # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
    # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
    # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
    # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
    # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
    # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
    # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
    # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
    # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
    # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
    # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
    # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
    # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

    # println(Base.Sys.CPU_THREADS)  # 4 可用 CPU 數;
    # println(Base.Filesystem.ispath(Base.Filesystem.pwd()))  # true 判斷目錄是否存在;
    # println(Base.Filesystem.isfile(Base.Filesystem.pwd()))  # true 判斷是否為文檔;
    # println(Base.Filesystem.isdir(Base.Filesystem.pwd()))  # true 判斷是否為文件夾;
    # println(Base.Sys.BINDIR)  # C:\Program Files\Julia 1.5.1\bin;
    # println(Base.PROGRAM_FILE)  # c:\Users\china\Documents\Node.js\Criss\jl\tempCodeRunnerFile.jl;
    # println(Base.Filesystem.basename(Base.Filesystem.pwd()))  # Criss;
    # # "File_Directory_and_Path";
    # println(Base.Filesystem.homedir())  # C:\Users\china;
    # println(Base.Filesystem.pwd())  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath("."))  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js\Criss;
    # # 获取路径的目录;
    # println(Base.Filesystem.dirname(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js;
    # # "/Users/juliauser/Functions_Scripts_Codes_Pipelines/Julia_Codes";
    # # 路径的末端分割;
    # println(Base.Filesystem.splitdir(Base.Filesystem.pwd()));
    # # ("c:\\Users\\china\\Documents\\Node.js", "Criss");
    # # 路径的合成;
    # println(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "temp", "intermediary_write_NodeJS.txt"));  # c:\Users\china\Documents\Node.js\temp\intermediary_write_NodeJS.txt;
    # # Base.Filesystem.cd()  # 更換工作目錄;
    # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl"))
    # # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl").mode) # 返回值為 Core.UInt64 類型數值，例如 Core.UInt64(33206);


    # 判斷傳入的參數用於指定監聽主機的 IP 地址或域名 host 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(host) 判斷 host 變量是否已經被定義過;
    if !Base.@isdefined(host) || host === "" || host === Core.nothing
        # local host = "127.0.0.1",  # "0.0.0.0" or "localhost";
        # local host = Core.nothing;  # 置空;
        println("用於指定監聽主機的 IP 地址或域名「host ∈ ", Base.typeof(host), "」不能被識別.");
        return ["error", host, "argument [ host = " * Base.string(host) * " ] typeof error, no defined."];  # "用於指定監聽主機的 IP 地址或域名「host = " * Base.string(Base.typeof(host)) * "」不能被識別.";
    elseif !Core.isa(host, Core.String) && !Core.isa(host, Sockets.IPv6) && !Core.isa(host, Sockets.IPv4)
        # 使用 Core.isa(host, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(host) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(host) === Core.String 方法判別 host 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Core.Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於指定監聽主機的 IP 地址或域名「host ∈ ", Base.typeof(host), "」不合法，只接受輸入主機 IP 地址或域名字符串或 Sockets.IPv6 類型或 Sockets.IPv4 類型.");
        return ["error", host, "argument [ host = " * Base.string(host) * " ] typeof error, not String or IPv6 or IPv4."];  # ["error", host, "用於指定監聽主機的 IP 地址或域名「host = " * Base.string(Base.typeof(host)) * "」不合法，只接受輸入主機 IP 地址或域名字符串."];
    end
    # host = Sockets.IPv6(host);  # Sockets.IPv4("0.0.0.0"); Sockets.IPv6("0:0:0:0:0:0:0:0");

    # 判斷傳入的參數用於指定監聽主機埠號（端口） port 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(port) 判斷 port 變量是否已經被定義過;
    if !Base.@isdefined(port) || port === "" || port === Core.nothing
        # local port = Core.UInt8(5000);  # Core.UInt8 類型，用於指定監聽主機埠號（端口），自定義函數檢查輸入合規性 CheckString(port, 'arabic_numerals');
        # port = Core.UInt8(5000);  # Core.UInt8 類型，用於指定監聽主機埠號（端口），自定義函數檢查輸入合規性 CheckString(port, 'arabic_numerals');
        # local port = Core.nothing;  # 置空;
        println("傳入的參數用於指定監聽主機埠號（端口）「port ∈ ", Base.typeof(port), "」不能被識別.");
        return "argument [ port = " * Base.string(port) * " ] typeof error, no defined."  # "用於指定監聽主機埠號（端口）「port = " * Base.string(Base.typeof(port)) * "」不能被識別.";
    elseif !(Base.typeof(port) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(port, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(port) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(port) <: Core.UInt64 方法判別 port 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於指定監聽主機埠號（端口）「port ∈ ", Base.typeof(port), "」不是一個數值類型的變量.");
        return "argument [ port = " * Base.string(port) * " ] typeof error, not Float and not Int."  # "用於指定監聽主機埠號（端口）「port = " * Base.string(Base.typeof(port)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的參數用於記錄服務器訪問賬號密碼的變量 key 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(key) 判斷 key 變量是否已經被定義過;
    if !Base.@isdefined(key) || key === Core.nothing
        # local key = "username:password";
        # local key = Core.nothing;  # 置空;
        println("用於記錄服務器訪問賬號密碼的變量「key ∈ ", Base.typeof(key), "」不能被識別.");
        return ["error", key, "argument [ key = " * Base.string(key) * " ] typeof error, no defined."];  # "用於記錄服務器訪問賬號密碼的變量「key = " * Base.string(Base.typeof(key)) * "」不能被識別.";
    elseif !Core.isa(key, Core.String)
        # 使用 Core.isa(key, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(key) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(key) === Core.String 方法判別 key 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於記錄服務器訪問賬號密碼的變量「key ∈ ", Base.typeof(key), "」不合法，只接受輸入「username:password」形式的字符串.");
        return ["error", key, "argument [ key = " * Base.string(key) * " ] typeof error, not String."];  # ["error", key, "用於記錄服務器訪問賬號密碼的變量「key = " * Base.string(Base.typeof(key)) * "」不合法，只接受輸入「username:password」形式的字符串."];
    end

    # 判斷傳入的參數用於記錄服務器 Session 數據的字典變量 session 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(session) 判斷 session 變量是否已經被定義過;
    if !Base.@isdefined(session) || session === "" || session === Core.nothing
        # session = Base.Dict{Core.String, Core.String}("request_Key->username:password" => key);  # 用於記錄服務器 Session 數據的字典變量;        
        println("用於記錄服務器 Session 數據的字典變量「session ∈ ", Base.typeof(session), "」不能被識別.");
        return ["error", session, "argument [ session ∈ " * Base.string(session) * " ] typeof error, no defined."];  # "用於保存服務器 Session 數據的字典變量「session ∈ " * Base.string(Base.typeof(session)) * "」不能被識別.";
    elseif !(Base.typeof(session) <: Base.Dict)
        # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於記錄服務器 Session 數據的字典變量「session ∈ ", Base.typeof(session), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
        return ["error", session, "argument [ session ∈ " * Base.string(Base.typeof(session)) * " ] typeof error, not Dict."];  # ["error", session, "用於記錄服務器 Session 數據的字典變量「session ∈ " * Base.string(Base.typeof(session)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    end

    # # 判斷傳入的參數用於具體執行處理客戶端 POST 請求數據的函數 do_POST 是否已定義且為函數，使用函數 Base.@isdefined(do_POST) 判斷 do_POST 變量是否已經被定義過;
    # if !Base.@isdefined(do_POST) || do_POST === "" || do_POST === Core.nothing
    #     # local do_POST = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     do_POST = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # local do_POST = Core.nothing;  # 置空;
    #     # println("用於具體執行處理客戶端 POST 請求數據的函數「do_POST ∈ ", Base.typeof(do_POST), "」不能被識別.");
    #     # return "argument [ do_POST = " * Base.string(do_POST) * " ] typeof error, no defined."  # "用於具體執行處理客戶端 POST 請求數據的函數「do_POST = " * Base.string(Base.typeof(do_POST)) * "」不能被識別.";
    # elseif !(Base.typeof(do_POST) <: Core.Function)
    #     # 使用 Core.isa(do_POST, Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_POST) <: Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_POST) <: Function 方法判別 do_POST 變量的類型是否包含於函數Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於具體執行處理客戶端 POST 請求數據的函數「do_POST ∈ ", Base.typeof(do_POST), "」不是一個函數類型的變量.");
    #     return "argument [ do_POST = " * Base.string(do_POST) * " ] typeof error, not Function."  # "用於具體執行處理客戶端 POST 請求數據的函數「do_POST = " * Base.string(Base.typeof(do_POST)) * "」不是一個函數類型的變量.";

    #     # try
    #     #     if length(methods(do_POST)) > 0
    #     #         global do_POST = do_data;
    #     #     else
    #     #         # global do_POST = Core.nothing;  # 置空;
    #     #         global do_POST = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     end
    #     # catch err
    #     #     # println(err);
    #     #     # println(Base.typeof(err));
    #     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
    #     #     if Core.isa(err, Core.UndefVarError)
    #     #         println(err.var, " not defined.");
    #     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
    #     #         # global do_POST = Core.nothing;  # 置空;
    #     #         global do_POST = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     else
    #     #         println(err);
    #     #     end
    #     # finally
    #     #     # global do_POST = Core.nothing;  # 置空;
    #     #     # global do_POST = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # end
    # end

    # 判斷傳入的參數用於具體執行處理客戶端請求數據的函數 do_Function 是否已定義且為函數，使用函數 Base.@isdefined(do_Function) 判斷 do_Function 變量是否已經被定義過;
    if !Base.@isdefined(do_Function) || do_Function === "" || do_Function === Core.nothing
        # local do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # local do_Function = Core.nothing;  # 置空;
        println("用於具體執行處理客戶端請求數據的函數「do_Function ∈ ", Base.typeof(do_Function), "」不能被識別.");
        return "argument [ do_Function = " * Base.string(do_Function) * " ] typeof error, no defined."  # "用於具體執行處理客戶端請求數據的函數「do_Function = " * Base.string(Base.typeof(do_Function)) * "」不能被識別.";
    elseif !(Base.typeof(do_Function) <: Core.Function)
        # 使用 Core.isa(do_Function, Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_Function) <: Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_Function) <: Function 方法判別 do_Function 變量的類型是否包含於函數Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於具體執行處理客戶端請求數據的函數「do_Function ∈ ", Base.typeof(do_Function), "」不是一個函數類型的變量.");
        return "argument [ do_Function ∈ " * Base.string(Base.typeof(do_Function)) * " ] typeof error, not Function."  # "用於具體執行處理客戶端請求數據的函數「do_Function ∈ " * Base.string(Base.typeof(do_Function)) * "」不是一個函數類型的變量.";

        # try
        #     if length(methods(do_Function)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的自定義多綫程并發數目參數 number_Worker_threads 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(number_Worker_threads) 判斷 number_Worker_threads 變量是否已經被定義過;
    if !Base.@isdefined(number_Worker_threads) || number_Worker_threads === "" || number_Worker_threads === Core.nothing
        # local number_Worker_threads = Core.UInt8(0);  # Core.UInt8 類型，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
        # number_Worker_threads = Core.UInt8(0);  # Core.UInt8 類型，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
        # local number_Worker_threads = Core.nothing;  # 置空;
        println("傳入的參數，指定的變量「number_Worker_threads ∈ ", Base.typeof(number_Worker_threads), "」不能被識別.");
        return "argument [ number_Worker_threads = " * Base.string(number_Worker_threads) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「number_Worker_threads = " * Base.string(Base.typeof(number_Worker_threads)) * "」不能被識別.";
    elseif !(Base.typeof(number_Worker_threads) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(number_Worker_threads, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判別 number_Worker_threads 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「number_Worker_threads ∈ ", Base.typeof(number_Worker_threads), "」不是一個數值類型的變量.");
        return "argument [ number_Worker_threads = " * Base.string(number_Worker_threads) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「number_Worker_threads = " * Base.string(Base.typeof(number_Worker_threads)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的自定義系統暫停時長參數 time_sleep 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(time_sleep) 判斷 time_sleep 變量是否已經被定義過;
    if !Base.@isdefined(time_sleep) || time_sleep === "" || time_sleep === Core.nothing
        # local time_sleep = Core.Float64(0.02);  # Core.Float64 類型變量，20 毫秒，系統暫停等待時長;
        # time_sleep = Core.Float64(0);  # Float64 類型變量，0.02 === 20 毫秒，系統暫停等待時長;
        # local time_sleep = Core.nothing;  # 置空;
        println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不能被識別.");
        return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不能被識別.";
    elseif !(Base.typeof(time_sleep) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(time_sleep, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判別 time_sleep 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不是一個數值類型的變量.");
        return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的參數用於指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量 isConcurrencyHierarchy 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(isConcurrencyHierarchy) 判斷 isConcurrencyHierarchy 變量是否已經被定義過;
    if !Base.@isdefined(isConcurrencyHierarchy) || isConcurrencyHierarchy === "" || isConcurrencyHierarchy === Core.nothing
        # local isConcurrencyHierarchy = "Tasks" || "Multi-Threading" || "Multi-Processes";
        # local isConcurrencyHierarchy = Core.nothing;  # 置空;
        println("指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy ∈ ", Base.typeof(isConcurrencyHierarchy), "」不能被識別.");
        return ["error", isConcurrencyHierarchy, "argument [ isConcurrencyHierarchy = " * Base.string(isConcurrencyHierarchy) * " ] typeof error, no defined."];  # "指定監聽并發的層次（多綫程、多進程）的變量「isConcurrencyHierarchy = " * Base.string(Base.typeof(isConcurrencyHierarchy)) * "」不能被識別.";
    elseif !Core.isa(isConcurrencyHierarchy, Core.String) || (isConcurrencyHierarchy !== "Tasks" && isConcurrencyHierarchy !== "Multi-Threading" && isConcurrencyHierarchy !== "Multi-Processes")
        # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy ", Base.typeof(isConcurrencyHierarchy), "」不合法，只接受輸入：\"Tasks\" || \"Multi-Threading\" 兩個值.");
        return ["error", isConcurrencyHierarchy, "argument [ isConcurrencyHierarchy = " * Base.string(isConcurrencyHierarchy) * " ] typeof error, not String."];  # ["error", isConcurrencyHierarchy, "指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy = " * Base.string(Base.typeof(isConcurrencyHierarchy)) * "」不合法，只接受輸入：\"Tasks\" || \"Multi-Threading\" 兩個值."];
    end

    # # 判斷傳入的參數用於保存每個綫程的字典變量 worker_queues_Dict 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(worker_queues_Dict) 判斷 worker_queues_Dict 變量是否已經被定義過;
    # if !Base.@isdefined(worker_queues_Dict) || worker_queues_Dict === "" || worker_queues_Dict === Core.nothing
    #     # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # 保存每個工作子綫程;
    #     worker_queues_Dict = Base.Dict{Core.String, Core.UInt64}();  # 保存每個工作子綫程;
    #     # println("用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ ", Base.typeof(worker_queues_Dict), "」不能被識別.");
    #     # return ["error", worker_queues_Dict, "argument [ worker_queues_Dict ∈ " * Base.string(worker_queues_Dict) * " ] typeof error, no defined."];  # "用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * "」不能被識別.";
    # elseif !(Base.typeof(worker_queues_Dict) <: Base.Dict)
    #     # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ ", Base.typeof(worker_queues_Dict), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
    #     return ["error", worker_queues_Dict, "argument [ worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * " ] typeof error, not Dict."];  # ["error", worker_queues_Dict, "用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    # end

    # 判斷傳入的參數用於記錄每個綫程纍加的被調用運算的總次數的字典變量 total_worker_called_number 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(total_worker_called_number) 判斷 total_worker_called_number 變量是否已經被定義過;
    if !Base.@isdefined(total_worker_called_number) || total_worker_called_number === "" || total_worker_called_number === Core.nothing
        # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
        total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
        # println("用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ ", Base.typeof(total_worker_called_number), "」不能被識別.");
        # return ["error", total_worker_called_number, "argument [ total_worker_called_number ∈ " * Base.string(total_worker_called_number) * " ] typeof error, no defined."];  # "用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * "」不能被識別.";
    elseif !(Base.typeof(total_worker_called_number) <: Base.Dict)
        # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ ", Base.typeof(total_worker_called_number), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
        return ["error", total_worker_called_number, "argument [ total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * " ] typeof error, not Dict."];  # ["error", total_worker_called_number, "用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    end

    # 自定義函數，指定響應狀態碼對應的文本信息;
    function statusMessage(response_statusCode::Core.Int64)::Core.String
        # response_statusCode::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8}

        # response_statusCode = 200;  // 401, "需要身份驗證賬號密碼", 301, "重定向";
        statusMessage_CN::Core.String = "";
        statusMessage_EN::Core.String = "";
        if response_statusCode === 200
            statusMessage_CN = "請求成功";
            statusMessage_EN = "OK.";
        elseif response_statusCode === 301
            statusMessage_CN = "服務器要求重定向";
            statusMessage_EN = "Moved Permanently.";
        elseif response_statusCode === 307
            statusMessage_CN = "服務器要求臨時重定向";
            statusMessage_EN = "Temporary Redirect.";
        elseif response_statusCode === 401
            statusMessage_CN = "服務器要求客戶端身份驗證出具賬號密碼";
            statusMessage_EN = "Unauthorized.";
        elseif response_statusCode === 404
            statusMessage_CN = "請求路徑(URL)錯誤";
            statusMessage_EN = "Page not Found !";
        elseif response_statusCode === 405
            statusMessage_CN = "請求方法錯誤";
            statusMessage_EN = "Method Not Allowed !";
        else
            statusMessage_CN = "";
            statusMessage_EN = "";
        end

        # using Base64;  # 導入 Julia 的原生標準模組「Base64」，用於按照 Base64 方式編解碼字符串;
        # Base64.base64encode(writefunc, args...; context=nothing)
        # Base64.base64encode(args...; context=nothing)
        # Given a write-like function writefunc, which takes an I/O stream as its first argument, base64encode(writefunc, args...) calls writefunc to write args... to a base64-encoded string, and returns the string. base64encode(args...) is equivalent to base64encode(write, args...): it converts its arguments into bytes using the standard write functions and returns the base64-encoded string.
        # The optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to writefunc or write.
        # Base64.base64decode(string)
        # Decode the base64-encoded string and returns a Vector{UInt8} of the decoded bytes.
        # Core.String(s::AbstractString)
        # Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.
        # "5ZC+" === Base64.base64encode("吾"; context=nothing)
        # "吾" === Core.String(Base64.base64decode("5ZC+"))

        status_Message = Base64.base64encode(statusMessage_CN; context=nothing) * "," * statusMessage_EN;  # 需要事先加載原生的 Base64 模組：using Base64 模組;

        # statusMessage_EN_Array = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();  # 聲明一個聯合類型的空1維數組;
        # # statusMessage_EN_Array = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
        # # 函數 Base.split(status_Message, ' ') 表示用等號字符 ' ' 分割字符串為數組;
        # for x in Base.split(status_Message, ' ')
        #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
        #     Base.push!(statusMessage_EN_Array, x);  # 使用 push! 函數在數組末尾追加推入新元素;
        # end
        # if length(statusMessage_EN_Array) > 1

        #     statusMessage_EN_Value = "";
        #     # statusMessage_EN_Value = join(Base.deleteat!(Base.deepcopy(statusMessage_EN_Array), 1), " ");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(statusMessage_EN_Array, 1) 函數刪除第一個元素時候就不會改變原數組 statusMessage_EN_Array，否則為淺拷貝傳址複製，使用 deleteat!(statusMessage_EN_Array, 1) 刪除第一個元素的時候會影響原數組 statusMessage_EN_Array 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
        #     for j = 2:length(statusMessage_EN_Array)
        #         if j === 2
        #             statusMessage_EN_Value = statusMessage_EN_Value * statusMessage_EN_Array[j];  # 使用星號*拼接字符串;
        #         else
        #             statusMessage_EN_Value = statusMessage_EN_Value * " " * statusMessage_EN_Array[j];
        #         end
        #     end
        # end

        return status_Message;
    end

    # 自定義一個在進程退出前一刻調用的函數 f()，使用 Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并注冊為在對象終結的前一刻運行;
    function func_Exit()

        # if isMonitorThreadsOrProcesses === "Multi-Processes" || isMonitorThreadsOrProcesses === "Multi-Threading"

        #     RemoteChannel_Data_Dict = Base.Dict{Core.String, Core.Any}(
        #         # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
        #         "monitor_file" => monitor_file,
        #         "monitor_dir" => monitor_dir,
        #         # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
        #         "output_dir" => output_dir,
        #         "output_file" => output_file,
        #         "temp_cache_IO_data_dir" => temp_cache_IO_data_dir,
        #         "to_executable" => to_executable,
        #         "to_script" => to_script,
        #         "input_queues_array" => input_queues_array,
        #         "output_queues_array" => output_queues_array,
        #         "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
        #         "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
        #         "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
        #         "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
        #         "label" => "exit",
        #         "message" => "exit worker process."
        #     );

        #     if Base.isopen(rc2to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_file() > worker process-2 be exit.";
        #         Base.put!(rc2to, RemoteChannel_Data_Dict);
        #         Base.close(rc2to);
        #     end

        #     if Base.isopen(rc3to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_input_queues() > worker process-3 be exit.";
        #         Base.put!(rc3to, RemoteChannel_Data_Dict);
        #         Base.close(rc3to);
        #     end

        #     if Base.isopen(rc4to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_output_queues() > worker process-4 be exit.";
        #         Base.put!(rc4to, RemoteChannel_Data_Dict);
        #         Base.close(rc4to);
        #     end

        #     RemoteChannel_Data_Dict = Core.nothing;

        #     if Base.isready(rc2from)
        #         # from2rcDict = Base.take!(rc2from);
        #         for from2rcDict in rc2from
        #             # input_queues_array = from2rcDict["input_queues_array"];
        #             # output_queues_array = from2rcDict["output_queues_array"];
        #             if from2rcDict["label"] === "exit"
        #                 println(from2rcDict["message"]);
        #             end
        #         end
        #         # from2rcDict = Core.nothing;
        #     end

        #     if Base.isready(rc3from)
        #         # from3rcDict = Base.take!(rc3from);
        #         for from3rcDict in rc3from
        #             # input_queues_array = from3rcDict["input_queues_array"];
        #             # output_queues_array = from3rcDict["output_queues_array"];
        #             if from3rcDict["label"] === "exit"
        #                 println(from3rcDict["message"]);
        #             end
        #         end
        #         # from3rcDict = Core.nothing;
        #     end

        #     if Base.isready(rc4from)
        #         # from4rcDict = Base.take!(rc4from);
        #         for from4rcDict in rc4from
        #             # input_queues_array = from4rcDict["input_queues_array"];
        #             # output_queues_array = from4rcDict["output_queues_array"];
        #             if from4rcDict["label"] === "exit"
        #                 println(from4rcDict["message"]);
        #             end
        #         end
        #         # from4rcDict = Core.nothing;
        #     end
        # end
    end
    Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

    # 開啓并發，在子進程（Worker）中，處理輸入任務隊列;
    if Core.Int8(number_Worker_threads) > Core.Int8(0)

        # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.Task}();
        # # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
        # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;

        if isConcurrencyHierarchy === "Tasks" || isConcurrencyHierarchy === "Multi-Threading"

            # 創建通道(Channel);
            main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
            sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
            control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));  # 用於控制并發數目的通道，寫入一個元素相當於記錄一個啓動的子協程(task)，取出一個元素相當於一個子協程(task)執行完畢，如通道已經滿，則阻塞等待;
            # Base.put!(main_to_sub_channel, channel_message_Dict);  # 向通道(Channel)中寫入元素;
            # # Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
            # Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
            # Base.close(main_to_sub_channel);  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗;
        elseif isConcurrencyHierarchy === "Multi-Processes"

            # Distributed.addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers;
            # Distributed.addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers;
            # Distributed.addprocs(Base.Sys.CPU_THREADS; kwargs...) -> List of process identifiers;
            # Distributed.addprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers;
            Distributed.addprocs(number_Worker_threads);  # Base.Sys.CPU_THREADS; # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

            main_to_sub_channel = Distributed.RemoteChannel(()->Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads)), Distributed.myid());  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
            sub_to_main_channel = Distributed.RemoteChannel(()->Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads)), Distributed.myid());
            control_number_Queues_channel = Distributed.RemoteChannel(()->Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads)), Distributed.myid());  # 用於控制并發數目的通道，寫入一個元素相當於記錄一個啓動的子協程(task)，取出一個元素相當於一個子協程(task)執行完畢，如通道已經滿，則阻塞等待;
            # Base.put!(main_to_sub_channel, channel_message_Dict);  # 向通道(Channel)中寫入元素;
            # # Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
            # Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
            # Base.close(main_to_sub_channel);  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗;
            
            Distributed.@everywhere do_Function, main_to_sub_channel, sub_to_main_channel, control_number_Queues_channel;
            # Distributed.@everywhere do_Function = Base.deepcopy(do_Function);
            # Distributed.@everywhere read_file_do_Function = Base.deepcopy(read_file_do_Function);
            # Distributed.@everywhere include(Base.PROGRAM_FILE);  # Distributed.@everywhere include("./script.jl") 將當前正在執行的 Julia 脚本文檔發送到所有子進程可見並在所有子進程中載入，Base.PROGRAM_FILE 為當前正在執行的 Julia 脚本文檔絕對路徑;
        end
    end

    # 當選擇使用多協程（Task）并發運算時，在子協程（Task）中執行的函數;
    function funcTask(
        # worker_data_Dict::Base.Dict{Core.String, Core.Any},
        do_Function,
        main_to_sub_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
        sub_to_main_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
        control_number_Queues_channel::Base.Channel{Core.UInt64}
    ) ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}

        # # print("當前協程 task: ", Base.current_task(), "\n");
        # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
        # print("當前綫程 thread 的 PID: ", Base.Threads.threadid(), "\n");
        # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
        # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
        # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
        # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
        # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
        # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
        # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
        # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
        # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
        # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
        # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
        # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
        # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

        worker_Data_Dict = Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
        # worker_Data_Dict = Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
        # worker_data_Dict = Base.Dict{Core.String, Core.Any}(
        #     # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
        #     "arguments" => request_Dict = Base.Dict{Core.String, Core.Any}(
        #         "request_Data" => request_body,
        #         "request_Nikename" => request_Nikename,
        #         "request_Password" => request_Password,
        #         "time" => Base.string(now_date),
        #         "request_IP" => request_head["request_IP"],
        #         "request_Method" => request_head["request_Method"],
        #         "request_Url" => request_head["request_Url"],
        #         "request_Path" => request_head["request_Path"],
        #         "request_Protocol" => request_head["request_Protocol"].
        #         "Authorization" => request_head["Authorization"],
        #         "Cookie" => request_head["Cookie"],
        #         "From" => request_head["From"],
        #         "User-Agent" => request_head["User-Agent"],
        #         "Host" => request_head["Host"],
        #         "Accept" => request_head["Accept"],
        #         "Accept-Language" => request_head["Accept-Language"],
        #         "Accept-Charset" => request_head["Accept-Charset"],
        #         "Date" => request_head["Date"]
        #     );
        # );

        if Base.isa(worker_Data_Dict, Base.Dict)

            if Base.haskey(worker_Data_Dict, "label") && worker_Data_Dict["label"] === "Run"

                request_Dict = Base.Dict{Core.String, Core.Any}();
        
                if Base.haskey(worker_Data_Dict, "arguments") && Base.isa(worker_Data_Dict["arguments"], Base.Dict)

                    # println(worker_Data_Dict["arguments"]);
                    request_Dict = worker_Data_Dict["arguments"];

                    result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = ["",""];
                    try
                        # Base.push!(result, "success");
                        result[1] = "success";
                        # Base.push!(result, do_Function(request_Dict));
                        result[2] = do_Function(request_Dict);
                        # result[2] = worker_Data_Dict["do_Function"](worker_Data_Dict["arguments"]);
                        # Base.write(Base.stdout, result[2]);
                        # println(result[2]);
                    catch err
                        # Base.write(stderr, err);
                        # Base.write(Base.stdout, err, "\n");
                        # println("自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                        println(err);
                        # println(err.msg);
                        # println(Base.typeof(err));
                        result[1] = "error";
                        result[2] = Base.string(err);
                    end
                    # Base.write(Base.stdout, result[2]);

                    # response_data_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                    # println(response_data_String);
        
                    nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text::Core.String = "";
                    # if Base.isa(request_Dict, Base.Dict)
                    #     if Base.haskey(request_Dict, "request_IP") && Base.haskey(request_Dict, "request_Nikename") && Base.haskey(request_Dict, "request_Password") && Base.haskey(request_Dict, "request_Path") && Base.haskey(request_Dict, "User-Agent") && Base.haskey(request_Dict, "From")
                    #         log_text = "error < " * Base.string(result[2]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(request_Dict["request_IP"]) * " > < " * Base.string(request_Dict["request_Nikename"], ":", request_Dict["request_Password"]) * " > < " * Base.string(request_Dict["request_Path"]) * " > < " * Base.string(request_Dict["User-Agent"]) * " > < " * Base.string(request_Dict["From"]) * " >.";
                    #     elseif Base.haskey(request_Dict, "request_IP") && Base.haskey(request_Dict, "request_Nikename") && Base.haskey(request_Dict, "request_Password") && Base.haskey(request_Dict, "request_Path")
                    #         log_text = "error < " * Base.string(result[2]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(request_Dict["request_IP"]) * " > < " * Base.string(request_Dict["request_Nikename"], ":", request_Dict["request_Password"]) * " > < " * Base.string(request_Dict["request_Path"]) * " >.";
                    #     elseif Base.haskey(request_Dict, "request_IP") && Base.haskey(request_Dict, "request_Path")
                    #         log_text = "error < " * Base.string(result[2]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(request_Dict["request_IP"]) * " > < " * Base.string(request_Dict["request_Path"]) * " >.";
                    #     elseif Base.haskey(request_Dict, "request_IP")
                    #         log_text = "error < " * Base.string(result[2]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(request_Dict["request_IP"]) * " >.";
                    #     end
                    # else
                    #     log_text = "error < " * Base.string(result[2]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " .";
                    # end
                    # print(log_text * "\n");
                    # log_file = "";  # 日志文檔;
                    # # 同步寫入用於記錄過程的日志文檔;
                    # try
                    #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                    #     # # write(filename::AbstractString, x)
                    #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                    #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                    #     # println(numBytes);
                    #     # println(Base.stat(log_file).size);
                    #     # println(Base.stat(log_file).mtime);
                    #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    #     # println(Base.stat(log_file).ctime);
                    #     # # Base.displaysize([io::IO]) -> (lines, columns)
                    #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                    #     # # Base.countlines — Function
                    #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                    #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                    #     # println(Base.countlines(log_file, eol='\\n'));
        
                    #     fWIO = Base.open(log_file, "a+");
                    #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                    #     # seekstart(fWIO);  # 指針返回文檔的起始位置;
        
                    #     # Keyword	Description				Default
                    #     # read		open for reading		!write
                    #     # write		open for writing		truncate | append
                    #     # create	create if non-existent	!read & write | truncate | append
                    #     # truncate	truncate to zero size	!read & write
                    #     # append	seek to end				false
        
                    #     # Mode	Description						Keywords
                    #     # r		read							none
                    #     # w		write, create, truncate			write = true
                    #     # a		write, create, append			append = true
                    #     # r+	read, write						read = true, write = true
                    #     # w+	read, write, create, truncate	truncate = true, read = true
                    #     # a+	read, write, create, append		append = true, read = true
        
                    #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                    #     if Base.iswritable(fWIO)
                    #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                    #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                    #         println(numBytes);
                    #         println(Base.stat(log_file).size);
                    #         println(Base.stat(log_file).mtime);
                    #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    #         println(Base.stat(log_file).ctime);
                    #         # Base.displaysize([io::IO]) -> (lines, columns)
                    #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                    #         # Base.countlines — Function
                    #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                    #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                    #         println(Base.countlines(log_file, eol='\\n'));
                    #     end
        
                    #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                    #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                    #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                    #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                    #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                    #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                    #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                    #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                    #     # Base.ismarked(io);  # Return true if stream s is marked;
                    #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                    #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                    #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                    #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                    #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                    #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                    #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                    #     # Base.close(io);  # 關閉緩衝區;
                    #     # println(a)
                    #     # Base.redirect_stdout — Function
                    #     # redirect_stdout([stream]) -> (rd, wr)
                    #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                    #     # If called with the optional stream argument, then returns stream itself.
                    #     # Base.redirect_stdout — Method
                    #     # redirect_stdout(f::Function, stream)
                    #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                    #     # Base.redirect_stderr — Function
                    #     # redirect_stderr([stream]) -> (rd, wr)
                    #     # Like redirect_stdout, but for stderr.
                    #     # Base.redirect_stderr — Method
                    #     # redirect_stderr(f::Function, stream)
                    #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                    #     # Base.redirect_stdin — Function
                    #     # redirect_stdin([stream]) -> (rd, wr)
                    #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                    #     # Base.redirect_stdin — Method
                    #     # redirect_stdin(f::Function, stream)
                    #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.
        
                    # catch err
                    #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                    #     println(err);
                    #     # println(Base.typeof(err));
        
                    #     # Julia提供了許多類型的錯誤：
                    #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                    #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                    #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                    #     # DivideError：這是數字除以0時的結果。
                    #     # DomainError：有效域之外的參數。
                    #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                    #     # InexactError：嘗試進行精確類型轉換失敗。
                    #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                    #     # LoadError：載入檔時發生錯誤。
                    #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                    #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                    #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                    #     # OverflowError：當操作結果太大時會發生這種情況。
                    #     # ParseError：解析給定運算式時出現問題。
                    #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                    #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                    #     # UndefRefError：未知引用。
                    #     # UndefVarError：對不存在的變數進行未知引用。
                    #     # InitError：調用模組的init方法時出現此錯誤。
                    #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                    #     # NullException：嘗試訪問Null值
                    #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤
        
                    #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];
        
                    # finally
                    #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                    #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                    #     if Base.eof(fWIO)
                    #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                    #     end
                    # end

                    request_Arguments = Base.Dict{Core.String, Core.String}();
                    if Base.length(request_Dict) > 0
                        # Base.isa(request_Dict, Base.Dict)
        
                        # if Base.haskey(request_Dict, "request_Data")
                        #     request_Arguments["request_Data"] = request_Dict["request_Data"];
                        # end
                        if Base.haskey(request_Dict, "request_Nikename")
                            request_Arguments["request_Nikename"] = request_Dict["request_Nikename"];
                        end
                        if Base.haskey(request_Dict, "request_Password")
                            request_Arguments["request_Password"] = request_Dict["request_Password"];
                        end
                        if Base.haskey(request_Dict, "time")
                            request_Arguments["time"] = request_Dict["time"];
                        end
                        if Base.haskey(request_Dict, "request_IP")
                            request_Arguments["request_IP"] = request_Dict["request_IP"];
                        end
                        if Base.haskey(request_Dict, "request_Method")
                            request_Arguments["request_Method"] = request_Dict["request_Method"];
                        end
                        if Base.haskey(request_Dict, "request_Path")
                            request_Arguments["request_Path"] = request_Dict["request_Path"];
                        end
                        if Base.haskey(request_Dict, "request_Protocol")
                            request_Arguments["request_Protocol"] = request_Dict["request_Protocol"];
                        end
                        if Base.haskey(request_Dict, "Authorization")
                            request_Arguments["Authorization"] = request_Dict["Authorization"];
                        end
                        if Base.haskey(request_Dict, "Cookie")
                            request_Arguments["Cookie"] = request_Dict["Cookie"];
                        end
                        if Base.haskey(request_Dict, "From")
                            request_Arguments["From"] = request_Dict["From"];
                        end
                        if Base.haskey(request_Dict, "User-Agent")
                            request_Arguments["User-Agent"] = request_Dict["User-Agent"];
                        end
                        if Base.haskey(request_Dict, "Host")
                            request_Arguments["Host"] = request_Dict["Host"];
                        end
                        if Base.haskey(request_Dict, "Accept")
                            request_Arguments["Accept"] = request_Dict["Accept"];
                        end
                        if Base.haskey(request_Dict, "Accept-Language")
                            request_Arguments["Accept-Language"] = request_Dict["Accept-Language"];
                        end
                        if Base.haskey(request_Dict, "Accept-Charset")
                            request_Arguments["Accept-Charset"] = request_Dict["Accept-Charset"];
                        end
                        if Base.haskey(request_Dict, "Date")
                            request_Arguments["Date"] = request_Dict["Date"];
                        end
                    end

                    result_Data_Dict = Base.Dict{Core.String, Core.Any}(
                        "request_Arguments" => request_Arguments,
                        # "do_Function" => do_Function,  # worker_Data_Dict["do_Function"]， # do_data ;
                        "result_data" => Base.string(result[2]),
                        "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                        "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                        "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                        "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        "label" => result[1],
                        "message" => "Function [ do_Function ] return " * result[1] * "."
                    );

                    Base.put!(sub_to_main_channel, result_Data_Dict);  # 向通道(Channel)中寫入元素;
                    num = Base.take!(control_number_Queues_channel);  # 取出用於控制并發數目的通道中的元素，使主進程中可以繼續創建子進程。使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;

                    # result_Data_Dict = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                    # Base.GC.gc();  # 内存回收函數 gc();

                    return [result[1], Base.string(result[2]), result_Data_Dict["message"]];
                else
                    return ["error", "main_to_sub_channel", "[ worker_data_Dict::Base.Dict{Core.String, Core.Any}[\"arguments\"] === request_Dict::Base.Dict{Core.String, Core.String} ] can't found."];
                end
            end

            if Base.haskey(worker_Data_Dict, "label") && worker_Data_Dict["label"] === "Exit"
                Base.close(sub_to_main_channel);
                Base.exit(0);
            end
        else
            return ["error", "main_to_sub_channel", "Base.typeof(Base.take!(main_to_sub_channel)) !== Base.Dict, not recognition."];
        end
    end

    # 注意，需要事先加載 Julia 原生的標準包套接字模組「Sockets」：using Sockets;
    # 異步監聽服務器端，注意，必須要異步監聽，否則將會阻塞後續代碼執行;
    # 使用 Julia 原生的標準包 Sockets 中的 listen(name_pipe) 函數建立服務器端的監聽，返回值為 PipeServer 類型，使用 accpet(PipeServer) 函數調用後，會調用 Base.wait() 函數，等待一個客戶端的鏈接，如果不采用異步形式，則此步驟代碼會阻塞後續的代碼執行，accpet(PipeServer) 函數的返回值為 Base.PipeEndpoint 類型，此類型為 Base 包中的不導出的類型。
    server = Core.nothing;
    # server::Core.Union{TCPServer, TCPSocket} = Core.nothing;
    sock = Core.nothing;
    # sock::Sockets.PipeServer = Core.nothing;
    # Base.@async begin
    begin

        # Sockets.listen([addr, ]port::Integer; backlog::Integer=BACKLOG_DEFAULT) -> TCPServer;
        # Listen on port on the address specified by addr. By default this listens on localhost only. To listen on all interfaces pass IPv4(0) or IPv6(0) as appropriate. backlog determines how many connections can be pending (not having called accept) before the server will begin to reject them. The default value of backlog is 511.
        # Sockets.listen(path::AbstractString) -> PipeServer;
        # Create and listen on a named pipe / UNIX domain socket.

        # name_pipe::Core.String = "\\\\.\\pipe\\mypipe-1";  # 定義一個命名管道，使用一個字符串即可命名一個管道;
        # server = Sockets.listen(name_pipe);
        server = Sockets.listen(host, port; backlog=511);  # 需要事先加載原生的 Sockets 模組：using Sockets 模組;
        # server = Sockets.listen(Sockets.IPv4("0.0.0.0"), 5000; backlog=511);
        # server = Sockets.listen(Sockets.IPv6("0:0:0:0:0:0:0:0"), 5000; backlog=511);

        while true

            response_statusCode::Core.Int64 = 0;
            response_status_Message::Core.String = "";

            # 獲取請求數據，獲取客戶端發送的請求頭和請求數據;
            request_head = Base.Dict{Core.String, Core.Any}();
            request_body::Core.String = "";  # Core.Array{Core.Any, 1}();
            request_data_Array = Core.Array{Core.Any, 1}();

            try

                # Sockets.accept(server[, client]) -> PipeEndpoint;
                # Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.
                # 等待客戶端的鏈接;
                sock = Sockets.accept(server);  # 函數 Sockets.accept(server[, client]) 會阻塞等待鏈接;
                # while Base.isopen(sock) end
                if Base.isreadable(sock)

                    # println(countlines(sock; eol="\r\n"));  # countlines(sock; eol="\r\n") 返回管道中數據的行數;

                    request_head["request_IP"] = Base.string(Sockets.getpeername(sock)[1]);  # 需要事先加載原生的 Sockets 模組：using Sockets 模組;
                    # println(request_head["request_IP"]);

                    # 獲取客戶端發送的請求頭和請求數據;
                    # for line in eachline(sock; keep=false)
                    #     # Base.write(Base.stdout, line * "\n");
                    #     # print(line, "\n");
                    #     Base.push!(request_data_Array, line);  # 使用 push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
                    # end

                    # request_data_Array = Base.readlines(sock; keep=false);

                    # request_data_String = Base.read(sock, Core.String);
                    # for x in split(request_data_String, "\r\n")
                    #     x = Base.convert(Core.String, x);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                    #     x = Base.strip(x);  # 使用 Base.strip(str) 去除字符串首尾兩端的空格;
                    #     push!(request_data_Array, x);  # 使用 push! 函數在數組末尾追加推入新元素;
                    # end

                    # while Base.isreadable(sock)
                    #     request_data_line_String = Base.readline(sock, keep=false);
                    #     # request_data_line_String = Base.strip(request_data_line_String);  # 使用 Base.strip(str) 去除字符串首尾兩端的空格;
                    #     push!(request_data_Array, request_data_line_String);  # 使用 push! 函數在數組末尾追加推入新元素;
                    # end

                    # 獲取客戶端發送的請求頭和請求數據，注意前面的四個方法讀完數據後，會自動將鏈接關閉，只有下面這個方法讀完之後不會關閉鏈接;
                    begin
                        request_data_String::Core.String = "";
                        request_data_bytes_Array = Core.Array{Core.Any, 1}();
                        # Base.readavailable(stream)
                        # Read available buffered data from a stream. Actual I/O is performed only if no data has already been buffered. The result is a Vector{UInt8}.
                        # Warning: The amount of data returned is implementation-dependent; for example it can depend on the internal choice of buffer size. Other functions such as read should generally be used instead.
                        request_data_bytes_Array = Base.readavailable(sock);  # 使用 Base.readavailable() 函數讀取鏈接中的數據，但不關閉鏈接，返回值為二進制 byte 字節形式的編碼構成的數組;

                        if Base.length(request_data_bytes_Array) > 0
                            for i = 1:Base.length(request_data_bytes_Array)
                                if Base.isvalid(Char, request_data_bytes_Array[i])
                                    # 使用 Base.isvalid() 函數判斷 byte 碼字節形式是否能夠轉換成爲對應的某個字符;
                                    request_data_String = request_data_String * Core.Char(request_data_bytes_Array[i]);  # 使用 Core.Char() 函數將 byte 碼字節形式轉換成爲對應的某個字符;
                                else
                                    continue;
                                end
                            end
                        end
                        # println(request_data_String);
    
                        request_data_SubString_Array = Core.Array{Core.Any, 1}();
                        if Base.length(request_data_String) > 0
                            if Base.occursin("\r\n", request_data_String)
                                request_data_SubString_Array = Base.split(request_data_String, "\r\n", keepempty=true);  # 將字符串使用特定標志分割爲數組;
                            else
                                request_data_SubString_Array = [request_data_String];
                            end
                        end
    
                        if Base.length(request_data_SubString_Array) > 0
                            for j = 1:Base.length(request_data_SubString_Array)
                                temp = Base.strip(request_data_SubString_Array[j]);  # 去掉字符串首尾兩端的空格;
                                temp = Base.convert(Core.String, temp);  # 將 substring 類型的變量轉換爲 Core.String 字符串類型;
                                # temp = Base.string(temp);
                                push!(request_data_Array, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量，使用 Base.strip(str) 去除字符串首尾兩端的空格，使用 push! 函數在數組末尾追加推入新元素;
                            end
                        end
                        # println(request_data_Array);
                    end
                end

            catch err

                # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                if Core.isa(err, Core.InterruptException)

                    print("\n");
                    # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                    # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                    println("[ Ctrl ] + [ c ] received, will be stop the TCP server.");

                    # # 打印進程被調用數目;
                    # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                    #     if isConcurrencyHierarchy === "Multi-Processes"

                    #         # Base.haskey(collection, key) -> Bool
                    #         # workNum = "worker";
                    #         for k in Base.keys(total_worker_called_number)
                    #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                    #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                    #         end
                    #         # println(workNum);

                    #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                    #         # Base.haskey(collection, key) -> Bool
                    #         # workNum = "worker";
                    #         for k in Base.keys(total_worker_called_number)
                    #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                    #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                    #         end
                    #         # println(workNum);

                    #     end

                    #     total_worker_called_number = Core.nothing;
                    # end

                    # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                    # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                    #     # Base.haskey(collection, key) -> Bool
                    #     # for k in Base.keys(worker_queues_Dict)
                    #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                    #     # end

                    #     worker_queues_Dict = Core.nothing;
                    # end

                    println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                    # Base.exit(0);
                    return ["", server, total_worker_called_number];

                else
                    
                    # Base.write(stderr, err);
                    # Base.write(Base.stdout, err, "\n");
                    println(err);

                    response_statusCode = Core.Int64(500);
                    response_status_Message = statusMessage(response_statusCode);
                    # response_data_String = "{\"Server_say\":\"" * "Server read request data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                    # cookie_string = "";  # * "; expires=" * Base.string(after_1_Days) * "; path=/;";  # 拼接 cookie 字符串值;

                    # Base.close(sock);  # 中斷當前的這個鏈接;
                    # # Base.sleep(time_sleep);
                    # continue;
                    # # break;
                end
            end
            # println(request_data_Array);

            # 解析客戶端發送的請求頭和請求數據，將之分類保存為結構體類型數據，便於後續提取特定請求頭參數處理數據;
            if Base.length(request_data_Array) > 0

                # request_head = Base.Dict{Core.String, Core.String}();
                spaceIndex = Core.Int64(Base.length(request_data_Array));
                # request_body::Core.String = "";  # Core.Array{Core.Any, 1}();

                for i = 1:Base.length(request_data_Array)
                    # Base.write(Base.stdout, request_data_Array[i] * "\n");
                    # print(request_data_Array[i], "\n");

                    if request_data_Array[i] === "\r\n\r\n" || request_data_Array[i] === ""
                        # Base.Unicode.isspace(request_data_Array[i])
                        spaceIndex = Core.Int64(i);
                        head_key = "Line_" * Base.string(i);
                        request_head[head_key] = request_data_Array[i];
                        continue;
                        # break;
                    end

                    if Core.Int64(i) === Core.Int64(1)
                        head_key = "Line_" * Base.string(i);
                        request_head[head_key] = request_data_Array[i];
                        if Base.occursin(" ", request_data_Array[i])
                            # Line_1_Array = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                            Line_1_SubString = Base.split(request_data_Array[i], ' ');
                            if Base.length(Line_1_SubString) === 3
                                request_head["request_Method"] = Base.string(Base.strip(Base.convert(Core.String, Line_1_SubString[1])));  # "get", "post";
                                request_head["request_Url"] = Base.string(Base.strip(Base.convert(Core.String, Line_1_SubString[2])));  # "/index.html?a=1&b=2#idStr";
                                request_head["request_Protocol"] = Base.string(Base.strip(Base.convert(Core.String, Line_1_SubString[3])));  # "http:", "https:";
                            end
                        end
                    end

                    if Core.Int64(i) > Core.Int64(1) && Core.Int64(i) < Core.Int64(spaceIndex)

                        # 是否爲空白字符，函數 Base.Unicode.isspace(c:: AbstractChar)，包括 ASCII 字符的 '\t', '\n', '\v', '\f', '\r', ' ', 及 Latin-1 字符 U+0085, 和 Unicode 類別為 Zs 的字符;
                        # println("sock line" * Base.string(i) * ": " * Base.string(request_data_Array[i]));  # 通過 Base.ARGS 數組獲取從控制臺傳入的參數;
                        # 使用 Core.isa(request_data_Array[i], Core.String) 函數判断「元素(变量实例)」是否属于「集合(变量类型集)」之间的关系，使用 Base.typeof(request_data_Array[i]) <: Core.String 方法判断「集合」是否包含于「集合」之间的关系，或 Base.typeof(request_data_Array[i]) === Core.String 方法判斷傳入的參數是否為 String 字符串類型;
                        if Core.isa(request_data_Array[i], Core.String) && !(request_data_Array[i] === "\r\n\r\n" || request_data_Array[i] === "")
                            # Base.Unicode.isspace(request_data_Array[i])

                            if Base.occursin(":", request_data_Array[i])

                                ARGSArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                                # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                                # 函數 Base.split(request_data_Array[i], ':') 表示用等號字符'='分割字符串為數組;
                                for item in Base.split(request_data_Array[i], ':')
                                    item = Base.convert(Core.String, item);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                                    item = Base.strip(item);  # Base.strip(str) 去除字符串首尾兩端的空格;
                                    item = Base.string(item);  # Base.string(str) 將變量强制轉換爲字符 Julia 的串類型;
                                    Base.push!(ARGSArray, item);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                                end

                                if Base.length(ARGSArray) > 1
            
                                    ARGSValue = "";
                                    # ARGSValue = Base.join(Base.deleteat!(Base.deepcopy(ARGSArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                                    for j = 2:Base.length(ARGSArray)
                                        if j === 2
                                            ARGSValue = ARGSValue * ARGSArray[j];  # 使用星號*拼接字符串;
                                        else
                                            ARGSValue = ARGSValue * ":" * ARGSArray[j];
                                        end
                                    end

                                    # try
                                    #     eval(:(
                                    #         begin
                                    #             Sys.eval("global " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                                    #             # Sys.eval("local " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                                    #             # println($ARGSIArray[1]);
                                    #         end
                                    #     ));
                                    # catch err
                                    #     println(err);
                                    # end

                                    if ARGSArray[1] !== ""
                                        # if ARGSValue !== ""
                                            request_head[ARGSArray[1]] = ARGSValue;
                                            # print(ARGSArray[1], ARGSValue, "\n");
                                        # end
                                    else
                                        head_key = "Line_" * Base.string(i);
                                        request_head[head_key] = ARGSValue;
                                    end
                                end
                            else
                                head_key = "Line_" * Base.string(i);
                                request_head[head_key] = request_data_Array[i];
                            end
                        end
                    end

                    if Core.Int64(i) > Core.Int64(spaceIndex)
                        if Core.Int64(i) === Core.Int64(spaceIndex + 1)
                            request_body = request_body * request_data_Array[i];  # 使用星號*拼接字符串;
                        else
                            request_body = request_body * "\r\n" * request_data_Array[i];
                        end
                    end
                end
            end
            # println(request_head);
            # println(request_body);

            # 解析獲取客戶端請求 url 中的查詢字符串值;
            request_Path::Core.String = "";
            request_Url_Query_Dict = Base.Dict{Core.String, Core.Any}();  # 客戶端請求 url 中的查詢字符串值解析字典;
            request_Url_Query_String::Core.String = "";  # 客戶端請求 url 中的查詢字符串值;
            if Base.length(request_head) > 0
                # Base.isa(request_head, Base.Dict)

                # 解析獲取客戶端請求 url 中的查询字符串;
                # request_Url_Query::Core.String = "";
                if Base.haskey(request_head, "request_Url")
                    # println("request URL: ", request_head["request_Url"]);  # "/index.html?a=1&b=2#idStr";
                    # println(Base.typeof(request_head["request_Url"]));

                    if Base.isa(request_head["request_Url"], Core.String) && Base.occursin('?', request_head["request_Url"])

                        # request_Path = Base.string(Base.strip(Base.split(request_head["request_Url"], '?')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.string() 表示强制轉換為字符串(String)型變量;
                        request_Path = Base.convert(Core.String, Base.strip(Base.split(request_head["request_Url"], '?')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.convert() 將子字符串(SubString)型轉換為字符串(String)型變量;

                        # request_Url_Query_String = Base.string(Base.strip(Base.split(request_head["request_Url"], '?')[2]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.string() 表示强制轉換為字符串(String)型變量;
                        request_Url_Query_String = Base.convert(Core.String, Base.strip(Base.split(request_head["request_Url"], '?')[2]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.convert() 將子字符串(SubString)型轉換為字符串(String)型變量;
                        if Base.isa(request_Url_Query_String, Core.String) && Base.occursin('#', request_Url_Query_String)
                            request_Url_Query_String = Base.convert(Core.String, Base.strip(Base.split(request_Url_Query_String, '#')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.convert() 將子字符串(SubString)型轉換為字符串(String)型變量;
                            # request_Url_Query_String = Base.string(Base.strip(Base.split(request_Url_Query_String, '#')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.convert() 將子字符串(SubString)型轉換為字符串(String)型變量;
                        end

                        if Base.isa(request_Url_Query_String, Core.String) && Base.occursin('&', request_Url_Query_String)

                            # url_Query_Array = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空1維數組，可以使用 Base.push! 函數在數組末尾追加推入新元素;
                            # url_Query_Array = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                            # 函數 Base.split(request_Url_Query_String, '&') 表示用等號字符'&'分割字符串為數組;
                            for x in Base.split(request_Url_Query_String, '&')
                                temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                                temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                                # temp = Base.string(temp);

                                if Base.isa(temp, Core.String) && Base.occursin('=', temp)

                                    tempKey = Base.split(temp, '=')[1];
                                    tempKey = Base.strip(tempKey);
                                    tempKey = Base.convert(Core.String, tempKey);
                                    # tempKey = Base.string(tempKey);
                                    tempKey = Core.String(Base64.base64decode(tempKey));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                                    # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                                    # Base64.base64decode("base64_Str");  # 解碼;

                                    tempValue = Base.split(temp, '=')[2];
                                    tempValue = Base.strip(tempValue);
                                    tempValue = Base.convert(Core.String, tempValue);
                                    # tempValue = Base.string(tempValue);
                                    tempValue = Core.String(Base64.base64decode(tempValue));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                                    # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                                    # Base64.base64decode("base64_Str");  # 解碼;

                                    request_Url_Query_Dict[Base.string(tempKey)] = Base.string(tempValue);  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);

                                else

                                    request_Url_Query_Dict[Base.string(temp)] = Base.string("");  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);

                                end

                            end
    
                        else

                            if Base.isa(request_Url_Query_String, Core.String) && Base.occursin('=', request_Url_Query_String)

                                tempKey = Base.split(request_Url_Query_String, '=')[1];
                                tempKey = Base.strip(tempKey);
                                tempKey = Base.convert(Core.String, tempKey);
                                # tempKey = Base.string(tempKey);
                                tempKey = Core.String(Base64.base64decode(tempKey));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                                # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                                # Base64.base64decode("base64_Str");  # 解碼;

                                tempValue = Base.split(request_Url_Query_String, '=')[2];
                                tempValue = Base.strip(tempValue);
                                tempValue = Base.convert(Core.String, tempValue);
                                # tempValue = Base.string(tempValue);
                                tempValue = Core.String(Base64.base64decode(tempValue));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                                # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                                # Base64.base64decode("base64_Str");  # 解碼;

                                request_Url_Query_Dict[Base.string(tempKey)] = Base.string(tempValue);  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);

                            else

                                request_Url_Query_Dict[Base.string(request_Url_Query_String)] = Base.string("");  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);

                            end

                        end

                        # try
                        #     eval(:(
                        #         begin
                        #             Sys.eval("global " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # Sys.eval("local " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # println($ARGSArray[1]);
                        #         end
                        #     ));
                        # catch err
                        #     println(err);
                        # end

                    elseif Base.isa(request_head["request_Url"], Core.String) && Base.occursin('#', request_head["request_Url"])

                        # request_Path = Base.string(Base.strip(Base.split(request_head["request_Url"], '#')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.string() 表示强制轉換為字符串(String)型變量;
                        request_Path = Base.convert(Core.String, Base.strip(Base.split(request_head["request_Url"], '#')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.convert() 將子字符串(SubString)型轉換為字符串(String)型變量;

                    else

                        request_Path = Base.string(request_head["request_Url"]);

                    end
                end
            end
            # println("request Path: [ " * request_Path * " ].");
            request_head["request_Path"] = request_Path;
            # println("request url Query: [ " * request_Url_Query_String * " ].");
            request_head["request_Url_Query_String"] = request_Url_Query_String;
            # # println(request_Url_Query_Dict);  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);
            # request_head["request_Url_Query_Dict"] = request_Url_Query_Dict;

            request_Accept::Core.String = "";  # 提取客戶端發送的請求頭裏包含的接受的數據類型參數（"Accept"）;
            if Base.length(request_head) > 0
                # Base.isa(request_head, Base.Dict)

                # 提取客戶端發送的請求頭裏包含的接受的數據類型參數（"Accept"）;
                # request_Accept::Core.String = "";
                if Base.haskey(request_head, "Accept")
                    request_Accept = request_head["Accept"];
                end
            end

            response_Content_Type::Core.String = "";  # "application/octet-stream, text/plain, text/html, text/javascript, text/css, image/jpeg, image/svg+xml, image/png; charset=utf-8";
            if request_Accept === ""
                response_Content_Type = "text/html; charset=utf-8";
            elseif Base.occursin("text/html", request_Accept)
                response_Content_Type = "text/html; charset=utf-8";
            elseif Base.occursin("text/javascript", request_Accept)
                response_Content_Type = "text/javascript; charset=utf-8";
            elseif Base.occursin("text/css", request_Accept)
                response_Content_Type = "text/css; charset=utf-8";
            elseif Base.occursin("application/octet-stream", request_Accept)
                response_Content_Type = "application/octet-stream; charset=utf-8";
            else
                response_Content_Type = request_Accept;  # "application/octet-stream, text/plain, text/html, text/javascript, text/css, image/jpeg, image/svg+xml, image/png; charset=utf-8";
            end

            # 解析請求頭中的 "authorization" 和 "cookie" 參數值，用以獲取客戶端發送的請求賬號和密碼進行權限驗證;
            request_Authorization::Core.String = "";  # 解析獲取客戶端請求頭中的賬號密碼 "authorization" 參數 "Basic domain name -> username:password";
            request_Cookie::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數 "Session_ID=request_Key->username:password";
            request_Cookie_name::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數名;
            request_Cookie_value::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數值;
            request_Key::Core.String = "";  # 判斷如果客戶端發送的請求的賬號密碼來源，如果請求頭 request.headers["Authorization"] 參數不爲空則使用 request.headers["Authorization"] 的參數值作爲客戶端的賬號密碼，如果請求頭 request.headers["Authorization"] 參數為空但 request.headers["Cookie"] 參數不爲空則使用 request.headers["Cookie"]  的參數值，作爲在自定義的 Session 對象中查找的"key"對應的"value"值，作爲客戶端的賬號密碼;
            request_Nikename::Core.String = "";  # 提取賬號密碼;
            request_Password::Core.String = "";  # 提取賬號密碼;

            if Base.length(request_head) > 0
                # Base.isa(request_head, Base.Dict)

                # 解析獲取客戶端請求頭中的賬號密碼 "authorization" 參數;
                # request_Authorization::Core.String = "";
                if Base.haskey(request_head, "Authorization")
                    # println("request Headers Authorization: ", request_head["Authorization"]);
                    # println(Base.typeof(request_head["Authorization"]));

                    if Base.isa(request_head["Authorization"], Core.String) && Base.occursin(' ', request_head["Authorization"])

                        authorArray = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空 1 維數組;
                        # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                        # 函數 Base.split(request_head["Authorization"], ' ') 表示用等號字符'='分割字符串為數組;
                        for x in Base.split(request_head["Authorization"], ' ')
                            temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                            temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                            # temp = Base.string(temp);
                            Base.push!(authorArray, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                        end

                        if Base.length(authorArray) > 1

                            authorValue = "";
                            # authorArray = Base.join(Base.deleteat!(Base.deepcopy(authorArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                            for j = 2:Base.length(authorArray)
                                if j === 2
                                    authorValue = authorValue * authorArray[j];  # 使用星號*拼接字符串;
                                else
                                    authorValue = authorValue * " " * authorArray[j];
                                end
                            end

                            # try
                            #     eval(:(
                            #         begin
                            #             Sys.eval("global " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                            #             # Sys.eval("local " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                            #             # println($ARGSArray[1]);
                            #         end
                            #     ));
                            # catch err
                            #     println(err);
                            # end

                            if authorArray[1] === "Basic" && Base.isa(authorValue, Core.String) && Base.length(authorValue) > 0
                                # !(authorValue === "\r\n\r\n" || authorValue === "")
                                # Base.Unicode.isspace(authorValue)
                                # println("request Headers Authorization: ", authorArray[1] * " " * Core.String(Base64.base64decode(authorValue)));  # 打印請求頭中的使用函數 Base64.base64decode() 解密之後的用戶賬號和密碼參數 "Authorization" 值 "Basic domain name -> username:password"，# 需要事先加載原生的 Base64 模組：using Base64 模組;;
                                request_Authorization = Core.String(Base64.base64decode(authorValue));  # 讀取客戶端發送的請求驗證賬號和密碼 "Basic domain name -> username:password" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                                # request_head["Authorization"] = "Basic" * " " * Base64.base64encode(request_Authorization; context=nothing);  # 編碼 "Basic domain name -> username:password"，需要事先加載原生的 Base64 模組：using Base64 模組;
                            end
                        end
                    end
                end
                # println("request Headers Authorization: [ " * request_Authorization * " ].");

                # 解析獲取客戶端請求頭中的 "cookie" 參數;
                # request_Cookie::Core.String = "";
                # request_Cookie_value::Core.String = "";
                if Base.haskey(request_head, "Cookie")
                    # println("request Headers Cookie: ", request_head["Cookie"]);  # 打印客戶端請求頭中的 Cookie 參數值;
                    # println(Base.typeof(request_head["Cookie"]));
                    request_Cookie = request_head["Cookie"];
                    # request_Cookie = Core.String(Base64.base64decode(request_head["Cookie"]));  # 讀取客戶端發送的請求頭中的 Cookie 參數值，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                    # request_head["Cookie"] = Base64.base64encode(request_Cookie; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
                    # 判斷客戶端發送的請求頭中 Cookie 參數值中是否包含"="符號，如果包含"="符號，則首先使用"="符號分割 Cookie 參數值字符串，否則直接使用 Cookie 參數值字符串;
                    if Base.isa(request_head["Cookie"], Core.String) && Base.occursin("=", request_head["Cookie"])

                        cookieArray = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空 1 維數組;
                        # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                        # 函數 Base.split(request_head["Cookie"], '=') 表示用等號字符'='分割字符串為數組;
                        for x in Base.split(request_head["Cookie"], '=')
                            temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                            temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                            Base.push!(cookieArray, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                        end

                        if Base.length(cookieArray) > 1

                            cookieValue = "";
                            # cookieArray = Base.join(Base.deleteat!(Base.deepcopy(cookieArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                            for j = 2:Base.length(cookieArray)
                                if j === 2
                                    cookieValue = cookieValue * cookieArray[j];  # 使用星號*拼接字符串;
                                else
                                    cookieValue = cookieValue * "=" * cookieArray[j];
                                end
                            end

                            # try
                            #     eval(:(
                            #         begin
                            #             Sys.eval("global " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                            #             # Sys.eval("local " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                            #             # println($ARGSIArray[1]);
                            #         end
                            #     ));
                            # catch err
                            #     println(err);
                            # end

                            # println("request Headers Cookie: ", cookieArray[1] * "=" * Core.String(Base64.base64decode(cookieValue)));  # 打印請求頭中的使用函數 Base64.base64decode() 解密之後的用戶 "Cookie"，# 需要事先加載原生的 Base64 模組：using Base64 模組;;
                            request_Cookie_name = Base.convert(Core.String, cookieArray[1]);  # "Session_ID=request_Key->username:password";
                            request_Cookie_value = Core.String(Base64.base64decode(cookieValue));  # "Session_ID=request_Key->username:password"，讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                            # request_head["cookie"] = request_Cookie_name * "=" * Base64.base64encode(request_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
                            # println("request Cookie name: ", request_Cookie_name);
                            # println("request Cookie value: ", request_Cookie_value);
                        end
                    else
                        request_Cookie_value = Core.String(Base64.base64decode(request_head["Cookie"]));  # "Session_ID=request_Key->username:password"，讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                    end
                end
                # println("request Headers Cookie: [ " * request_Cookie * " ].");
                # println(request Cookie name * ": [ " * request_Cookie_value * " ].");

                # 判斷如果客戶端發送的請求的賬號密碼來源，如果請求頭 request.headers["Authorization"] 參數不爲空則使用 request.headers["Authorization"] 的參數值作爲客戶端的賬號密碼，如果請求頭 request.headers["Authorization"] 參數為空但 request.headers["Cookie"] 參數不爲空則使用 request.headers["Cookie"]  的參數值，作爲在自定義的 Session 對象中查找的"key"對應的"value"值，作爲客戶端的賬號密碼;
                # request_Key::Core.String = "";
                if request_Authorization !== ""
                    # 如果請求頭 request.headers["Authorization"] 參數不爲空，則使用 request.headers["Authorization"] 的參數值，作爲客戶端的賬號密碼;
                    request_Key = request_Authorization;
                elseif request_Cookie !== "" && request_Cookie_value !== ""
                    # 如果客戶端發送的請求頭 request.headers["Authorization"] 參數為空，但如果客戶端發送的請求頭的 request.headers["Cookie"] 參數不爲空，則使用 request.headers["Cookie"]  的參數值，作爲在自定義的 Session 對象中查找的"key"對應的"value"值，作爲客戶端的賬號密碼;
                    if Base.isa(session, Base.Dict)
                        if Base.length(session) > 0 && Base.haskey(session, request_Cookie_value) && (request_Cookie_name === "" || request_Cookie_name === "session_id")
                            # if Base.isa(session[request_Cookie_value], Core.String) && !(session[request_Cookie_value] === "\r\n\r\n" || session[request_Cookie_value] === "")
                                # Base.Unicode.isspace(session[request_Cookie_value])
                                request_Key = session[request_Cookie_value];
                            # end
                        end
                    end
                end
                # println("request Key: [ " * request_Key * " ].");

                # 提取賬號密碼;
                # request_Nikename::Core.String = "";
                # request_Password::Core.String = "";
                if request_Key !== "" && Base.occursin(":", request_Key)

                    KeyArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                    # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                    # 函數 Base.split(request_Key, ':') 表示用等號字符'='分割字符串為數組;
                    for x in Base.split(request_Key, ':')
                        x = Base.convert(Core.String, x);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                        Base.push!(KeyArray, Base.strip(x));  # 使用 Base.push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
                    end

                    if Core.Int64(Base.length(KeyArray)) === Core.Int64(1)
                        request_Nikename = KeyArray[1];
                    end

                    if Base.length(KeyArray) > 1

                        KeyValue = "";
                        # KeyValue = Base.join(Base.deleteat!(Base.deepcopy(KeyArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        for j = 2:Base.length(KeyArray)
                            if j === 2
                                KeyValue = KeyValue * KeyArray[j];  # 使用星號*拼接字符串;
                            else
                                KeyValue = KeyValue * ":" * KeyArray[j];
                            end
                        end

                        # try
                        #     eval(:(
                        #         begin
                        #             Sys.eval("global " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # Sys.eval("local " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # println($KeyArray[1]);
                        #         end
                        #     ));
                        # catch err
                        #     println(err);
                        # end

                        request_Nikename = KeyArray[1];
                        request_Password = KeyValue;
                        # println("request Nikename: [ " * KeyArray[1] * " ], request Password: [ " * KeyValue * " ].");
                    end
                else
                    request_Nikename = request_Key;
                    # request_Password = "";
                end
                # println("request Nikename: [ " * request_Nikename * " ], request Password: [ " * request_Password * " ].");

            end

            if Base.length(request_Url_Query_Dict) > 0
                # Base.isa(request_Url_Query_Dict, Base.Dict)

                # 解析獲取客戶端請求 url 中的賬號密碼 "key" 參數;
                # request_Key::Core.String = "";
                # println(Base.haskey(request_Url_Query_Dict, "key"));
                if Base.haskey(request_Url_Query_Dict, "key")
                    # if Base.isa(request_Url_Query_Dict["key"], Core.String) && Base.occursin(':', request_Url_Query_Dict["key"])
                        request_Key = Base.string(request_Url_Query_Dict["key"]);  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
                    # end
                elseif Base.haskey(request_Url_Query_Dict, "Key")
                    request_Key = Base.string(request_Url_Query_Dict["Key"]);  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
                elseif Base.haskey(request_Url_Query_Dict, "KEY")
                    request_Key = Base.string(request_Url_Query_Dict["KEY"]);  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
                end
                # println("request url query key: [ " * request_Key * " ].");

                # 提取賬號密碼;
                # request_Nikename::Core.String = "";
                # request_Password::Core.String = "";
                if request_Key !== "" && Base.occursin(":", request_Key)

                    KeyArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                    # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                    # 函數 Base.split(request_Key, ':') 表示用等號字符'='分割字符串為數組;
                    for x in Base.split(request_Key, ':')
                        x = Base.convert(Core.String, x);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                        Base.push!(KeyArray, Base.strip(x));  # 使用 Base.push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
                    end

                    if Core.Int64(Base.length(KeyArray)) === Core.Int64(1)
                        request_Nikename = KeyArray[1];
                    end

                    if Base.length(KeyArray) > 1

                        KeyValue = "";
                        # KeyValue = Base.join(Base.deleteat!(Base.deepcopy(KeyArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        for j = 2:Base.length(KeyArray)
                            if j === 2
                                KeyValue = KeyValue * KeyArray[j];  # 使用星號*拼接字符串;
                            else
                                KeyValue = KeyValue * ":" * KeyArray[j];
                            end
                        end

                        # try
                        #     eval(:(
                        #         begin
                        #             Sys.eval("global " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # Sys.eval("local " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # println($KeyArray[1]);
                        #         end
                        #     ));
                        # catch err
                        #     println(err);
                        # end

                        request_Nikename = KeyArray[1];
                        request_Password = KeyValue;
                        # println("request Nikename: [ " * KeyArray[1] * " ], request Password: [ " * KeyValue * " ].");
                    end
                else
                    request_Nikename = request_Key;
                    # request_Password = "";
                end
                # println("request Nikename: [ " * request_Nikename * " ], request Password: [ " * request_Password * " ].");
            end

            # 配置服務器端向客戶端發送的響應數據;
            # Set-Cookie: name=value[; expires=date][; domain=domain][; path=path][; secure];
            # 其中，參數secure選項只是一個標記沒有其它的值，表示一個secure cookie只有當請求是通過SSL和HTTPS創建時，才會發送到伺服器端;
            # 參數domain選項表示cookie作用域，不支持IP數值，只能使用功能變數名稱，指示cookie將要發送到哪個域或那些域中，預設情況下domain會被設置為創建該cookie的頁面所在的功能變數名稱，domain選項被用來擴展cookie值所要發送域的數量;
            # 參數Path選項（The path option），與domain選項相同的是，path指明了在發Cookie消息頭之前，必須在請求資源中存在一個URL路徑，這個比較是通過將path屬性值與請求的URL從頭開始逐字串比較完成的，如果字元匹配，則發送Cookie消息頭;
            # 參數value部分，通常是一個 name=value 格式的字串，通常性的使用方式是以 name=value 的格式來指定cookie的值;
            # 通常cookie的壽命僅限於單一的會話中，流覽器的關閉意味這一次會話的結束，所以會話cookie只存在於流覽器保持打開的狀態之下，參數expires選項用於設定這個cookie壽命（有效時長），一個expires選項會被附加到登錄的cookie中指定一個截止日期，如果expires選項設置了一個過去的時間點，那麼這個cookie會被立即刪除;

            # 需要先加載 Julia 原生的 Dates 模組：using Dates;
            # 函數 Dates.now() 返回當前日期時間對象 2021-06-28T12:12:50.544，使用 Base.string(Dates.now()) 方法，可以返回當前日期時間字符串 2021-06-28T12:12:50.544。
            # 函數 Dates.time() 當前日期時間的 Unix 值 1.652232489777e9，UNIX 時間，或稱爲 POSIX 時間，是 UNIX 或類 UNIX 系統使用的時間表示方式：從 UTC 1970 年 1 月 1 日 0 時 0 分 0 秒起至現在的縂秒數，不考慮閏秒。
            # 函數 Dates.unix2datetime() 將 Unix 時間轉化爲日期（時間）對象，使用 Base.string(Dates.time()) 方法，可以返回當前日期時間字符串 2021-06-28T12:12:50。
            now_date = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            # println(Base.string(Dates.now()))
            after_1_Days = Dates.DateTime(Dates.year(now_date), Dates.month(now_date), Dates.day(now_date) + Dates.day(1), Dates.hour(now_date), Dates.minute(now_date), Dates.second(now_date), Dates.millisecond(now_date));  # 計算 1 日之後的日期，需要先加載原生 Dates 包 using Dates;
            # println(Base.string(after_1_Days));

            response_Cookie_name::Core.String = "session_id";  # "session_id=request_Key->username:password";
            response_Cookie_value::Core.String = Base64.base64encode("request_Key->" * request_Key; context=nothing);  # "session_id=request_Key->username:password"，將漢字做Base64轉碼Base64.base64encode()，需要事先加載原生的 Base64 模組：using Base64 模組;
            # println(response_Cookie_name * "=" * Core.String(Base64.base64decode(response_Cookie_value)));  # Base64解碼 Base64.base64decode(base64)，需要事先加載原生的 Base64 模組：using Base64 模組;
            response_Cookie_string::Core.String = "";
            if response_Cookie_name === ""
                # response_Cookie_string = "request_Key->" * request_Key * "; expires=" * Base.string(after_1_Days) * "; domain=abc.com; path=/; HTTPOnly;");
                response_Cookie_string = response_Cookie_value * ";" * "expires=" * Base.string(after_1_Days) * ";" * "path=/;";  # 拼接 cookie 字符串值 "session_id=request_Key->username:password; expires=2021-06-28T12:12:50.544; path=/";
            else
                # response_Cookie_string = response_Cookie_name * "=" * "request_Key->" * request_Key * "; expires=" * Base.string(after_1_Days) * "; domain=abc.com; path=/; HTTPOnly;");
                response_Cookie_string = response_Cookie_name * "=" * response_Cookie_value * ";" * "expires=" * Base.string(after_1_Days) * ";" * "path=/;";  # 拼接 cookie 字符串值 "session_id=request_Key->username:password; expires=2021-06-28T12:12:50.544; path=/";
            end
            # println(response_Cookie_string);

            server_info::Core.String = "Julia-" * Base.string(Base.VERSION) * " Sockets.listen.";  # "Julia-1.6.2 Sockets.listen.";

            response_data_String::Core.String = "";
            response_Body_String_len::Core.Int64 = 0;
            response_String::Core.String = "";

            # 當服務器端預設的賬號密碼變量不爲空（key !== ""）時，且客戶端發送的請求賬戶密碼空或錯誤時，發送的響應值;
            if (key !== "" && key !== ":") && ((request_Authorization === "" && request_Cookie === "") || request_Nikename !== Base.convert(Core.String, Base.strip(Base.split(key, ':')[1])) || request_Password !== Base.convert(Core.String, Base.strip(Base.split(key, ':')[2])))

                # response_data = Base.Dict{Core.String, Core.String}(
                #     "Server_say" => "No request Headers Authorization or Cookie received.",
                #     "Server_Authorization" => key,
                #     "time" => Base.string(now_date)
                # );
                # response_data_String = JSONstring(response_data);  # 將Julia的字典Dict對象轉換為JSON字符串，自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
                # # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                # # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                if request_Authorization === "" && request_Cookie === ""
                    response_data_String = "{\"Server_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                else request_Nikename !== Base.strip(Base.convert(Core.String, Base.split(key, ':')[1])) || request_Password !== Base.strip(Base.convert(Core.String, Base.split(key, ':')[2]))
                    response_data_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                end
                # response_Body_String_len = Base.sizeof(response_data_String);

                response_statusCode = Core.Int64(401);
                response_status_Message = statusMessage(response_statusCode);
                response_Cookie_string = "";  # * "; expires=" * Base.string(after_1_Days) * "; path=/;";  # 拼接 cookie 字符串值;
            end

            # 當服務器端預設的賬號密碼變量爲空（key === ""）時，或者客戶端發送的請求賬戶密碼通過服務器端的預設變量 key 的驗證時，發送的響應值;
            if (key === "" || key === ":") || (request_Nikename === Base.convert(Core.String, Base.strip(Base.split(key, ':')[1])) && request_Password === Base.convert(Core.String, Base.strip(Base.split(key, ':')[2])))

                # 處理請求數據;
                # JSON_Str = JSONstring(Julia_Dict);  # 自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
                # Julia_Dict = JSONparse(JSON_Str);  # 自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
                # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                request_Dict = Base.Dict{Core.String, Core.Any}(
                    "request_Data" => request_body,
                    "request_Nikename" => request_Nikename,
                    "request_Password" => request_Password,
                    "time" => Base.string(now_date)
                );
                # if Base.length(request_head) > 0
                #     # Base.isa(request_head, Base.Dict)

                #     if Base.haskey(request_head, "request_IP")
                #         request_Dict["request_IP"] = request_head["request_IP"];
                #     end
                #     if Base.haskey(request_head, "request_Method")
                #         request_Dict["request_Method"] = request_head["request_Method"];
                #     end
                #     if Base.haskey(request_head, "request_Url")
                #         request_Dict["request_Url"] = request_head["request_Url"];
                #     end
                #     if Base.haskey(request_head, "request_Path")
                #         request_Dict["request_Path"] = request_head["request_Path"];
                #     end
                #     if Base.haskey(request_head, "request_Protocol")
                #         request_Dict["request_Protocol"] = request_head["request_Protocol"];
                #     end
                #     if Base.haskey(request_head, "Authorization")
                #         request_Dict["Authorization"] = request_head["Authorization"];
                #     end
                #     if Base.haskey(request_head, "Cookie")
                #         request_Dict["Cookie"] = request_head["Cookie"];
                #     end
                #     if Base.haskey(request_head, "From")
                #         request_Dict["From"] = request_head["From"];
                #     end
                #     if Base.haskey(request_head, "User-Agent")
                #         request_Dict["User-Agent"] = request_head["User-Agent"];
                #     end
                #     if Base.haskey(request_head, "Host")
                #         request_Dict["Host"] = request_head["Host"];
                #     end
                #     if Base.haskey(request_head, "Accept")
                #         request_Dict["Accept"] = request_head["Accept"];
                #     end
                #     if Base.haskey(request_head, "Accept-Language")
                #         request_Dict["Accept-Language"] = request_head["Accept-Language"];
                #     end
                #     if Base.haskey(request_head, "Accept-Charset")
                #         request_Dict["Accept-Charset"] = request_head["Accept-Charset"];
                #     end
                #     if Base.haskey(request_head, "Date")
                #         request_Dict["Date"] = request_head["Date"];
                #     end
                # end
                for (itemKey, itemValue) in request_head
                    request_Dict[itemKey] = itemValue;
                end

                # 將客戶端請求 url 中的查詢字符串值解析為 Julia 字典類型;
                request_Url_Query_Dict = Base.Dict{Core.String, Core.Any}();  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);
                if Base.isa(request_Url_Query_String, Core.String) && request_Url_Query_String !== ""

                    if Base.occursin('&', request_Url_Query_String)

                        # url_Query_Array = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空1維數組，可以使用 Base.push! 函數在數組末尾追加推入新元素;
                        # url_Query_Array = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                        # 函數 Base.split(request_Url_Query_String, '&') 表示用等號字符'&'分割字符串為數組;
                        for x in Base.split(request_Url_Query_String, '&')
                            temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                            temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                            # temp = Base.string(temp);

                            if Base.isa(temp, Core.String) && Base.occursin('=', temp)

                                tempKey = Base.split(temp, '=')[1];
                                tempKey = Base.strip(tempKey);
                                tempKey = Base.convert(Core.String, tempKey);
                                tempKey = Base.string(tempKey);
                                # tempKey = Base.string(Base64.base64decode(tempKey));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                                # # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                                # # Base64.base64decode("base64_Str");  # 解碼;

                                tempValue = Base.split(temp, '=')[2];
                                tempValue = Base.strip(tempValue);
                                tempValue = Base.convert(Core.String, tempValue);
                                tempValue = Base.string(tempValue);
                                # tempValue = Base.string(Base64.base64decode(tempValue));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                                # # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                                # # Base64.base64decode("base64_Str");  # 解碼;

                                request_Url_Query_Dict[Base.string(tempKey)] = Base.string(tempValue);

                            else

                                request_Url_Query_Dict[Base.string(temp)] = Base.string("");
                            end
                        end

                    else

                        if Base.isa(request_Url_Query_String, Core.String) && Base.occursin('=', request_Url_Query_String)

                            tempKey = Base.split(request_Url_Query_String, '=')[1];
                            tempKey = Base.strip(tempKey);
                            tempKey = Base.convert(Core.String, tempKey);
                            # tempKey = Base.string(tempKey);
                            tempKey = Core.String(Base64.base64decode(tempKey));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                            # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                            # Base64.base64decode("base64_Str");  # 解碼;

                            tempValue = Base.split(request_Url_Query_String, '=')[2];
                            tempValue = Base.strip(tempValue);
                            tempValue = Base.convert(Core.String, tempValue);
                            # tempValue = Base.string(tempValue);
                            tempValue = Core.String(Base64.base64decode(tempValue));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                            # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                            # Base64.base64decode("base64_Str");  # 解碼;

                            request_Url_Query_Dict[Base.string(tempKey)] = Base.string(tempValue);

                        else

                            request_Url_Query_Dict[Base.string(request_Url_Query_String)] = Base.string("");
                        end
                    end
                end
                # println(request_Url_Query_Dict);  # Base.Dict("a" => 1, "b" => 2);
                # request_head["request_Url_Query_Dict"] = request_Url_Query_Dict;
                request_Dict["request_Url_Query_Dict"] = request_Url_Query_Dict;

                # try
                #     eval(:(
                #         begin
                #             Sys.eval("global " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                #             # Sys.eval("local " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                #             # println($ARGSArray[1]);
                #         end
                #     ));
                # catch err
                #     println(err);
                # end
                
                # 判斷變量 do_Function 是否已經被定義，并且是否為函數類型;
                if Base.@isdefined(do_Function) && Base.typeof(do_Function) <: Function
                    # response_data = Base.Dict{Core.String, Core.String}(
                    #     "Server_say" => "No request Headers Authorization or Cookie received.",
                    #     "Server_Authorization" => key,
                    #     "time" => Base.string(now_date)
                    # );
                    # response_data_String = JSONstring(response_data);  # 將Julia的字典Dict對象轉換為JSON字符串，自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
                    # # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                    # # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;

                    # 無并發，就在當前主進程（Master）中，處理輸入任務隊列;
                    if Core.Int8(number_Worker_threads) <= Core.Int8(0)

                        # 記錄每個協程（Task）纍加的被調用運算的總次數;
                        # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                        # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                        if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid()))
                            # global total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid())]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                            total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid())]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                        else
                            # global total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                        end

                        try
                            response_statusCode = Core.Int64(200);
                            response_status_Message = statusMessage(response_statusCode);

                            # response_data_String = do_Function(request_head["request_Url"], request_body, request_head);
                            response_data_String = do_Function(request_Dict);
                            # Base.write(Base.stdout, response_data_String);
                            # println(response_data_String);

                            # log_text = "";
                            # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                            #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                            #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * Base.string(response_statusCode) * " .";
                            #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                            #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                            #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                            #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                            #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                            #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * Base.string(response_statusCode) * " .";
                            #     end
                            # else
                            #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * Base.string(request_head["request_IP"]) * Base.string(request_head["request_Url"]) * Base.string(response_statusCode) * " .";
                            # end
                            # print(log_text * "\n");

                        catch err

                            # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                            if Core.isa(err, Core.InterruptException)

                                print("\n");
                                # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                                # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                                println("[ Ctrl ] + [ c ] received, will be stop the TCP Server.");

                                # # 打印進程被調用數目;
                                # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                                #     if isConcurrencyHierarchy === "Multi-Processes"

                                #         # Base.haskey(collection, key) -> Bool
                                #         # workNum = "worker";
                                #         for k in Base.keys(total_worker_called_number)
                                #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                #         end
                                #         # println(workNum);

                                #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                                #         # Base.haskey(collection, key) -> Bool
                                #         # workNum = "worker";
                                #         for k in Base.keys(total_worker_called_number)
                                #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                #         end
                                #         # println(workNum);

                                #     end

                                #     total_worker_called_number = Core.nothing;
                                # end

                                # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                                # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                                #     # Base.haskey(collection, key) -> Bool
                                #     # for k in Base.keys(worker_queues_Dict)
                                #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                                #     # end

                                #     worker_queues_Dict = Core.nothing;
                                # end

                                println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                                # Base.exit(0);
                                return ["", server, total_worker_called_number];

                            else

                                # Base.write(stderr, err);
                                # Base.write(Base.stdout, err, "\n");
                                println("自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                                println(err);
                                # println(err.msg);
                                # println(Base.typeof(err));

                                response_statusCode = Core.Int64(500);
                                response_status_Message = statusMessage(response_statusCode);
                                response_data_String = "{\"Server_say\":\"" * "Server calculate data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;

                                # Base.close(sock);  # 中斷當前的這個鏈接;
                                # Base.sleep(time_sleep);
                                # continue;
                                # # break;
                            end
                        end
                        # response_data_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                        # println(response_data_String);
                    end

                    # 開啓并發，在子進程（Worker）中，處理輸入任務隊列;
                    if Core.Int8(number_Worker_threads) > Core.Int8(0)

                        # # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.Task}();
                        # # # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
                        # # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
                    
                        # # 創建通道(Channel);
                        # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                        # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                        # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));  # 用於控制并發數目的通道，寫入一個元素相當於記錄一個啓動的子協程(task)，取出一個元素相當於一個子協程(task)執行完畢，如通道已經滿，則阻塞等待;
                        # # Base.put!(main_to_sub_channel, channel_message_Dict);  # 向通道(Channel)中寫入元素;
                        # # # Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
                        # # Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                        # # Base.close(main_to_sub_channel);  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗;

                        if isConcurrencyHierarchy === "Tasks"

                            # 在 Julia 中，稱協程（Coroutine）為任務（Task）。創建任務（Task）的方式有兩種，
                            # 用構造方法：
                            # taskname = Task(f)
                            # 用構造方法 Task(f) 將一個函數對象 f 封裝成名為 taskname 的任務（Task）。此時要求函數對象 f 必須是無參數的，即沒有參數或所有參數都有預設值。假如函數對象 f 有參數，那麼 f 就變成了運算式，在傳入 Task() 前會被執行，於是傳入 Task() 的不再是函數對象而是執行結果。為解決此問題，可以定義一個 f1()=f(參數)，然後 taskname = Task(f1)。
                            # 巨集（宏）命令 @task 將一個運算式封裝成任務（Task）
                            # taskname = @task 運算式
                            # 用巨集（宏）命令 @task 將一個運算式封裝成名為 taskname 的任務（Task）。注意大小寫。
                            # 創建後，可用 istaskstarted(taskname) 函數和 istaskdone(taskname) 函數查看創建的任務（Task）是否啟動和結束。Task 有五個狀態：runnable（可被啟動）, waiting（阻塞等待中）, queued（正被調度中）, done（執行結束）, failed（執行異常結束）。在 Julia 內部有一個調度器，負責維護 task 運行佇列。用 schedule(taskname) 函數可以把 Task 加入佇列並啟動，隨後會自動返回 done 狀態，表示已完成。
                            # 對於運算式，有個「合二為一」的巨集命令：@async 運算式。它會創建 Task 並直接啟動。例如：
                            # using Distributed
                            # a=zeros(1,5)
                            # 1×5 Array{Float64,2}:
                            # 0.0  0.0  0.0  0.0  0.0
                            # @async fill!(a, 4)
                            # Task (done) @0x00000000063059f0
                            # println(a)
                            # 1×5 Array{Float64,2}:
                            # 4.0  4.0  4.0  4.0  4.0
                            # 1
                            # 2
                            # 3
                            # 4
                            # 5
                            # 6
                            # 7
                            # 8
                            # 9
                            # 10
                            # 11
                            # 12
                            # 可以在被傳給 Task() 的函數對象 f 內部使用某些命令強迫這一 Task 改變狀態，包括：
                            # Base.sleep(N)  睡眠N秒
                            # yield()  請求切換為其他 task
                            # yieldto(taskname)  請求切換為指定的task，一般不建議使用
        
                            # 通道、管道(Channel);
                            # Base.Channel{T=Any}(size::Int=0);
                            # 如果一個 Channel 是空的，讀取的 task（即執行 v = Base.take!(c::Channel) 的 task）會被阻塞直到有新的資料準備好了。
                            # 如果一個 Channel 是滿的，那麼寫入的 task（即執行 Base.put!(c::Channel, v) 的 task）則會被阻塞，直到 Channel 有空餘。
                            # Base.isready(c::Channel) 可以用來檢查一個 channel 中是否有已經準備好的元素，而等待一個元素準備好 則用 Base.wait(r::Future) 函數。
                            # 一個 Channel 一開始處於開啟狀態，也就是說可以被 take! 讀取和 put! 寫入。Base.close(c::Channel[, excp::Exception]) 會關閉一個 Channel，對於一個已經關閉的 Channel，put! 會失敗。
                            # Channel 可以在 for 迴圈中遍歷，此時，迴圈會一直運行直到 Channel 中有資料，遍歷過程中會取遍加入到 Channel 中的所有值。一旦 Channel關閉或者取空了，for 迴圈就會終止。
                            # c = Channel{Int}(10)
                            # foreach(i->put!(c, i), 1:3)
                            # 此時，如果直接用 for 去遍歷通道 c 中的內容，則在讀取完後會一直等待通道(Channel)中有新的資料進來，如果在控制臺REPL上運行，則會停在那裡。
                            # data = [i for i in c]
                            # 如果先把Channel關閉，再用for去遍歷，則會讀出Channel中的內容，因此此時c已經關閉，for不會再等待寫入了。
                            # close(c);
                            # data = [i for i in c]
        
                            # 使用 Base.bind(chnl::Channel, task::Task) 方法，將通道(Channel)的生存期與任務或叫協程(task)相關聯。當協程(task)終止時，通道(Channel)自動關閉。任務中任何未捕獲的異常都會傳播到通道(Channel)上的所有等待者。
                            # 通道(Channel)對象可以獨立於協程(task)終止顯式關閉。終止協程(task)對已關閉的通道(Channel)對象沒有影響。
                            # 當通道(Channel)綁定到多個協程(task)時，第一個終止的協程(task)將關閉通道(Channel)。當多個通道(Channel)綁定到同一個協程(task)時，協程(task)的終止將關閉所有綁定的通道(Channel)。
                            # task = Base.@async foreach(i->put!(c, i), 1:4);
                            # Base.bind(c,task);
                            # for i in c
                            #     Base.@show i
                            #     println(Base.current_task())
                            # end;
                            # i = 1
                            # i = 2
                            # i = 3
                            # i = 4
                            # Base.isopen(c)
                            # false
                            # c2 = Base.Channel{Core.Float64}(32)  # 創建一個長度爲 32，元素(item)類型爲 Float64 的通道(Channel);
                            # Base.put!(c2, 2)  # 向通道(Channel)中寫入元素;
                            # itme1 = Base.fetch(c2)  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
                            # itme1 = Base.take!(c2)  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                            # Base.close(c2)  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗，take!() 和 fetch() 爲空時，將會關閉這個通道;
                            # Base.isready(c2)
        
                            # # 用Channel完成多工（多任務 task）之間的資料交互
                            # # 新建兩個Channel，一個是Int型，一個是Tuple型，對於每個任務，延時一段時間後，開始執行該任務的內容，並將結果放入到results中。
                            # const jobs = Channel{Int}(32)
                            # const results = Channel{Tuple}(32)
                            # function do_work()
                            #     for job_id in jobs
                            #         exec_time = rand()
                            #         Base.sleep(exec_time)  # simulates elapsed time doing actual work typically performed externally.
                            #         put!(results, (job_id, exec_time))
                            #     end
                            # end
                            # # 向jobs中放入數據
                            # function make_jobs(n)
                            #     for i in 1:n
                            #         put!(jobs, i)
                            #     end
                            # end
                            # # 寫入12個資料
                            # n = 12
                            # @async make_jobs(n)
                            # # @async表示把後面的運算式放到Task裡，並加入到程式的執行清單中
                            # # 開四個任務來處理
                            # for i in 1:4
                            #     # start 4 tasks to process requests in parallel
                            #     @async do_work()
                            # end
                            # # 取出4個任務的執行結果
                            # @elapsed while n > 0
                            #     # print out results
                            #     job_id, exec_time = take!(results)
                            #     println("$job_id finished in $(round(exec_time; digits=2)) seconds")
                            #     global n = n - 1
                            # end
                            # # >>1 finished in 0.51 seconds
                            # # 4 finished in 0.62 seconds
                            # # 3 finished in 0.75 seconds
                            # # 2 finished in 0.81 seconds
                            # # 5 finished in 0.55 seconds
                            # # 8 finished in 0.35 seconds
                            # # 6 finished in 0.77 seconds
                            # # 9 finished in 0.38 seconds
                            # # 12 finished in 0.11 seconds
                            # # 7 finished in 0.88 seconds
                            # # 11 finished in 0.25 seconds
                            # # 10 finished in 0.75 seconds

                            # 控制並發數;
                            # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                            Base.put!(control_number_Queues_channel, Core.UInt64(1));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                            worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                "arguments" => request_Dict,
                                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                "label" => "Run",
                                "message" => "Run"
                            );

                            # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                            # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                            Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                            # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                            #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                            # end

                            try
                                # 創建一個子協程（worker task）;
                                f() = funcTask(
                                    # worker_data_Dict,
                                    do_Function,
                                    main_to_sub_channel,
                                    sub_to_main_channel,
                                    control_number_Queues_channel
                                );
                                workerTask = Core.Task(f);  # 創建一個協程（任務）task;
                                workerTask.sticky = false;

                                # # 保存每個被創建的協程(task)在一個字典中;
                                # # 使用 Base.objectid(Base.current_task()) 方法返回當前協程（task） ID 號;
                                # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                # if Base.haskey(worker_queues_Dict, Base.string(Base.objectid(workerTask)))
                                #     # global worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                #     worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                # else
                                #     # global worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                #     worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                # end
                                # # 記錄每個綫程纍加的被調用運算的總次數;
                                # # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                # if Base.haskey(total_worker_called_number, Base.string(Base.objectid(workerTask)))
                                #     # global total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(workerTask))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                #     total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(workerTask))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                # else
                                #     # global total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                #     total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                # end

                                Base.schedule(workerTask);  # 用 Base.schedule(t::Task, [val]; error=false) 函數把未啓動的協程(Task)加入等待執行的隊列並啓動，隨後會自動返回 done 狀態，表示已經執行完畢;
                                # Base.wait(workerTask);  # 阻塞主進程後面的代碼執行，直到該子協程 workerTask 運行完畢;
                                # 用 istaskstarted(taskname) 和 istaskdone(taskname) 查看 Task 是否已經啓動和結束。Task 有五個狀態：runnable（可被啓動）, waiting（阻塞等待中）, queued（正被調度中）, done（執行結束）, failed（執行異常結束）。Julia 内部有一個調度器，負責維護 task 運行隊列;

                                # 讀出輸出通道中子協程(task)返回的結果;
                                # Base.take!(sub_to_main_channel);
                                # 這裏 for 結構本質上是一串自動執行的從通道中取出元素 take!() 的操作，和 take!() 操作一樣會移除元素。當通道 Channel 中元素取為空時，for 結構會阻塞;
                                # 使用 close(channelname) 强制關閉通道 Channel 的入口並釋放所有 put!() 和 take!() 的阻塞，此時 for 循環取完通道 Channel 中元素為空時，將不再阻塞會自行退出;
                                for result_Dict in sub_to_main_channel

                                    # result_Dict = Base.Dict{Core.String, Core.Any}(
                                    #     # "do_Function" => do_Function,  # worker_Data_Dict["do_Function"]， # do_data ;
                                    #     "result_data" => response_data_String,
                                    #     "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                    #     "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                    #     "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                    #     "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #     "label" => result[1],
                                    #     "message" => "Function [ do_Function ] return " * result[1] * ".",
                                    #     "request_Arguments" => request_Arguments = Base.Dict{Core.String, Core.String}(
                                    #         "request_Data" => request_body,
                                    #         "request_Nikename" => request_Nikename,
                                    #         "request_Password" => request_Password,
                                    #         "time" => Base.string(now_date),
                                    #         "request_IP" => request_head["request_IP"],
                                    #         "request_Method" => request_head["request_Method"],
                                    #         "request_Path" => request_head["request_Url"],
                                    #         "request_Protocol" => request_head["request_Protocol"].
                                    #         "Authorization" => request_head["Authorization"],
                                    #         "Cookie" => request_head["Cookie"],
                                    #         "From" => request_head["From"],
                                    #         "User-Agent" => request_head["User-Agent"],
                                    #         "Host" => request_head["Host"],
                                    #         "Accept" => request_head["Accept"],
                                    #         "Accept-Language" => request_head["Accept-Language"],
                                    #         "Accept-Charset" => request_head["Accept-Charset"],
                                    #         "Date" => request_head["Date"]
                                    #     )
                                    # );

                                    if Base.isa(result_Dict, Base.Dict)

                                        # 記錄每個協程（Task）纍加的被調用運算的總次數;
                                        # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                        if Base.haskey(total_worker_called_number, Base.string(result_Dict["threadID"]))
                                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                        else
                                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                        end
                                        # if Base.haskey(total_worker_called_number, Base.string(result_Dict["taskID"]))
                                        #     # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                        #     total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                        # else
                                        #     # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                        #     total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                        # end
    
                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "error"
                                            if Base.haskey(result_Dict, "taskID") && result_Dict["taskID"] !== Core.nothing && Base.isa(result_Dict["taskID"], Core.String) && result_Dict["taskID"] !== ""
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                end
                                            else
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task return error.");
                                                end
                                            end
    
                                            response_statusCode = Core.Int64(500);
                                            response_status_Message = statusMessage(response_statusCode);

                                            # Base.close(sock);  # 中斷當前的這個鏈接;
                                            # Base.sleep(time_sleep);
                                            # continue;
                                            # # break;
                                        end
    
                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "success"
                                            response_statusCode = Core.Int64(200);
                                            response_status_Message = statusMessage(response_statusCode);
                                        end
    
                                        response_data_String =  response_data_String * Base.string(result_Dict["result_data"]);
                                        # response_data_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                        # println(response_data_String);

                                        # log_text = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * Base.string(response_statusCode) * " .";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * Base.string(request_head["request_IP"]) * Base.string(request_head["request_Url"]) * Base.string(response_statusCode) * " .";
                                        # end
                                        # print(log_text * "\n");

                                        # response_data_String = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                        # Base.GC.gc();  # 内存回收函數 gc();

                                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        # println(Base.string(nowTime));
                                        # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # log_text::Core.String = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " >.";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " .";
                                        # end
                                        # print(log_text * "\n");
                                        # log_file = "";  # 日志文檔;
                                        # # 同步寫入用於記錄過程的日志文檔;
                                        # try
                                        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #     # # write(filename::AbstractString, x)
                                        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                        #     # println(numBytes);
                                        #     # println(Base.stat(log_file).size);
                                        #     # println(Base.stat(log_file).mtime);
                                        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #     # println(Base.stat(log_file).ctime);
                                        #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #     # # Base.countlines — Function
                                        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #     # println(Base.countlines(log_file, eol='\\n'));

                                        #     fWIO = Base.open(log_file, "a+");
                                        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                        #     # Keyword	Description				Default
                                        #     # read		open for reading		!write
                                        #     # write		open for writing		truncate | append
                                        #     # create	create if non-existent	!read & write | truncate | append
                                        #     # truncate	truncate to zero size	!read & write
                                        #     # append	seek to end				false

                                        #     # Mode	Description						Keywords
                                        #     # r		read							none
                                        #     # w		write, create, truncate			write = true
                                        #     # a		write, create, append			append = true
                                        #     # r+	read, write						read = true, write = true
                                        #     # w+	read, write, create, truncate	truncate = true, read = true
                                        #     # a+	read, write, create, append		append = true, read = true

                                        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                        #     if Base.iswritable(fWIO)
                                        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #         println(numBytes);
                                        #         println(Base.stat(log_file).size);
                                        #         println(Base.stat(log_file).mtime);
                                        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #         println(Base.stat(log_file).ctime);
                                        #         # Base.displaysize([io::IO]) -> (lines, columns)
                                        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #         # Base.countlines — Function
                                        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #         println(Base.countlines(log_file, eol='\\n'));
                                        #     end

                                        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                                        #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                                        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                        #     # Base.ismarked(io);  # Return true if stream s is marked;
                                        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                        #     # Base.close(io);  # 關閉緩衝區;
                                        #     # println(a)
                                        #     # Base.redirect_stdout — Function
                                        #     # redirect_stdout([stream]) -> (rd, wr)
                                        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                        #     # If called with the optional stream argument, then returns stream itself.
                                        #     # Base.redirect_stdout — Method
                                        #     # redirect_stdout(f::Function, stream)
                                        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                        #     # Base.redirect_stderr — Function
                                        #     # redirect_stderr([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stderr.
                                        #     # Base.redirect_stderr — Method
                                        #     # redirect_stderr(f::Function, stream)
                                        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                        #     # Base.redirect_stdin — Function
                                        #     # redirect_stdin([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                        #     # Base.redirect_stdin — Method
                                        #     # redirect_stdin(f::Function, stream)
                                        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                        # catch err
                                        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                        #     println(err);
                                        #     # println(Base.typeof(err));

                                        #     # Julia提供了許多類型的錯誤：
                                        #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                                        #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                                        #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                                        #     # DivideError：這是數字除以0時的結果。
                                        #     # DomainError：有效域之外的參數。
                                        #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                                        #     # InexactError：嘗試進行精確類型轉換失敗。
                                        #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                                        #     # LoadError：載入檔時發生錯誤。
                                        #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                                        #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                                        #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                                        #     # OverflowError：當操作結果太大時會發生這種情況。
                                        #     # ParseError：解析給定運算式時出現問題。
                                        #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                                        #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                                        #     # UndefRefError：未知引用。
                                        #     # UndefVarError：對不存在的變數進行未知引用。
                                        #     # InitError：調用模組的init方法時出現此錯誤。
                                        #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                                        #     # NullException：嘗試訪問Null值
                                        #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                                        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                        # finally
                                        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                        #     if Base.eof(fWIO)
                                        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                        #     end
                                        # end
                                    end

                                    # 使用 Base.isready(c::Channel) 函數判斷通道中元素是否已經取空，如果已經取空 Base.isready(c::Channel) 返回為 false 值，則跳出 for 循環，如果一個空通道從未寫入過元素，則 Base.isready(sub_to_main_channel) 值爲 true，因此會一直阻塞等待不會跳出循環;
                                    if !Base.isready(sub_to_main_channel)
                                        break;
                                    end
                                end
                                # response_data_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                # println(response_data_String);

                            catch err

                                while Base.isreadable(sub_to_main_channel)
                                    Base.take!(sub_to_main_channel);
                                end
                                # for result_Dict in sub_to_main_channel
                                # end
                                # for i = 1:Base.length(sub_to_main_channel)
                                #     Base.take!(sub_to_main_channel);
                                # end

                                # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                                if Core.isa(err, Core.InterruptException)

                                    print("\n");
                                    # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                                    # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                                    println("[ Ctrl ] + [ c ] received, will be stop the TCP Server.");

                                    # # 打印進程被調用數目;
                                    # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                                    #     if isConcurrencyHierarchy === "Multi-Processes"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     end

                                    #     total_worker_called_number = Core.nothing;
                                    # end

                                    # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                                    # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                                    #     # Base.haskey(collection, key) -> Bool
                                    #     # for k in Base.keys(worker_queues_Dict)
                                    #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                                    #     # end

                                    #     worker_queues_Dict = Core.nothing;
                                    # end

                                    println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                                    # Base.exit(0);
                                    return ["", server, total_worker_called_number];

                                else

                                    # Base.write(stderr, err);
                                    # Base.write(Base.stdout, err, "\n");
                                    println("多協程並發（multi-task）時，工作協程（worker-task）中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                                    println(err);
                                    # println(err.msg);
                                    # println(Base.typeof(err));

                                    response_statusCode = Core.Int64(500);
                                    response_status_Message = statusMessage(response_statusCode);
                                    # response_data_String = "{\"Server_say\":\"" * "Server calculate data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;

                                    # Base.close(sock);  # 中斷當前的這個鏈接;
                                    # Base.sleep(time_sleep);
                                    # continue;
                                    # # break;
                                end
                            end
                        end

                        # 需要注意，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
                        if isConcurrencyHierarchy === "Multi-Threading"

                            # 必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
                            # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
                            # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
                            # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
                            # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;

                            # 通道、管道(Channel);
                            # Base.Channel{T=Any}(size::Int=0);
                            # 如果一個 Channel 是空的，讀取的 task（即執行 v = Base.take!(c::Channel) 的 task）會被阻塞直到有新的資料準備好了。
                            # 如果一個 Channel 是滿的，那麼寫入的 task（即執行 Base.put!(c::Channel, v) 的 task）則會被阻塞，直到 Channel 有空餘。
                            # Base.isready(c::Channel) 可以用來檢查一個 channel 中是否有已經準備好的元素，而等待一個元素準備好 則用 Base.wait(r::Future) 函數。
                            # 一個 Channel 一開始處於開啟狀態，也就是說可以被 take! 讀取和 put! 寫入。Base.close(c::Channel[, excp::Exception]) 會關閉一個 Channel，對於一個已經關閉的 Channel，put! 會失敗。
                            # Channel 可以在 for 迴圈中遍歷，此時，迴圈會一直運行直到 Channel 中有資料，遍歷過程中會取遍加入到 Channel 中的所有值。一旦 Channel關閉或者取空了，for 迴圈就會終止。
                            # c = Channel{Int}(10)
                            # foreach(i->put!(c, i), 1:3)
                            # 此時，如果直接用 for 去遍歷通道 c 中的內容，則在讀取完後會一直等待通道(Channel)中有新的資料進來，如果在控制臺REPL上運行，則會停在那裡。
                            # data = [i for i in c]
                            # 如果先把Channel關閉，再用for去遍歷，則會讀出Channel中的內容，因此此時c已經關閉，for不會再等待寫入了。
                            # close(c);
                            # data = [i for i in c]

                            # 使用 Base.bind(chnl::Channel, task::Task) 方法，將通道(Channel)的生存期與任務或叫協程(task)相關聯。當協程(task)終止時，通道(Channel)自動關閉。任務中任何未捕獲的異常都會傳播到通道(Channel)上的所有等待者。
                            # 通道(Channel)對象可以獨立於協程(task)終止顯式關閉。終止協程(task)對已關閉的通道(Channel)對象沒有影響。
                            # 當通道(Channel)綁定到多個協程(task)時，第一個終止的協程(task)將關閉通道(Channel)。當多個通道(Channel)綁定到同一個協程(task)時，協程(task)的終止將關閉所有綁定的通道(Channel)。
                            # task = Base.@async foreach(i->put!(c, i), 1:4);
                            # Base.bind(c,task);
                            # for i in c
                            #     Base.@show i
                            #     println(Base.current_task())
                            # end;
                            # i = 1
                            # i = 2
                            # i = 3
                            # i = 4
                            # Base.isopen(c)
                            # false
                            # c2 = Base.Channel{Core.Float64}(32)  # 創建一個長度爲 32，元素(item)類型爲 Float64 的通道(Channel);
                            # Base.put!(c2, 2)  # 向通道(Channel)中寫入元素;
                            # itme1 = Base.fetch(c2)  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
                            # itme1 = Base.take!(c2)  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                            # Base.close(c2)  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗，take!() 和 fetch() 爲空時，將會關閉這個通道;
                            # Base.isready(c2)

                            # # 用Channel完成多工（多任務 task）之間的資料交互
                            # # 新建兩個Channel，一個是Int型，一個是Tuple型，對於每個任務，延時一段時間後，開始執行該任務的內容，並將結果放入到results中。
                            # const jobs = Channel{Int}(32)
                            # const results = Channel{Tuple}(32)
                            # function do_work()
                            #     for job_id in jobs
                            #         exec_time = rand()
                            #         Base.sleep(exec_time)  # simulates elapsed time doing actual work typically performed externally.
                            #         put!(results, (job_id, exec_time))
                            #     end
                            # end
                            # # 向jobs中放入數據
                            # function make_jobs(n)
                            #     for i in 1:n
                            #         put!(jobs, i)
                            #     end
                            # end
                            # # 寫入12個資料
                            # n = 12
                            # @async make_jobs(n)
                            # # @async表示把後面的運算式放到Task裡，並加入到程式的執行清單中
                            # # 開四個任務來處理
                            # for i in 1:4
                            #     # start 4 tasks to process requests in parallel
                            #     @async do_work()
                            # end
                            # # 取出4個任務的執行結果
                            # @elapsed while n > 0
                            #     # print out results
                            #     job_id, exec_time = take!(results)
                            #     println("$job_id finished in $(round(exec_time; digits=2)) seconds")
                            #     global n = n - 1
                            # end
                            # # >>1 finished in 0.51 seconds
                            # # 4 finished in 0.62 seconds
                            # # 3 finished in 0.75 seconds
                            # # 2 finished in 0.81 seconds
                            # # 5 finished in 0.55 seconds
                            # # 8 finished in 0.35 seconds
                            # # 6 finished in 0.77 seconds
                            # # 9 finished in 0.38 seconds
                            # # 12 finished in 0.11 seconds
                            # # 7 finished in 0.88 seconds
                            # # 11 finished in 0.25 seconds
                            # # 10 finished in 0.75 seconds

                            # 控制並發數;
                            # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                            Base.put!(control_number_Queues_channel, Core.UInt64(1));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                            worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                "arguments" => request_Dict,
                                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                "label" => "Run",
                                "message" => "Run"
                            );

                            # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                            # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                            Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                            # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                            #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                            # end

                            try
                                # 創建一個子綫程（worker thread）;
                                # 需要注意，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
                                # workerThread = Base.Threads.@spawn begin
                                #     funcTask(
                                #         # worker_data_Dict,
                                #         do_Function,
                                #         main_to_sub_channel,
                                #         sub_to_main_channel,
                                #         control_number_Queues_channel
                                #     );
                                # end
                                workerThread = Base.Threads.@spawn funcTask(
                                    # worker_data_Dict,
                                    do_Function,
                                    main_to_sub_channel,
                                    sub_to_main_channel,
                                    control_number_Queues_channel
                                );
                                # r = Base.fetch(workerThread);  # 等待讀取子綫程運行完畢後的返回值，阻塞後面的代碼執行;
                                # Base.wait(workerThread);  # 阻塞主進程後面的代碼執行，直到該子綫程 workerThread 運行完畢;

                                # # 保存每個被創建的綫程（worker thread）在一個字典中;
                                # # 使用 Base.Threads.threadid() 方法返回當前綫程 ID 號;
                                # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                # if Base.haskey(worker_queues_Dict, Base.string(Base.Threads.threadid(workerThread)))
                                #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                # else
                                #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                # end
                                # # 記錄每個綫程纍加的被調用運算的總次數;
                                # # 使用 Base.Threads.threadid() 方法返回當前子綫程(thread) ID 號;
                                # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                # if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid(workerThread)))
                                #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                # else
                                #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                # end

                                # # Base.Threads.@threads for...end
                                # # A macro to parallelize a for-loop to run with multiple threads. This spawns nthreads() number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.
                                # # 使用 Base.Threads.@threads for...end 方法創建子綫程，多綫程并發執行 for...end 循環，在每次 for 循環中具體動作;
                                # Base.Threads.@threads for i in 1:input_queues_length

                                #     if Base.isa(input_queues_array[i], Base.Dict)

                                #         # 控制並發數;
                                #         # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                                #         Base.put!(control_number_Queues_channel, Core.UInt64(i));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                                #         worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                #             # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                #             "arguments" => input_queues_array[i]
                                #             );

                                #         # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                                #         # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                                #         Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                                #         # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                                #         #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                                #         # end

                                #         resultArray = funcTask(
                                #             # worker_data_Dict,
                                #             do_Function,
                                #             main_to_sub_channel,
                                #             sub_to_main_channel,
                                #             control_number_Queues_channel
                                #             );
                                #         # println(resultArray);

                                #         # # 保存每個被創建的綫程（worker thread）在一個字典中;
                                #         # # 使用 Base.Threads.threadid() 方法返回當前綫程 ID 號;
                                #         # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                #         # if Base.haskey(worker_queues_Dict, Base.string(Base.Threads.threadid(workerThread)))
                                #         #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #         #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #         # else
                                #         #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #         #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #         # end
                                #         # # 記錄每個綫程纍加的被調用運算的總次數;
                                #         # # 使用 Base.Threads.threadid() 方法返回當前子綫程(thread) ID 號;
                                #         # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                #         # if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid(workerThread)))
                                #         #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                #         #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                #         # else
                                #         #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                #         #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                #         # end
                                #     end
                                # end


                                # 讀出輸出通道中子協程(task)返回的結果;
                                # Base.take!(sub_to_main_channel);
                                # 這裏 for 結構本質上是一串自動執行的從通道中取出元素 take!() 的操作，和 take!() 操作一樣會移除元素。當通道 Channel 中元素取為空時，for 結構會阻塞;
                                # 使用 close(channelname) 强制關閉通道 Channel 的入口並釋放所有 put!() 和 take!() 的阻塞，此時 for 循環取完通道 Channel 中元素為空時，將不再阻塞會自行退出;
                                for result_Dict in sub_to_main_channel

                                    # result_Dict = Base.Dict{Core.String, Core.Any}(
                                    #     # "do_Function" => do_Function,  # worker_Data_Dict["do_Function"]， # do_data ;
                                    #     "result_data" => response_data_String,
                                    #     "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                    #     "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                    #     "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                    #     "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #     "label" => result[1],
                                    #     "message" => "Function [ do_Function ] return " * result[1] * ".",
                                    #     "request_Arguments" => request_Arguments = Base.Dict{Core.String, Core.String}(
                                    #         "request_Data" => request_body,
                                    #         "request_Nikename" => request_Nikename,
                                    #         "request_Password" => request_Password,
                                    #         "time" => Base.string(now_date),
                                    #         "request_IP" => request_head["request_IP"],
                                    #         "request_Method" => request_head["request_Method"],
                                    #         "request_Path" => request_head["request_Url"],
                                    #         "request_Protocol" => request_head["request_Protocol"].
                                    #         "Authorization" => request_head["Authorization"],
                                    #         "Cookie" => request_head["Cookie"],
                                    #         "From" => request_head["From"],
                                    #         "User-Agent" => request_head["User-Agent"],
                                    #         "Host" => request_head["Host"],
                                    #         "Accept" => request_head["Accept"],
                                    #         "Accept-Language" => request_head["Accept-Language"],
                                    #         "Accept-Charset" => request_head["Accept-Charset"],
                                    #         "Date" => request_head["Date"]
                                    #     )
                                    # );

                                    if Base.isa(result_Dict, Base.Dict)

                                        # 記錄每個協程（Task）纍加的被調用運算的總次數;
                                        # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                        if Base.haskey(total_worker_called_number, Base.string(result_Dict["threadID"]))
                                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                        else
                                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                        end

                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "error"
                                            if Base.haskey(result_Dict, "taskID") && result_Dict["taskID"] !== Core.nothing && Base.isa(result_Dict["taskID"], Core.String) && result_Dict["taskID"] !== ""
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                end
                                            else
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task return error.");
                                                end
                                            end
    
                                            response_statusCode = Core.Int64(500);
                                            response_status_Message = statusMessage(response_statusCode);

                                            # Base.close(sock);  # 中斷當前的這個鏈接;
                                            # Base.sleep(time_sleep);
                                            # continue;
                                            # # break;
                                        end

                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "success"
                                            response_statusCode = Core.Int64(200);
                                            response_status_Message = statusMessage(response_statusCode);
                                        end

                                        response_data_String =  response_data_String * Base.string(result_Dict["result_data"]);
                                        # response_data_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                        # println(response_data_String);

                                        # log_text = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * Base.string(response_statusCode) * " .";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * Base.string(request_head["request_IP"]) * Base.string(request_head["request_Url"]) * Base.string(response_statusCode) * " .";
                                        # end
                                        # print(log_text * "\n");

                                        # response_data_String = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                        # Base.GC.gc();  # 内存回收函數 gc();

                                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        # println(Base.string(nowTime));
                                        # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # log_text::Core.String = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " >.";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " .";
                                        # end
                                        # print(log_text * "\n");
                                        # log_file = "";  # 日志文檔;
                                        # # 同步寫入用於記錄過程的日志文檔;
                                        # try
                                        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #     # # write(filename::AbstractString, x)
                                        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                        #     # println(numBytes);
                                        #     # println(Base.stat(log_file).size);
                                        #     # println(Base.stat(log_file).mtime);
                                        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #     # println(Base.stat(log_file).ctime);
                                        #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #     # # Base.countlines — Function
                                        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #     # println(Base.countlines(log_file, eol='\\n'));

                                        #     fWIO = Base.open(log_file, "a+");
                                        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                        #     # Keyword	Description				Default
                                        #     # read		open for reading		!write
                                        #     # write		open for writing		truncate | append
                                        #     # create	create if non-existent	!read & write | truncate | append
                                        #     # truncate	truncate to zero size	!read & write
                                        #     # append	seek to end				false

                                        #     # Mode	Description						Keywords
                                        #     # r		read							none
                                        #     # w		write, create, truncate			write = true
                                        #     # a		write, create, append			append = true
                                        #     # r+	read, write						read = true, write = true
                                        #     # w+	read, write, create, truncate	truncate = true, read = true
                                        #     # a+	read, write, create, append		append = true, read = true

                                        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                        #     if Base.iswritable(fWIO)
                                        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #         println(numBytes);
                                        #         println(Base.stat(log_file).size);
                                        #         println(Base.stat(log_file).mtime);
                                        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #         println(Base.stat(log_file).ctime);
                                        #         # Base.displaysize([io::IO]) -> (lines, columns)
                                        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #         # Base.countlines — Function
                                        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #         println(Base.countlines(log_file, eol='\\n'));
                                        #     end

                                        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                                        #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                                        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                        #     # Base.ismarked(io);  # Return true if stream s is marked;
                                        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                        #     # Base.close(io);  # 關閉緩衝區;
                                        #     # println(a)
                                        #     # Base.redirect_stdout — Function
                                        #     # redirect_stdout([stream]) -> (rd, wr)
                                        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                        #     # If called with the optional stream argument, then returns stream itself.
                                        #     # Base.redirect_stdout — Method
                                        #     # redirect_stdout(f::Function, stream)
                                        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                        #     # Base.redirect_stderr — Function
                                        #     # redirect_stderr([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stderr.
                                        #     # Base.redirect_stderr — Method
                                        #     # redirect_stderr(f::Function, stream)
                                        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                        #     # Base.redirect_stdin — Function
                                        #     # redirect_stdin([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                        #     # Base.redirect_stdin — Method
                                        #     # redirect_stdin(f::Function, stream)
                                        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                        # catch err
                                        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                        #     println(err);
                                        #     # println(Base.typeof(err));

                                        #     # Julia提供了許多類型的錯誤：
                                        #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                                        #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                                        #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                                        #     # DivideError：這是數字除以0時的結果。
                                        #     # DomainError：有效域之外的參數。
                                        #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                                        #     # InexactError：嘗試進行精確類型轉換失敗。
                                        #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                                        #     # LoadError：載入檔時發生錯誤。
                                        #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                                        #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                                        #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                                        #     # OverflowError：當操作結果太大時會發生這種情況。
                                        #     # ParseError：解析給定運算式時出現問題。
                                        #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                                        #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                                        #     # UndefRefError：未知引用。
                                        #     # UndefVarError：對不存在的變數進行未知引用。
                                        #     # InitError：調用模組的init方法時出現此錯誤。
                                        #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                                        #     # NullException：嘗試訪問Null值
                                        #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                                        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                        # finally
                                        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                        #     if Base.eof(fWIO)
                                        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                        #     end
                                        # end
                                    end

                                    # 使用 Base.isready(c::Channel) 函數判斷通道中元素是否已經取空，如果已經取空 Base.isready(c::Channel) 返回為 false 值，則跳出 for 循環，如果一個空通道從未寫入過元素，則 Base.isready(sub_to_main_channel) 值爲 true，因此會一直阻塞等待不會跳出循環;
                                    if !Base.isready(sub_to_main_channel)
                                        break;
                                    end
                                end
                                # response_data_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                # println(response_data_String);

                            catch err
                                
                                while Base.isreadable(sub_to_main_channel)
                                    Base.take!(sub_to_main_channel);
                                end
                                # for result_Dict in sub_to_main_channel
                                # end
                                # for i = 1:Base.length(sub_to_main_channel)
                                #     Base.take!(sub_to_main_channel);
                                # end

                                # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                                if Core.isa(err, Core.InterruptException)

                                    print("\n");
                                    # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                                    # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                                    println("[ Ctrl ] + [ c ] received, will be stop the TCP Server.");

                                    # # 打印進程被調用數目;
                                    # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                                    #     if isConcurrencyHierarchy === "Multi-Processes"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     end

                                    #     total_worker_called_number = Core.nothing;
                                    # end

                                    # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                                    # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                                    #     # Base.haskey(collection, key) -> Bool
                                    #     # for k in Base.keys(worker_queues_Dict)
                                    #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                                    #     # end

                                    #     worker_queues_Dict = Core.nothing;
                                    # end

                                    println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                                    # Base.exit(0);
                                    return ["", server, total_worker_called_number];

                                else

                                    # Base.write(stderr, err);
                                    # Base.write(Base.stdout, err, "\n");
                                    println("多綫程並發（multi-thread）時，工作綫程（worker-thread）中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                                    println(err);
                                    # println(err.msg);
                                    # println(Base.typeof(err));

                                    response_statusCode = Core.Int64(500);
                                    response_status_Message = statusMessage(response_statusCode);
                                    # response_data_String = "{\"Server_say\":\"" * "Server calculate data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;

                                    # Base.close(sock);  # 中斷當前的這個鏈接;
                                    # Base.sleep(time_sleep);
                                    # continue;
                                    # # break;
                                end
                            end
                        end

                        # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                        if isConcurrencyHierarchy === "Multi-Processes"

                            # 控制並發數;
                            # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                            Base.put!(control_number_Queues_channel, Core.UInt64(1));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                            worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                "arguments" => request_Dict,
                                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                "label" => "Run",
                                "message" => "Run"
                            );

                            # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                            # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                            Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                            # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                            #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                            # end

                            try
                                # # 子進程 2 運行輪詢 funcTask 函數;
                                # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                # # Distributed.@spawnat p expr
                                # function func_wp2(
                                #     funcTask,
                                #     # worker_data_Dict::Base.Dict{Core.String, Core.Any},
                                #     do_Function,
                                #     main_to_sub_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
                                #     sub_to_main_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
                                #     control_number_Queues_channel::Base.Channel{Core.UInt64}
                                # )
                                # # wp2 = Distributed.@spawnat 2 begin

                                #     function func_Exit()
                                #         # Base.close(sub_to_main_channel);
                                #         # Base.exit(0);
                                #     end
                                #     Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

                                #     funcTask(
                                #         # worker_data_Dict,
                                #         do_Function,
                                #         main_to_sub_channel,
                                #         sub_to_main_channel,
                                #         control_number_Queues_channel
                                #     );
                                # end
                                # # Distributed.remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future;
                                # wp2 = Distributed.remotecall(
                                #     func_wp2,
                                #     2,
                                #     funcTask,
                                #     # worker_data_Dict,
                                #     do_Function,
                                #     main_to_sub_channel,
                                #     sub_to_main_channel,
                                #     control_number_Queues_channel
                                # );
                                # r2 = Base.fetch(wp2);

                                # Base.Threads.@spawn
                                # Create and run a Task on any available thread. To wait for the task to finish, call wait on the result of this macro, or call fetch to wait and then obtain its return value.
                                # Values can be interpolated into @spawn via $, which copies the value directly into the constructed underlying closure. This allows you to insert the value of a variable, isolating the asynchronous code from changes to the variable's value in the current task.
                                # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                wp = Base.Threads.@spawn funcTask(
                                    # worker_data_Dict,
                                    do_Function,
                                    main_to_sub_channel,
                                    sub_to_main_channel,
                                    control_number_Queues_channel
                                );
                                # r = Base.fetch(wp);


                                # 讀出輸出通道中子協程(task)返回的結果;
                                # Base.take!(sub_to_main_channel);
                                # 這裏 for 結構本質上是一串自動執行的從通道中取出元素 take!() 的操作，和 take!() 操作一樣會移除元素。當通道 Channel 中元素取為空時，for 結構會阻塞;
                                # 使用 close(channelname) 强制關閉通道 Channel 的入口並釋放所有 put!() 和 take!() 的阻塞，此時 for 循環取完通道 Channel 中元素為空時，將不再阻塞會自行退出;
                                for result_Dict in sub_to_main_channel

                                    # result_Dict = Base.Dict{Core.String, Core.Any}(
                                    #     # "do_Function" => do_Function,  # worker_Data_Dict["do_Function"]， # do_data ;
                                    #     "result_data" => response_data_String,
                                    #     "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                    #     "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                    #     "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                    #     "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #     "label" => result[1],
                                    #     "message" => "Function [ do_Function ] return " * result[1] * ".",
                                    #     "request_Arguments" => request_Arguments = Base.Dict{Core.String, Core.String}(
                                    #         "request_Data" => request_body,
                                    #         "request_Nikename" => request_Nikename,
                                    #         "request_Password" => request_Password,
                                    #         "time" => Base.string(now_date),
                                    #         "request_IP" => request_head["request_IP"],
                                    #         "request_Method" => request_head["request_Method"],
                                    #         "request_Path" => request_head["request_Url"],
                                    #         "request_Protocol" => request_head["request_Protocol"].
                                    #         "Authorization" => request_head["Authorization"],
                                    #         "Cookie" => request_head["Cookie"],
                                    #         "From" => request_head["From"],
                                    #         "User-Agent" => request_head["User-Agent"],
                                    #         "Host" => request_head["Host"],
                                    #         "Accept" => request_head["Accept"],
                                    #         "Accept-Language" => request_head["Accept-Language"],
                                    #         "Accept-Charset" => request_head["Accept-Charset"],
                                    #         "Date" => request_head["Date"]
                                    #     )
                                    # );

                                    if Base.isa(result_Dict, Base.Dict)

                                        # 記錄每個協程（Task）纍加的被調用運算的總次數;
                                        # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                        if Base.haskey(total_worker_called_number, Base.string(result_Dict["processID"]))
                                            # global total_worker_called_number[Base.string(result_Dict["processID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["processID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                            total_worker_called_number[Base.string(result_Dict["processID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["processID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                        else
                                            # global total_worker_called_number[Base.string(result_Dict["processID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                            total_worker_called_number[Base.string(result_Dict["processID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                        end

                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "error"
                                            if Base.haskey(result_Dict, "taskID") && result_Dict["taskID"] !== Core.nothing && Base.isa(result_Dict["taskID"], Core.String) && result_Dict["taskID"] !== ""
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                end
                                            else
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task return error.");
                                                end
                                            end

                                            response_statusCode = Core.Int64(500);
                                            response_status_Message = statusMessage(response_statusCode);

                                            # Base.close(sock);  # 中斷當前的這個鏈接;
                                            # Base.sleep(time_sleep);
                                            # continue;
                                            # # break;
                                        end

                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "success"
                                            response_statusCode = Core.Int64(200);
                                            response_status_Message = statusMessage(response_statusCode);
                                        end

                                        response_data_String =  response_data_String * Base.string(result_Dict["result_data"]);
                                        # response_data_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                        # println(response_data_String);

                                        # log_text = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * Base.string(response_statusCode) * " .";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * Base.string(request_head["request_IP"]) * Base.string(request_head["request_Url"]) * Base.string(response_statusCode) * " .";
                                        # end
                                        # print(log_text * "\n");

                                        # response_data_String = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                        # Base.GC.gc();  # 内存回收函數 gc();

                                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        # println(Base.string(nowTime));
                                        # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # log_text::Core.String = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " >.";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " .";
                                        # end
                                        # print(log_text * "\n");
                                        # log_file = "";  # 日志文檔;
                                        # # 同步寫入用於記錄過程的日志文檔;
                                        # try
                                        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #     # # write(filename::AbstractString, x)
                                        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                        #     # println(numBytes);
                                        #     # println(Base.stat(log_file).size);
                                        #     # println(Base.stat(log_file).mtime);
                                        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #     # println(Base.stat(log_file).ctime);
                                        #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #     # # Base.countlines — Function
                                        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #     # println(Base.countlines(log_file, eol='\\n'));

                                        #     fWIO = Base.open(log_file, "a+");
                                        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                        #     # Keyword	Description				Default
                                        #     # read		open for reading		!write
                                        #     # write		open for writing		truncate | append
                                        #     # create	create if non-existent	!read & write | truncate | append
                                        #     # truncate	truncate to zero size	!read & write
                                        #     # append	seek to end				false

                                        #     # Mode	Description						Keywords
                                        #     # r		read							none
                                        #     # w		write, create, truncate			write = true
                                        #     # a		write, create, append			append = true
                                        #     # r+	read, write						read = true, write = true
                                        #     # w+	read, write, create, truncate	truncate = true, read = true
                                        #     # a+	read, write, create, append		append = true, read = true

                                        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                        #     if Base.iswritable(fWIO)
                                        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #         println(numBytes);
                                        #         println(Base.stat(log_file).size);
                                        #         println(Base.stat(log_file).mtime);
                                        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #         println(Base.stat(log_file).ctime);
                                        #         # Base.displaysize([io::IO]) -> (lines, columns)
                                        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #         # Base.countlines — Function
                                        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #         println(Base.countlines(log_file, eol='\\n'));
                                        #     end

                                        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（IOBuffer）;
                                        #     # io = Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（IOBuffer）;
                                        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                        #     # Base.ismarked(io);  # Return true if stream s is marked;
                                        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                        #     # Base.close(io);  # 關閉緩衝區;
                                        #     # println(a)
                                        #     # Base.redirect_stdout — Function
                                        #     # redirect_stdout([stream]) -> (rd, wr)
                                        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                        #     # If called with the optional stream argument, then returns stream itself.
                                        #     # Base.redirect_stdout — Method
                                        #     # redirect_stdout(f::Function, stream)
                                        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                        #     # Base.redirect_stderr — Function
                                        #     # redirect_stderr([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stderr.
                                        #     # Base.redirect_stderr — Method
                                        #     # redirect_stderr(f::Function, stream)
                                        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                        #     # Base.redirect_stdin — Function
                                        #     # redirect_stdin([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                        #     # Base.redirect_stdin — Method
                                        #     # redirect_stdin(f::Function, stream)
                                        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                        # catch err
                                        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                        #     println(err);
                                        #     # println(Base.typeof(err));

                                        #     # Julia提供了許多類型的錯誤：
                                        #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                                        #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                                        #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                                        #     # DivideError：這是數字除以0時的結果。
                                        #     # DomainError：有效域之外的參數。
                                        #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                                        #     # InexactError：嘗試進行精確類型轉換失敗。
                                        #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                                        #     # LoadError：載入檔時發生錯誤。
                                        #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                                        #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                                        #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                                        #     # OverflowError：當操作結果太大時會發生這種情況。
                                        #     # ParseError：解析給定運算式時出現問題。
                                        #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                                        #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                                        #     # UndefRefError：未知引用。
                                        #     # UndefVarError：對不存在的變數進行未知引用。
                                        #     # InitError：調用模組的init方法時出現此錯誤。
                                        #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                                        #     # NullException：嘗試訪問Null值
                                        #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                                        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                        # finally
                                        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                        #     if Base.eof(fWIO)
                                        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                        #     end
                                        # end
                                    end

                                    # 使用 Base.isready(c::Channel) 函數判斷通道中元素是否已經取空，如果已經取空 Base.isready(c::Channel) 返回為 false 值，則跳出 for 循環，如果一個空通道從未寫入過元素，則 Base.isready(sub_to_main_channel) 值爲 true，因此會一直阻塞等待不會跳出循環;
                                    if !Base.isready(sub_to_main_channel)
                                        break;
                                    end
                                end
                                # response_data_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                # println(response_data_String);

                            catch err

                                while Base.isreadable(sub_to_main_channel)
                                    Base.take!(sub_to_main_channel);
                                end
                                # for result_Dict in sub_to_main_channel
                                # end
                                # for i = 1:Base.length(sub_to_main_channel)
                                #     Base.take!(sub_to_main_channel);
                                # end

                                # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                                if Core.isa(err, Core.InterruptException)

                                    print("\n");
                                    # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                                    # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                                    println("[ Ctrl ] + [ c ] received, will be stop the TCP Server.");

                                    # # 打印進程被調用數目;
                                    # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                                    #     if isConcurrencyHierarchy === "Multi-Processes"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     end

                                    #     total_worker_called_number = Core.nothing;
                                    # end

                                    # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                                    # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                                    #     # Base.haskey(collection, key) -> Bool
                                    #     # for k in Base.keys(worker_queues_Dict)
                                    #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                                    #     # end

                                    #     worker_queues_Dict = Core.nothing;
                                    # end

                                    println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                                    # Base.exit(0);
                                    return ["", server, total_worker_called_number];

                                else

                                    # Base.write(stderr, err);
                                    # Base.write(Base.stdout, err, "\n");
                                    println("多協程並發 ( multi-task ) 時，工作協程 ( worker task ) 中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                                    println(err);
                                    # println(err.msg);
                                    # println(Base.typeof(err));

                                    response_statusCode = Core.Int64(500);
                                    response_status_Message = statusMessage(response_statusCode);
                                    # response_data_String = "{\"Server_say\":\"" * "Server calculate data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;

                                    # Base.close(sock);  # 中斷當前的這個鏈接;
                                    # Base.sleep(time_sleep);
                                    # continue;
                                    # # break;
                                end
                            end
                        end
                    end
                else
                    response_statusCode = Core.Int64(500);
                    response_status_Message = statusMessage(response_statusCode);

                    response_data_String = request_body;
                    # response_data_String = "{\"Server_say\":\"" * "Server calculate data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                    # println(response_data_String);
                end
            end

            response_Body_String_len = Base.sizeof(response_data_String);

            response_String = Base.string(
                "HTTP/1.1" * " " * Base.string(response_statusCode) * " " * Base.string(response_status_Message) * "\r\n",  # "HTTP/1.1 401 Unauthorized\r\n"，401 表示用戶沒有訪問權限 Unauthorized;
                "Content-Type:" * response_Content_Type * "\r\n",  # "text/html, text/plain; charset=utf-8" 響應數據類型;
                "Content-Length:" * Base.string(response_Body_String_len) * "\r\n",  # 設置響應體數據長度 response_Body_String_len = Buffer.byteLength(post_Data_String, "utf8");
                "Set-Cookie:" * response_Cookie_string * "\r\n",  # 設置 Set-Cookie = "Session_ID=request_Key->username:password; expires=2021-06-28T12:12:50.544; path=/" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk; expires=2021-06-28T12:12:50.544; path=/";
                "Www-Authenticate:" * "Basic realm=\"domain name -> " * Base.string(key) * "\"" * "\r\n",  # 告訴客戶端應該在請求頭Authorization中提供什麽類型的身份驗證信息 Www-Authenticate = "Basic realm=\"domain name -> username:password\"" -> "Basic realm=\"domain name -> dXNlcm5hbWU6cGFzc3dvcmQ=\"";
                "Content-Language:" * "zh-Hant-TW; q=0.8, zh-Hant; q=0.7, zh-Hans-CN; q=0.7, zh-Hans; q=0.5, en-US, en; q=0.3" * "\r\n",  # 服務器發送響應的自然語言類型;
                # "Content-Disposition:" * "attachment; filename=Test.zip" * "\r\n",  # 服務端要求客戶端以下載文檔的方式打開該文檔;
                # "Transfer-Encoding:" * "chunked" * "\r\n",  # 以數據流形式分塊發送響應數據到客戶端;
                # "Expires:" * "100-continue header" * "\r\n",  # 服務端禁止客戶端緩存頁面數據;
                # "Cache-Control:" * "no-cache" * "\r\n",  # 'max-age=0' 或 no-store, must-revalidate 設置不允許瀏覽器緩存，必須刷新數據;
                # "Pragma:" * "no-cache" * "\r\n",  # 服務端禁止客戶端緩存頁面數據;
                "Date:" * Base.string(now_date) * "\r\n",  # 服務端向客戶端返回響應的時間 2021-06-28T12:12:50.544;
                # "Access-Control-Allow-Methods:" * "GET, POST, HEAD, PATCH" * "\r\n",  # 設置響應頭，但是并不發送響應頭;
                # "Access-Control-Allow-Origin:" * "*" * "\r\n",  # 設置響應頭，但是并不發送響應頭;
                # "Access-Control-Allow-Headers:" * "content-type, Accept" * "\r\n",  # 設置響應頭，但是并不發送響應頭;
                # "Access-Control-Allow-Credentials:" * "true" * "\r\n",  # 設置響應頭，但是并不發送響應頭;
                "Connection:" * "close" * "\r\n",  # 'keep-alive' 維持客戶端和服務端的鏈接關係，當一個網頁打開完成後，客戶端和服務器之間用於傳輸 HTTP 數據的 TCP 鏈接不會關閉，如果客戶端再次訪問這個服務器上的網頁，會繼續使用這一條已經建立的鏈接;
                "Server:" * Base.string(server_info) * "\r\n\r\n",  # web 服務器名稱版本信息 "Julia-1.6.2 Sockets.listen.";
                response_data_String
            );

            # 如果客戶端鏈接正常，則由服務器端向客戶端發送響應數據;
            if Base.iswritable(sock)
                try
                    # Base.write(Base.stdout, response_String);
                    Base.write(sock, response_String);  # 向客戶端發送響應值;
                catch err
                    # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                    if Core.isa(err, Core.InterruptException)

                        print("\n");
                        # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                        # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                        println("[ Ctrl ] + [ c ] received, will be stop the TCP server.");

                        # # 打印進程被調用數目;
                        # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                        #     if isConcurrencyHierarchy === "Multi-Processes"

                        #         # Base.haskey(collection, key) -> Bool
                        #         # workNum = "worker";
                        #         for k in Base.keys(total_worker_called_number)
                        #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                        #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                        #         end
                        #         # println(workNum);

                        #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                        #         # Base.haskey(collection, key) -> Bool
                        #         # workNum = "worker";
                        #         for k in Base.keys(total_worker_called_number)
                        #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                        #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                        #         end
                        #         # println(workNum);

                        #     end

                        #     total_worker_called_number = Core.nothing;
                        # end

                        # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                        # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                        #     # Base.haskey(collection, key) -> Bool
                        #     # for k in Base.keys(worker_queues_Dict)
                        #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                        #     # end

                        #     worker_queues_Dict = Core.nothing;
                        # end

                        println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                        println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                        # Base.exit(0);
                        return ["", server, total_worker_called_number];

                    else

                        # Base.write(stderr, err);
                        # Base.write(Base.stdout, err, "\n");
                        println(err);
                        Base.close(sock);  # 中斷當前的這個鏈接;
                        Base.sleep(time_sleep);
                        continue;
                        # break;
                    end
                end
            end

            # log_text::Core.String = Base.string(now_date) * " " * Base.string(request_head["request_IP"]) * " " * Base.string(request_head["request_Url"]) * " " * Base.string(response_statusCode) * " .";
            log_text::Core.String = "";
            log_text = log_text * Base.string(now_date);
            if Base.haskey(request_head, "request_IP")
                log_text = log_text * " " * Base.string(request_head["request_IP"]);
            end
            if Base.haskey(request_head, "request_Url")
                log_text = log_text * " " * Base.string(request_head["request_Url"]);
            end
            log_text = log_text * " " * Base.string(response_statusCode) * " .";
            print(log_text * "\n");

            Base.close(sock);  # 中斷當前的這個鏈接;
            Base.sleep(time_sleep);
        end
    end

    return ["", server, total_worker_called_number];
end


function TCP_Server_Run(;
    host::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv6(0),  # "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
    port::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String} = Core.UInt8(5000),  # 0 ~ 65535，監聽埠號（端口）;
    do_Function = (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Request";
    key::Core.String = ":",  # "username:password",  # 自定義的訪問網站簡單驗證用戶名和密碼;
    session::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => TCP_Server_Run.key),  # 保存網站的 Session 數據;
    number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Base.Sys.CPU_THREADS,  # Core.UInt8(1)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
    time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
    isConcurrencyHierarchy::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
    # worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
    # total_worker_called_number::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
    TCP_Server = TCP_Server
) ::Core.Array{Core.Any, 1}

    # # print("當前協程 task: ", Base.current_task(), "\n");
    # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
    # print("當前綫程 thread 的 ID: ", Base.Threads.threadid(), "\n");
    # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
    # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
    # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
    # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
    # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
    # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
    # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
    # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
    # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
    # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
    # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
    # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
    # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

    # println(Base.Sys.CPU_THREADS)  # 4 可用 CPU 數;
    # println(Base.Filesystem.ispath(Base.Filesystem.pwd()))  # true 判斷目錄是否存在;
    # println(Base.Sys.BINDIR)  # C:\Program Files\Julia 1.5.1\bin;
    # println(Base.PROGRAM_FILE)  # c:\Users\china\Documents\Node.js\Criss\jl\tempCodeRunnerFile.jl;
    # println(Base.Filesystem.basename(Base.Filesystem.pwd()))  # Criss;
    # # "File_Directory_and_Path";
    # println(Base.Filesystem.homedir())  # C:\Users\china;
    # println(Base.Filesystem.pwd())  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath("."))  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js\Criss;
    # # 获取路径的目录;
    # println(Base.Filesystem.dirname(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js;
    # # "/Users/juliauser/Functions_Scripts_Codes_Pipelines/Julia_Codes";
    # # 路径的末端分割;
    # println(Base.Filesystem.splitdir(Base.Filesystem.pwd()));
    # # ("c:\\Users\\china\\Documents\\Node.js", "Criss");
    # # 路径的合成;
    # println(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "temp", "intermediary_write_NodeJS.txt"));  # c:\Users\china\Documents\Node.js\temp\intermediary_write_NodeJS.txt;
    # # Base.Filesystem.cd()  # 更換工作目錄;
    # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl"))
    # # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl").mode) # 返回值為 Core.UInt64 類型數值，例如 Core.UInt64(33206);

    # 自定義一個在進程退出前一刻調用的函數 f()，使用 Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并注冊為在對象終結的前一刻運行;
    function func_Exit()

        # if isMonitorThreadsOrProcesses === "Multi-Processes" || isMonitorThreadsOrProcesses === "Multi-Threading"

        #     RemoteChannel_Data_Dict = Base.Dict{Core.String, Core.Any}(
        #         # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
        #         "monitor_file" => monitor_file,
        #         "monitor_dir" => monitor_dir,
        #         # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
        #         "output_dir" => output_dir,
        #         "output_file" => output_file,
        #         "temp_cache_IO_data_dir" => temp_cache_IO_data_dir,
        #         "to_executable" => to_executable,
        #         "to_script" => to_script,
        #         "input_queues_array" => input_queues_array,
        #         "output_queues_array" => output_queues_array,
        #         "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
        #         "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
        #         "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
        #         "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
        #         "label" => "exit",
        #         "message" => "exit worker process."
        #     );

        #     if Base.isopen(rc2to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_file() > worker process-2 be exit.";
        #         Base.put!(rc2to, RemoteChannel_Data_Dict);
        #         Base.close(rc2to);
        #     end

        #     if Base.isopen(rc3to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_input_queues() > worker process-3 be exit.";
        #         Base.put!(rc3to, RemoteChannel_Data_Dict);
        #         Base.close(rc3to);
        #     end

        #     if Base.isopen(rc4to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_output_queues() > worker process-4 be exit.";
        #         Base.put!(rc4to, RemoteChannel_Data_Dict);
        #         Base.close(rc4to);
        #     end

        #     RemoteChannel_Data_Dict = Core.nothing;

        #     if Base.isready(rc2from)
        #         # from2rcDict = Base.take!(rc2from);
        #         for from2rcDict in rc2from
        #             # input_queues_array = from2rcDict["input_queues_array"];
        #             # output_queues_array = from2rcDict["output_queues_array"];
        #             if from2rcDict["label"] === "exit"
        #                 println(from2rcDict["message"]);
        #             end
        #         end
        #         # from2rcDict = Core.nothing;
        #     end

        #     if Base.isready(rc3from)
        #         # from3rcDict = Base.take!(rc3from);
        #         for from3rcDict in rc3from
        #             # input_queues_array = from3rcDict["input_queues_array"];
        #             # output_queues_array = from3rcDict["output_queues_array"];
        #             if from3rcDict["label"] === "exit"
        #                 println(from3rcDict["message"]);
        #             end
        #         end
        #         # from3rcDict = Core.nothing;
        #     end

        #     if Base.isready(rc4from)
        #         # from4rcDict = Base.take!(rc4from);
        #         for from4rcDict in rc4from
        #             # input_queues_array = from4rcDict["input_queues_array"];
        #             # output_queues_array = from4rcDict["output_queues_array"];
        #             if from4rcDict["label"] === "exit"
        #                 println(from4rcDict["message"]);
        #             end
        #         end
        #         # from4rcDict = Core.nothing;
        #     end
        # end
    end
    Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

    # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.Task}()，保存每個創建的子進程的字典;
    # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
    total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
    resultArray = Core.Array{Core.Any, 1}();  # ::Core.Array{Core.Any, 1} = ["", "", ""];

    # 監聽 'SIGINT' 信號，當 Julia 進程接收到 'SIGINT' 信號時，會觸發該事件;
    # 'SIGHUP' 信號在 Windows 平臺上當控制臺使用鍵盤輸入 [ Ctrl ] + [ c ] 窗口被關閉時會被觸發，在其它平臺上在相似的條件下也會被觸發;
    # 修改 Julia 解釋器 jl_exit_on_sigint 模組的變量 Cint 的值為 0（預設值為 1），使在執行代碼脚本文檔的時候，接收到鍵盤 Ctrl + c 信號，抛出 Core.UndefVarError 錯誤;
    # 預設的只有在控制臺交互的時候，解釋器 jl_exit_on_sigint 模組的變量 Cint 的值預設值為 0，在接收到鍵盤 Ctrl + c 信號時，會抛出 Core.UndefVarError 錯誤；
    # 但是在執行代碼脚本文檔的時候，解釋器 jl_exit_on_sigint 模組的變量 Cint 的值預設值為 1，，在接收到鍵盤 Ctrl + c 信號時，并不會抛出 Core.UndefVarError 錯誤；
    ccall(:jl_exit_on_sigint, Cvoid, (Cint,), 0);  # 修改 Julia 解釋器 jl_exit_on_sigint 模組的變量 Cint 的值為 0（預設值為 1），使在執行代碼脚本文檔的時候，接收到鍵盤 Ctrl + c 信號，抛出 Core.UndefVarError 錯誤;
    try
        println("進程: process-" * Base.string(Distributed.myid()) * " , 執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在監聽主機「 " * Base.string(host) * " 」埠號「 " * Base.string(port) * " 」 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        if Core.isa(host, Sockets.IPv6)
            println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on Host -> http://[" * Base.string(host) * "]:" * Base.string(port) * "/ ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # elseif Base.string(host) === "::0" || Base.string(host) === "::1" || Base.string(host) === "::" || Base.string(host) === "0" || Base.string(host) === "1" || CheckIP(Base.string(host)) === "IPv6"
        #     println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on Host -> http://[" * Base.string(host) * "]:" * Base.string(port) * "/ ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        elseif Core.isa(host, Sockets.IPv4)
            println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on Host -> http://" * Base.string(host) * ":" * Base.string(port) * "/ ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # elseif Base.string(host) === "0.0.0.0" || Base.string(host) === "127.0.0.1" || CheckIP(Base.string(host)) === "IPv4"
        #     println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on Host -> http://" * Base.string(host) * ":" * Base.string(port) * "/ ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # elseif Base.string(host) === "localhost"
        #     println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on Host -> http://" * Base.string(host) * ":" * Base.string(port) * "/ ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        else
            println("Error: host IP [ " * Base.string(host) * " ] unrecognized.");
            # return false
        end
        if Core.isa(key, Core.String) && key !== ""
            Key_username::Core.String = "";  # "username";
            Key_password::Core.String = "";  # "password";
            if Base.occursin(":", key)
                Key_username = Base.convert(Core.String, Base.split(key, ':')[1]);  # "username";
                Key_password = Base.convert(Core.String, Base.split(key, ':')[2]);  # "password";
            else
                Key_username = Base.string(key);  # "username";
            end
            if Key_username !== "" && Key_password !== ""
                println("Client key = [ " * Key_username * " ]" * " : " * "[ " * Key_password * " ].");
                println("Client connection password Request Head Authorization = [ \"" * Base.string(key) * "\" ].");
            elseif Key_username !== "" && Key_password === ""
                println("Client key = " * Key_username);
            elseif Key_username === "" && Key_password !== ""
                println("Client key = :" * Key_password);
            end
        end
        println("Import data interface JSON String: {\"Client_say\":\"這裏是需要傳入的數據字符串 this is import string data\"}.");
        println("Export data interface JSON String: {\"Server_say\":\"這裏是處理後傳出的數據字符串 this is export string data\"}.");
        println("Keyboard Enter [ Ctrl ] + [ c ] to close.");
        println("鍵盤輸入 [ Ctrl ] + [ c ] 中止運行.");
        print("\n");

        # resultArray::Core.Array{Core.Any, 1} = ["", "", total_worker_called_number];
        result = TCP_Server(
            host,  # "0.0.0.0" or "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
            port;  # 0 ~ 65535，監聽埠號（端口）;
            do_Function = do_Function,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Request";
            key = key,  # ::Core.String = "username:password",  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
            session = session,  # ::Base.Dict{Core.String, Core.Any}("request_Key->username:password" => Key),  # 保存網站的 Session 數據;
            number_Worker_threads = number_Worker_threads,  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Base.Sys.CPU_THREADS,  # Core.UInt8(0)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
            time_sleep = time_sleep,  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
            isConcurrencyHierarchy = isConcurrencyHierarchy,  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
            # worker_queues_Dict = worker_queues_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
            total_worker_called_number = total_worker_called_number  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
        );

        if Base.typeof(result) <: Core.Array
            # && Base.length(result) >= 3

            # resultArray::Core.Array{Core.Any, 1} = ["", "", total_worker_called_number];
            resultArray = result;
            # resultArray[1] = result[1];
            # resultArray[2] = result[2];
            # resultArray[3] = result[3];
            # println(typeof(resultArray));
            # println(resultArray[1]);
            # println(resultArray[2]);
            # println(resultArray[3]);
        elseif Base.@isdefined(result)
            resultArray = ["error", result, total_worker_called_number];
        else
            resultArray = ["error", "", total_worker_called_number];
        end

    catch myException
        # println(Base.typeof(myException));
        # println(myException);
        # println(myException.msg);
        # 使用 Core.isa(myException, Core.InterruptException) 函數判斷 myException 的類型是否爲 Core.InterruptException;
        if Core.isa(myException, Core.InterruptException)

            print("\n");
            # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
            # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
            println("[ Ctrl ] + [ c ] received, will be stop the TCP Server.");

            # 打印進程被調用數目;
            if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                # if isConcurrencyHierarchy === "Multi-Processes"

                #     # Base.haskey(collection, key) -> Bool
                #     # workNum = "worker";
                #     for k in Base.keys(total_worker_called_number)
                #         println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                #         # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                #     end
                #     # println(workNum);

                # elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                #     # Base.haskey(collection, key) -> Bool
                #     # workNum = "worker";
                #     for k in Base.keys(total_worker_called_number)
                #         println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                #         # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                #     end
                #     # println(workNum);

                # end

                total_worker_called_number = Core.nothing;
            end

            # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
            # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

            #     # Base.haskey(collection, key) -> Bool
            #     # for k in Base.keys(worker_queues_Dict)
            #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
            #     # end

            #     worker_queues_Dict = Core.nothing;
            # end

            println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

            # Base.exit(0);
            return resultArray;
        else
            println(myException);
        end
    end

    # Base.exit(0);
    # return resultArray;
end


# # 函數使用示例;
# # 控制臺命令行使用:
# # C:\>C:\Criss\Julia\Julia-1.6.2\bin\julia.exe -p 4 --project=C:/Criss/jl/ C:/Criss/jl/src/Interface.jl
# # 啓動運行;
# # 參數 -p 4 表示設定允許 4 個進程并發;
# # 參數 --project=C:/Criss/jl/ 表示隔離全局環境，只是用項目私人環境 C:/Criss/jl/ 啓動 Julia 解釋器;
# # 媒介服務器函數服務端（後端） TCP_Server() 使用説明;
# webPath = Base.string(Base.Filesystem.joinpath(Base.string(Base.Filesystem.abspath(".")), "html"));  # 服務器運行的本地硬盤根目錄，可以使用函數：上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__;
# # webPath = Base.string(Base.Filesystem.abspath("."));  # 服務器運行的本地硬盤根目錄，可以使用函數：上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__;
# host = Sockets.IPv6(0);  # "::1";  # "127.0.0.1",  # "0.0.0.0" or "localhost"; 監聽主機域名 Host domain name;
# port = Core.UInt64(10001);  # ::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String} = Core.UInt8(8000),  # 0 ~ 65535， 監聽埠號（端口）;
# key = "username:password";  # ::Core.String = "username:password",  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
# session = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => key);  # 保存網站的 Session 數據;
# do_Function = do_Request;  # (argument) -> begin argument; end; 匿名函數對象，用於接收執行對根目錄(/)的 POST 請求處理功能的函數 "do_POST_root_directory";
# number_Worker_threads = Core.UInt8(Base.Sys.CPU_THREADS);  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Base.Sys.CPU_THREADS,  # Core.UInt8(0)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
# time_sleep = Core.Float16(0);  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
# isConcurrencyHierarchy = "Tasks";  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
# # print("isConcurrencyHierarchy: ", isConcurrencyHierarchy, "\n");
# # 當 isConcurrencyHierarchy = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
# # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
# # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
# # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
# # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;
# TCP_Server = TCP_Server;
# # worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
# # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;

# # a = Array{Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}(Core.nothing, 3);
# a = TCP_Server_Run(
#     host = host,  # ::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv6(0),  # "::1";  # "127.0.0.1",  # "0.0.0.0" or "localhost"; 監聽主機域名 Host domain name;
#     port = port,  # ::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String} = 8000, # 0 ~ 65535， 監聽埠號（端口）;
#     do_Function = do_Function,  # do_Request,  # (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Request_root_directory";
#     key = key,  # ::Core.String = "username:password",  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
#     session = session,  # ::Base.Dict{Core.String, Core.Any}("request_Key->username:password" => Key),  # 保存網站的 Session 數據;
#     number_Worker_threads = number_Worker_threads,  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Base.Sys.CPU_THREADS,  # Core.UInt8(0)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
#     time_sleep = time_sleep,  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
#     isConcurrencyHierarchy = isConcurrencyHierarchy,  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
#     # worker_queues_Dict = worker_queues_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
#     # total_worker_called_number = total_worker_called_number,  # Base.Dict{Core.String, Core.UInt64}();  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
#     TCP_Server = TCP_Server
# );
# # println(typeof(a))
# # println(a[1])
# # println(a[2])
# # println(a[3])





# # 示例函數，處理從服務器端返回的響應信息;
# function do_Response(response_Dict::Core.Union{Core.String, Base.Dict})::Core.Union{Core.String, Base.Dict}
#     println(response_Dict);

#     if Base.length(request_Dict) > 0
#         # Base.isa(request_Dict, Base.Dict)

#         if Base.haskey(request_Dict, "request_IP")
#         end
#         if Base.haskey(request_Dict, "request_Path")
#         end
#         if Base.haskey(request_Dict, "request_Method")
#         end
#     end

#     request_data_Dict = Base.Dict{Core.String, Core.Any}();  # 函數返回值，聲明一個空字典;
#     request_data_Dict = request_Dict;
#     request_form_value::Core.String = request_data_Dict["request_Data"];  # 函數接收到的參數值;

#     response_data_Dict = Base.Dict{Core.String, Core.Any}();  # 函數返回值，聲明一個空字典;
#     response_data_String::Core.String = "";

#     # # require_data_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Int64}()聲明一個空字典並指定數據類型;
#     # require_data_Dict = Base.Dict();  # 聲明一個空字典，函數接收到的參數;
#     # # 使用自定義函數isStringJSON(request_form_value)判斷讀取到的請求體表單"form"數據 request_form_value 是否為JSON格式的字符串;
#     # if isStringJSON(request_form_value)
#     #     require_data_Dict = JSONstring(request_form_value);  # 使用自定義的 JSONstring() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
#     #     # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象;
#     #     # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
#     # else
#     #     require_data_Dict["Client_say"] = data_Str;  # Base.Dict(data_Str);  # Base.Dict("aa" => 1, "bb" => 2, "cc" => 3);
#     # end

#     return_file_creat_time = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
#     # println(Base.string(Dates.now()))

#     response_data_Dict["Julia_say"] = Base.string(request_form_value);  # Base.Dict("Julia_say" => Base.string(request_form_value));
#     response_data_Dict["time"] = Base.string(return_file_creat_time);  # Base.Dict("Julia_say" => Base.string(request_form_value), "time" => string(return_file_creat_time));
#     # println(response_data_Dict);

#     # response_data_String = JSONstring(response_data_Dict);  # 使用自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
#     # # response_data_String = JSON.json(response_data_Dict);  # 使用第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
#     response_data_String = "{\"Julia_say\":\"" * Base.string(request_form_value) * "\",\"time\":\"" * Base.string(return_file_creat_time) * "\"}";  # 使用星號*拼接字符串;
#     # println(response_data_String);

#     return response_data_String;
# end


# # TCP Client 「Sockets.Sockets.connect」;
# host::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv6(0);  # "::0" or "::1" or "0.0.0.0" or "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
# IPVersion = "IPv6";  # "IPv6"、"IPv4";
# port = "10001";  # ::Core.Union{Core.String, Core.UInt8} = "10001";  # Core.UInt8(5000),  # 0 ~ 65535， 監聽埠號（端口）;
# Authorization = "";  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
# postData = Core.nothing;  # Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.String}("request_Key->username:password" => key); 自定義 session 值，Base.Dict 對象;
# URL = "";  # "http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1;
# requestPath = "";
# requestMethod = "";  # "POST",  # "GET"; # 請求方法;
# requestProtocol = "";
# # time_out = Core.Float16(0);  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
# Cookie = "";  # "Session_ID=request_Key->username:password"，將漢字做Base64轉碼Base64.base64encode()，需要事先加載原生的 Base64 模組：using Base64 模組;
# # println(Core.String(Base64.base64decode(Cookie_value)));
# # println("Request Cook: ", Cookie);
# requestFrom = "";  # "user@email.com";
# number_Worker_threads = "";  # Core.UInt8(1)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
# time_sleep = "";  # Core.Float64(0.02)，監聽文檔輪詢時使用 Base.sleep(time_sleep) 函數延遲時長，單位秒，自定義函數檢查輸入合規性 CheckString(delay, 'positive_integer');
# readtimeout::Core.Int = Core.Int(0);  # 服務器響應數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
# connect_timeout::Core.Int = Core.Int(0);  # 服務器鏈接超時，單位：（秒），close the connection after this many seconds if it is still attempting to connect. Use to disable.connect_timeout = 0;
# do_Function = Core.nothing;  # (argument) -> begin argument; end; 匿名函數對象，用於接收執行對根目錄(/)的 POST 請求處理功能的函數 "do_POST_root_directory";
# isConcurrencyHierarchy = "";  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;

# # 控制臺傳參，通過 Base.ARGS 數組獲取從控制臺傳入的參數;
# # println(Base.PROGRAM_FILE);  # 通過命令行啓動的，當前正在執行的 Julia 脚本文檔路徑;
# # for X in Base.ARGS
# #     println(X)
# # end
# # for X ∈ Base.ARGS
# #     println(X)
# # end
# if Base.length(Base.ARGS) > 0
#     for i = 1:Base.length(Base.ARGS)
#         # println("Base.ARGS" * Base.string(i) * ": " * Base.string(Base.ARGS[i]));  # 通過 Base.ARGS 數組獲取從控制臺傳入的參數;
#         # 使用 Core.isa(Base.ARGS[i], Core.String) 函數判断「元素(变量实例)」是否属于「集合(变量类型集)」之间的关系，使用 Base.typeof(Base.ARGS[i]) <: Core.String 方法判断「集合」是否包含于「集合」之间的关系，或 Base.typeof(Base.ARGS[i]) === Core.String 方法判斷傳入的參數是否為 String 字符串類型;
#         if Core.isa(Base.ARGS[i], Core.String) && Base.ARGS[i] !== "" && Base.occursin("=", Base.ARGS[i])

#             ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();  # 聲明一個聯合類型的空1維數組;
#             # 函數 Base.split(Base.ARGS[i], '=') 表示用等號字符'='分割字符串為數組;
#             for x in Base.split(Base.ARGS[i], '=')
#                 x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
#                 Base.push!(ARGSIArray, x);  # 使用 push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
#             end

#             if Base.length(ARGSIArray) > 1

#                 ARGSValue = "";
#                 # ARGSValue = join(Base.deleteat!(Base.deepcopy(ARGSIArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
#                 for j = 2:Base.length(ARGSIArray)
#                     if j === 2
#                         ARGSValue = ARGSValue * ARGSIArray[j];  # 使用星號*拼接字符串;
#                     else
#                         ARGSValue = ARGSValue * "=" * ARGSIArray[j];
#                     end
#                 end

#                 # try
#                 #     g = Base.Meta.parse(Base.string(ARGSIArray[1]) * "=" * Base.string(ARGSValue));  # 先使用 Base.Meta.parse() 函數解析字符串為代碼;
#                 #     Base.MainInclude.eval(g);  # 然後再使用 Base.MainInclude.eval() 函數執行字符串代碼語句;
#                 #     println(Base.string(ARGSIArray[1]) * " = " * "\$" * Base.string(ARGSIArray[1]));
#                 # catch err
#                 #     println(err);
#                 # end

#                 if ARGSValue !== ""

#                     if ARGSIArray[1] === "is_monitor"
#                         # global is_monitor = Base.Meta.parse(ARGSValue);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                         global is_monitor = Base.parse(Core.Bool, ARGSValue);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換為布爾型(Bool)的變量，用於判別執行一次還是持續監聽的開關 "true / false";
#                         # print("is monitor: ", is_monitor, "\n");
#                     end

#                     if ARGSIArray[1] === "monitor_file"
#                         global monitor_file = ARGSValue;  # 用於接收傳值的媒介文檔 "../temp/intermediary_write_Node.txt";
#                         # print("monitor file: ", monitor_file, "\n");
#                     end

#                     if ARGSIArray[1] === "monitor_dir"
#                         global monitor_dir = ARGSValue;  # 用於輸入傳值的媒介目錄 "../temp/"，當前路徑 Base.@__DIR__;
#                         # print("monitor dir: ", monitor_dir, "\n");
#                     end

#                     if ARGSIArray[1] === "output_dir"
#                         global output_dir = ARGSValue;  # 用於輸出傳值的媒介目錄 "../temp/"，當前路徑 Base.@__DIR__;
#                         # print("output dir: ", output_dir, "\n");
#                     end

#                     if ARGSIArray[1] === "output_file"
#                         global output_file = ARGSValue;  # 用於輸出傳值的媒介文檔 "../temp/intermediary_write_Julia.txt";
#                         # print("output file: ", output_file, "\n");
#                     end

#                     if ARGSIArray[1] === "temp_cache_IO_data_dir"
#                         global temp_cache_IO_data_dir = ARGSValue;  # 一個唯一的用於暫存傳入傳出數據的臨時媒介文件夾 "C:\Users\china\AppData\Local\Temp\temp_NodeJS_cache_IO_data\"，當前路徑 Base.@__DIR__;
#                         # print("Temporary cache IO data directory: ", temp_cache_IO_data_dir, "\n");
#                     end

#                     if ARGSIArray[1] === "to_executable"
#                         global to_executable = ARGSValue;  # 用於對返回數據執行功能的解釋器可執行文件 "C:\\NodeJS\\nodejs\\node.exe";
#                         # print("to executable: ", to_executable, "\n");
#                     end

#                     if ARGSIArray[1] === "to_script"
#                         global to_script = ARGSValue;  # 用於對返回數據執行功能的被調用的脚本文檔 "../js/test.js";
#                         # print("to script: ", to_script, "\n");
#                     end

#                     if ARGSIArray[1] === "time_sleep"
#                         # CheckString(ARGSValue, 'arabic_numerals');  # 自定義函數檢查輸入合規性;
#                         # global is_monitor = Base.Meta.parse(ARGSValue);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                         global time_sleep = Base.parse(Core.Float64, ARGSValue);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換無符號的長整型(Core.UInt64)類型的變量，監聽文檔輪詢延遲時長，單位毫秒 id = setInterval(function, delay);
#                         # print("time sleep: ", time_sleep, "\n");
#                     end

#                     if ARGSIArray[1] === "number_Worker_threads"
#                         # CheckString(ARGSValue, 'arabic_numerals');  # 自定義函數檢查輸入合規性;
#                         # global is_monitor = Base.Meta.parse(ARGSValue);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                         global number_Worker_threads = Base.parse(Core.UInt8, ARGSValue);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換無符號的短整型(UInt8)類型的變量，os.cpus().length 創建子進程 worker 數目等於物理 CPU 數目，使用"os"庫的方法獲取本機 CPU 數目;
#                         # print("number Worker threads: ", number_Worker_threads, "\n");
#                     end

#                     if ARGSIArray[1] === "readtimeout"
#                         # CheckString(ARGSValue, 'arabic_numerals');  # 自定義函數檢查輸入合規性;
#                         # global is_monitor = Base.Meta.parse(ARGSValue);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                         global readtimeout = Base.parse(Core.Int, ARGSValue);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換無符號的短整型(Int)類型的變量，os.cpus().length 創建子進程 worker 數目等於物理 CPU 數目，使用"os"庫的方法獲取本機 CPU 數目;
#                         # print("Read Timeout: ", readtimeout, "\n");
#                     end

#                     if ARGSIArray[1] === "connecttimeout"
#                         # CheckString(ARGSValue, 'arabic_numerals');  # 自定義函數檢查輸入合規性;
#                         # global is_monitor = Base.Meta.parse(ARGSValue);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                         global connect_timeout = Base.parse(Core.Int, ARGSValue);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換無符號的短整型(Int)類型的變量，os.cpus().length 創建子進程 worker 數目等於物理 CPU 數目，使用"os"庫的方法獲取本機 CPU 數目;
#                         # print("Connect Timeout: ", connect_timeout, "\n");
#                     end

#                     if ARGSIArray[1] === "verbose"
#                         # global verbose = Base.Meta.parse(ARGSValue);  # 使用 Base.Meta.parse() 將字符串類型(Core.String)變量解析為可執行的代碼語句;
#                         global verbose = Base.parse(Core.Bool, ARGSValue);  # 使用 Base.parse() 將字符串類型(Core.String)變量轉換為布爾型(Bool)的變量，用於判別執行一次還是持續監聽的開關 "true / false";
#                         # print("verbose: ", verbose, "\n");
#                     end

#                     if ARGSIArray[1] === "isMonitorThreadsOrProcesses"
#                         global isMonitorThreadsOrProcesses = ARGSValue;  # 0 || "0" || "Multi-Threading" || "Multi-Processes"; # 選擇監聽動作的函數的并發層級（多協程、多綫程、多進程）;
#                         # print("isMonitorThreadsOrProcesses: ", isMonitorThreadsOrProcesses, "\n");
#                         # 當 isMonitorThreadsOrProcesses = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
#                         # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
#                         # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
#                         # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
#                         # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;
#                     end

#                     if ARGSIArray[1] === "isDoTasksOrThreads"
#                         global isDoTasksOrThreads = ARGSValue;  # "Tasks" || "Multi-Threading"; # 選擇具體執行功能的函數的并發層級（多協程、多綫程、多進程）;
#                         # print("isDoTasksOrThreads: ", isDoTasksOrThreads, "\n");
#                         # 當 isDoTasksOrThreads = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
#                         # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
#                         # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
#                     end

#                     if ARGSIArray[1] === "do_Function"

#                         if ARGSValue === "do_data"

#                             # 使用函數 Base.@isdefined(do_data) 判斷 do_data 變量是否已經被聲明過;
#                             if Base.@isdefined(do_data)
#                                 # 使用 Core.isa(do_data, Core.Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_data) <: Core.Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_data) <: Core.Function 方法判別 do_data 變量的類型是否包含於函數Core.Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
#                                 # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數Core.Function類型集:
#                                 # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
#                                 if Base.typeof(do_data) <: Core.Function
#                                     global do_Function = do_data;
#                                 else
#                                     println("傳入的參數，指定的變量「" * ARGSValue * "」不是一個函數類型的變量.");
#                                     # global do_Function = Core.nothing;  # 置空;
#                                     global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                 end
#                             else
#                                 println("傳入的參數，指定的變量「" * ARGSValue * "」未定義.");
#                                 # global do_Function = Core.nothing;  # 置空;
#                                 global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             end

#                             # try
#                             #     if length(methods(do_data)) > 0
#                             #         global do_Function = do_data;
#                             #     else
#                             #         # global do_Function = Core.nothing;  # 置空;
#                             #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             #     end
#                             # catch err
#                             #     # println(err);
#                             #     # println(Base.typeof(err));
#                             #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷 err 的類型是否爲 Core.UndefVarError;
#                             #     if Core.isa(err, Core.UndefVarError)
#                             #         println(err.var, " not defined.");
#                             #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
#                             #         # global do_Function = Core.nothing;  # 置空;
#                             #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             #     else
#                             #         println(err);
#                             #     end
#                             # finally
#                             #     # global do_Function = Core.nothing;  # 置空;
#                             #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             # end
#                         end

#                         if ARGSValue === "do_Request"

#                             # 使用函數 Base.@isdefined(do_Request) 判斷 do_Request 變量是否已經被聲明過;
#                             if Base.@isdefined(do_Request)
#                                 # 使用 Core.isa(do_Request, Core.Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_Request) <: Core.Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_Request) <: Core.Function 方法判別 do_Request 變量的類型是否包含於函數Core.Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
#                                 # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數Core.Function類型集:
#                                 # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
#                                 if Base.typeof(do_Request) <: Core.Function
#                                     global do_Function = do_Request;
#                                 else
#                                     println("傳入的參數，指定的變量「" * ARGSValue * "」不是一個函數類型的變量.");
#                                     # global do_Function = Core.nothing;  # 置空;
#                                     global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                 end
#                             else
#                                 println("傳入的參數，指定的變量「" * ARGSValue * "」未定義.");
#                                 # global do_Function = Core.nothing;  # 置空;
#                                 global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             end

#                             # try
#                             #     if length(methods(do_Request)) > 0
#                             #         global do_Function = do_Request;
#                             #     else
#                             #         # global do_Function = Core.nothing;  # 置空;
#                             #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             #     end
#                             # catch err
#                             #     # println(err);
#                             #     # println(Base.typeof(err));
#                             #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷 err 的類型是否爲 Core.UndefVarError;
#                             #     if Core.isa(err, Core.UndefVarError)
#                             #         println(err.var, " not defined.");
#                             #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
#                             #         # global do_Function = Core.nothing;  # 置空;
#                             #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             #     else
#                             #         println(err);
#                             #     end
#                             # finally
#                             #     # global do_Function = Core.nothing;  # 置空;
#                             #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             # end
#                         end

#                         if ARGSValue === "do_Response"

#                             # 使用函數 Base.@isdefined(do_Response) 判斷 do_Response 變量是否已經被聲明過;
#                             if Base.@isdefined(do_Response)
#                                 # 使用 Core.isa(do_Response, Core.Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_Response) <: Core.Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_Response) <: Core.Function 方法判別 do_Response 變量的類型是否包含於函數Core.Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
#                                 # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數Core.Function類型集:
#                                 # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
#                                 if Base.typeof(do_Response) <: Core.Function
#                                     global do_Function = do_Response;
#                                 else
#                                     println("傳入的參數，指定的變量「" * ARGSValue * "」不是一個函數類型的變量.");
#                                     # global do_Function = Core.nothing;  # 置空;
#                                     global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                                 end
#                             else
#                                 println("傳入的參數，指定的變量「" * ARGSValue * "」未定義.");
#                                 # global do_Function = Core.nothing;  # 置空;
#                                 global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             end

#                             # try
#                             #     if length(methods(do_Response)) > 0
#                             #         global do_Function = do_Response;
#                             #     else
#                             #         # global do_Function = Core.nothing;  # 置空;
#                             #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             #     end
#                             # catch err
#                             #     # println(err);
#                             #     # println(Base.typeof(err));
#                             #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷 err 的類型是否爲 Core.UndefVarError;
#                             #     if Core.isa(err, Core.UndefVarError)
#                             #         println(err.var, " not defined.");
#                             #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
#                             #         # global do_Function = Core.nothing;  # 置空;
#                             #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             #     else
#                             #         println(err);
#                             #     end
#                             # finally
#                             #     # global do_Function = Core.nothing;  # 置空;
#                             #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
#                             # end
#                         end

#                         # if ARGSValue !== "do_data" && ARGSValue !== "do_data"
#                         #     # global do_Function = Core.nothing;  # 置空;
#                         #     global do_Function = (argument) -> argument;  # 匿名函數，直接返回傳入參數做返回值;
#                         # end

#                         # print("do Function: ", do_Function, "\n");
#                     end

#                     if ARGSIArray[1] === "host"
#                         global host = ARGSValue;  # 用於輸出傳值的媒介目錄 "../temp/";
#                         if Base.string(host) === "::0" || Base.string(host) === "::1" || Base.string(host) === "::" || Base.string(host) === "0" || Base.string(host) === "1"
#                             # || CheckIP(Base.string(host)) === "IPv6"
#                             global host = Sockets.IPv6(host);  # Sockets.IPv6(0);  # ::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv6(0);  # "::0" or "::1" or "localhost"; 監聽主機域名 Host domain name;
#                         elseif Base.string(host) === "0.0.0.0" || Base.string(host) === "127.0.0.1"
#                             # || CheckIP(Base.string(host)) === "IPv4"
#                             global host = Sockets.IPv4(host);  # Sockets.IPv4("0.0.0.0");  # ::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv4("0.0.0.0");  # "0.0.0.0" or "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
#                         elseif Base.string(host) === "localhost"
#                             global host = Sockets.IPv6(0);  # ::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv4("0.0.0.0");  # "::1";  # "0.0.0.0" or "localhost"; 監聽主機域名 Host domain name;
#                         else
#                             println("Error: host IP [ " * Base.string(host) * " ] unrecognized.");
#                             # return false
#                         end
#                         # print("host: ", Base.string(host), "\n");
#                     end

#                     if ARGSIArray[1] === "IPVersion"
#                         global IPVersion = ARGSValue;  # "IPv6"、"IPv4";
#                         # print("IP Version: ", IPVersion, "\n");
#                     end

#                     if ARGSIArray[1] === "port"
#                         global port = ARGSValue;  # Core.UInt8(5000),  # 0 ~ 65535， 監聽埠號（端口）;
#                         global port = Base.parse(Core.UInt64, port);
#                         # print("port: ", Base.string(port), "\n");
#                     end

#                     if ARGSIArray[1] === "key"
#                         global key = ARGSValue;  # 用於接收傳值的媒介文檔 "../temp/intermediary_write_Node.txt";
#                         # print("key: ", key, "\n");
#                     end

#                     if ARGSIArray[1] === "session"
#                         # global session = ARGSValue;  # 用於輸入傳值的媒介目錄 "../temp/";
#                         # g = Base.Meta.parse(Base.string(ARGSIArray[1]) * Base.string(ARGSValue));
#                         g = Base.Meta.parse("session=" * Base.string(ARGSValue));
#                         Base.MainInclude.eval(g);
#                         # print("session: ", session, "\n");
#                     end

#                     if ARGSIArray[1] === "isConcurrencyHierarchy"
#                         global isConcurrencyHierarchy = ARGSValue;  # "Tasks" || "Multi-Threading" || "Multi-Processes"; # 選擇具體執行功能的函數的并發層級（多協程、多綫程、多進程）;
#                         # print("isConcurrencyHierarchy: ", isConcurrencyHierarchy, "\n");
#                         # 當 isConcurrencyHierarchy = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
#                         # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
#                         # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
#                         # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
#                         # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;
#                     end

#                     if ARGSIArray[1] === "Authorization"
#                         global Authorization = ARGSValue;  # 客戶端發送的請求頭中的 Authorizater 參數值;
#                         # print("Authorization: ", Authorization, "\n");
#                     end

#                     if ARGSIArray[1] === "Cookie"
#                         global Cookie = ARGSValue;  # 客戶端發送的請求頭中的 Cookie 參數值;
#                         # print("Cookie: ", Cookie, "\n");
#                     end

#                     if ARGSIArray[1] === "key"
#                         if Base.string(ARGSValue) === "nothing" || Base.string(ARGSValue) === ""
#                             global key = "";
#                             # global key = Core.nothing;
#                         else
#                             global key = Base.string(ARGSValue);  # 用於接收傳值的媒介文檔 "../temp/intermediary_write_Node.txt";
#                         end
#                         # print("key: ", key, "\n");
#                     end

#                     if ARGSIArray[1] === "URL"
#                         global URL = ARGSValue;
#                         # print("URL: ", URL, "\n");
#                     end

#                     if ARGSIArray[1] === "requestFrom"
#                         global requestFrom = ARGSValue;  # 客戶端發送的請求頭中的 From 參數值;
#                         # print("requestFrom: ", requestFrom, "\n");
#                     end

#                     if ARGSIArray[1] === "requestPath"
#                         global requestPath = ARGSValue;
#                         # print("requestPath: ", requestPath, "\n");
#                     end

#                     if ARGSIArray[1] === "requestMethod"
#                         global requestMethod = ARGSValue;
#                         # print("requestMethod: ", requestMethod, "\n");
#                     end

#                     if ARGSIArray[1] === "requestProtocol"
#                         global requestProtocol = ARGSValue;
#                         # print("requestProtocol: ", requestProtocol, "\n");
#                     end

#                     if ARGSIArray[1] === "postData"
#                         # global postData = ARGSValue;  # 用於輸入傳值的媒介目錄 "../temp/";
#                         # g = Base.Meta.parse(Base.string(ARGSIArray[1]) * Base.string(ARGSValue));
#                         g = Base.Meta.parse("postData=" * Base.string(ARGSValue));
#                         Base.MainInclude.eval(g);
#                         # print("postData: ", postData, "\n");
#                     end

#                     if ARGSIArray[1] === "webPath"
#                         global webPath = ARGSValue;  # 用於輸入服務器的根目錄 "../";
#                         # print("webPath: ", webPath, "\n");
#                     end
#                 end
#             end
#         end
#     end
# end


# https://www.w3cschool.cn/julia/6rkw1jfj.html
# TCP_Client_「Sockets.Sockets.connect」;
function TCP_Client(
    host::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4},  # "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
    port::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String};  # 0 ~ 65535，監聽埠號（端口）;
    IPVersion::Core.String = "IPv6",  # "IPv6"、"IPv4";
    postData::Core.Union{Core.String, Base.Dict} = "",  # Base.Dict{Core.String, Core.Any}("Client_say" => "Julia-1.6.2 Sockets.connect."),  # postData::Core.Union{Core.String, Base.Dict{Core.Any, Core.Any}}，"{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"time\":\"" * Base.string(now_date) * "\"}";
    URL::Core.String = "",  # Base.string(http_Client.requestProtocol) * "://" * Base.convert(Core.String, Base.strip((Base.split(Base.string(http_Client.Authorization), ' ')[2]))) * "@" * Base.string(http_Client.host) * ":" * Base.string(http_Client.port) * Base.string(http_Client.requestPath),  # 請求網址 URL："http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1;
    requestPath::Core.String = "/",
    requestMethod::Core.String = "GET",  # "POST",  # "GET"; # 請求方法;
    requestProtocol::Core.String = "HTTP",
    # time_out::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
    Authorization::Core.String = ":",  # "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
    Cookie::Core.String = "",  # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
    requestFrom::Core.String = "user@email.com",
    # do_Function = (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Response";
    # session::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => TCP_Server.key),  # 保存網站的 Session 數據;
    # number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.UInt8(0),  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
    # time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
    # isConcurrencyHierarchy::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
    # worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
    # total_worker_called_number::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
)::Core.Array{Core.Any, 1}
    # ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}

    # # print("當前協程 task: ", Base.current_task(), "\n");
    # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
    # print("當前綫程 thread 的 ID: ", Base.Threads.threadid(), "\n");
    # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
    # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
    # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
    # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
    # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
    # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
    # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
    # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
    # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
    # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
    # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
    # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
    # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

    # println(Base.Sys.CPU_THREADS)  # 4 可用 CPU 數;
    # println(Base.Filesystem.ispath(Base.Filesystem.pwd()))  # true 判斷目錄是否存在;
    # println(Base.Sys.BINDIR)  # C:\Program Files\Julia 1.5.1\bin;
    # println(Base.PROGRAM_FILE)  # c:\Users\china\Documents\Node.js\Criss\jl\tempCodeRunnerFile.jl;
    # println(Base.Filesystem.basename(Base.Filesystem.pwd()))  # Criss;
    # # "File_Directory_and_Path";
    # println(Base.Filesystem.homedir())  # C:\Users\china;
    # println(Base.Filesystem.pwd())  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath("."))  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js\Criss;
    # # 获取路径的目录;
    # println(Base.Filesystem.dirname(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js;
    # # "/Users/juliauser/Functions_Scripts_Codes_Pipelines/Julia_Codes";
    # # 路径的末端分割;
    # println(Base.Filesystem.splitdir(Base.Filesystem.pwd()));
    # # ("c:\\Users\\china\\Documents\\Node.js", "Criss");
    # # 路径的合成;
    # println(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "temp", "intermediary_write_NodeJS.txt"));  # c:\Users\china\Documents\Node.js\temp\intermediary_write_NodeJS.txt;
    # # Base.Filesystem.cd()  # 更換工作目錄;
    # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl"))
    # # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl").mode) # 返回值為 Core.UInt64 類型數值，例如 Core.UInt64(33206);


    # 判斷傳入的參數用於指定監聽主機的 IP 地址或域名 host 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(host) 判斷 host 變量是否已經被定義過;
    if !Base.@isdefined(host) || host === "" || host === Core.nothing
        # local host = "127.0.0.1",  # "0.0.0.0" or "localhost";
        # local host = Core.nothing;  # 置空;
        println("用於指定監聽主機的 IP 地址或域名「host ∈ ", Base.typeof(host), "」不能被識別.");
        return ["error", host, "argument [ host = " * Base.string(host) * " ] typeof error, no defined."];  # "用於指定監聽主機的 IP 地址或域名「host = " * Base.string(Base.typeof(host)) * "」不能被識別.";
    elseif !Core.isa(host, Core.String) && !Core.isa(host, Sockets.IPv6) && !Core.isa(host, Sockets.IPv4)
        # 使用 Core.isa(host, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(host) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(host) === Core.String 方法判別 host 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於指定監聽主機的 IP 地址或域名「host ∈ ", Base.typeof(host), "」不合法，只接受輸入主機 IP 地址或域名字符串.");
        return ["error", host, "argument [ host = " * Base.string(host) * " ] typeof error, not String."];  # ["error", host, "用於指定監聽主機的 IP 地址或域名「host = " * Base.string(Base.typeof(host)) * "」不合法，只接受輸入主機 IP 地址或域名字符串."];
    end

    # 判斷傳入的參數用於指定監聽主機的 IP 地址或域名 host 版本標志爲 IPv6 還是 IPv4 版，使用函數 Base.@isdefined(IPVersion) 判斷 IPVersion 變量是否已經被定義過;
    if !Base.@isdefined(IPVersion) || IPVersion === "" || IPVersion === Core.nothing
        # local host = "127.0.0.1",  # "0.0.0.0" or "localhost";
        # local host = Core.nothing;  # 置空;
        IPVersion = "IPv6";
        # println("用於指定監聽主機的 IP 地址版本「IP Version ∈ ", Base.typeof(IPVersion), "」不能被識別.");
        # return ["error", IPVersion, "argument [ IPVersion = " * Base.string(IPVersion) * " ] typeof error, no defined."];  # "用於指定監聽主機的 IP 地址或域名「IPVersion = " * Base.string(Base.typeof(IPVersion)) * "」不能被識別.";
    elseif !Core.isa(IPVersion, Core.String) || !(IPVersion === "IPv6" || IPVersion === "IPv4")
        # 使用 Core.isa(IPVersion, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(IPVersion) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(IPVersion) === Core.String 方法判別 IPVersion 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於指定監聽主機的 IP 地址版本「IP Version ∈ ", Base.typeof(IPVersion), "」不合法，只接受輸入主機 IP 地址版本類型[ \"IPv6\", \"IPv4\" ]字符串.");
        return ["error", IPVersion, "argument [ IPVersion = " * Base.string(IPVersion) * " ] typeof error, not String or IPv6 or IPv4."];  # ["error", IPVersion, "用於指定監聽主機的 IP 地址或域名「IPVersion = " * Base.string(Base.typeof(IPVersion)) * "」不合法，只接受輸入主機 IP 地址或域名字符串."];
    end

    # 判斷傳入的參數用於指定監聽主機埠號（端口） port 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(port) 判斷 port 變量是否已經被定義過;
    if !Base.@isdefined(port) || port === "" || port === Core.nothing
        # local port = Core.UInt8(5000);  # Core.UInt8 類型，用於指定監聽主機埠號（端口），自定義函數檢查輸入合規性 CheckString(port, 'arabic_numerals');
        port = Core.UInt8(5000);  # Core.UInt8 類型，用於指定監聽主機埠號（端口），自定義函數檢查輸入合規性 CheckString(port, 'arabic_numerals');
        # local port = Core.nothing;  # 置空;
        # println("傳入的參數用於指定監聽主機埠號（端口）「port ∈ ", Base.typeof(port), "」不能被識別.");
        # return "argument [ port = " * Base.string(port) * " ] typeof error, no defined."  # "用於指定監聽主機埠號（端口）「port = " * Base.string(Base.typeof(port)) * "」不能被識別.";
    elseif !(Base.typeof(port) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(port, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(port) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(port) <: Core.UInt64 方法判別 port 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於指定監聽主機埠號（端口）「port ∈ ", Base.typeof(port), "」不是一個數值類型的變量.");
        return "argument [ port = " * Base.string(port) * " ] typeof error, not Float and not Int."  # "用於指定監聽主機埠號（端口）「port = " * Base.string(Base.typeof(port)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的參數用於向服務器發送的請求數據字典或字符串變量 postData 是否已定義且為字典類型 Base.Dict 或字符串 Core.String 類型;
    if !Base.@isdefined(postData) || postData === Core.nothing
        # postData = Base.Dict{Core.String, Core.Any}("Client_say" => "Julia-1.6.2 Sockets.connect.");  # 用於記錄服務器 postData 數據的字典變量;        
        println("用於向服務器發送的請求數據 postData 字典或字符串變量「postData ∈ ", Base.typeof(postData), "」不能被識別.");
        return ["error", postData, "argument [ postData ∈ " * Base.string(postData) * " ] typeof error, no defined."];  # "用於向服務器發送的請求數據 postData 字典或字符串變量「postData ∈ " * Base.string(Base.typeof(postData)) * "」不能被識別.";
    elseif !(Base.typeof(postData) <: Core.Union{Core.String, Base.Dict})
        # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求數據 postData 字典或字符串變量「postData ∈ ", Base.typeof(postData), "」不合法，只接受輸入字典(Base.Dict)或者字符串(Core.String)類型變量.");
        return ["error", postData, "argument [ postData ∈ " * Base.string(Base.typeof(postData)) * " ] typeof error, not Dict or String."];  # ["error", postData, "用於向服務器發送的請求數據 postData 字典或字符串變量「postData ∈ " * Base.string(Base.typeof(postData)) * "」不合法，只接受輸入字典(Base.Dict)或者字符串(Core.String)類型變量."];
    end

    # 判斷傳入的參數用於記錄服務器訪問賬號密碼的變量 key 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(key) 判斷 key 變量是否已經被定義過;
    if !Base.@isdefined(Authorization) || Authorization === Core.nothing
        # local Authorization = "username:password";
        # local Authorization = Core.nothing;  # 置空;
        println("用於記錄服務器訪問賬號密碼的變量「Authorization ∈ ", Base.typeof(Authorization), "」不能被識別.");
        return ["error", Authorization, "argument [ Authorization = " * Base.string(Authorization) * " ] typeof error, no defined."];  # "用於記錄服務器訪問賬號密碼的變量「Authorization = " * Base.string(Base.typeof(Authorization)) * "」不能被識別.";
    elseif !Core.isa(Authorization, Core.String)
        # 使用 Core.isa(Authorization, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(Authorization) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(Authorization) === Core.String 方法判別 Authorization 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於記錄服務器訪問賬號密碼的變量「Authorization ∈ ", Base.typeof(Authorization), "」不合法，只接受輸入「username:password」形式的字符串.");
        return ["error", Authorization, "argument [ Authorization = " * Base.string(Authorization) * " ] typeof error, not String."];  # ["error", Authorization, "用於記錄服務器訪問賬號密碼的變量「Authorization = " * Base.string(Base.typeof(Authorization)) * "」不合法，只接受輸入「username:password」形式的字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求頭 Cookie 參數 Cookie 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(Cookie) 判斷 Cookie 變量是否已經被定義過;
    if !Base.@isdefined(Cookie) || Cookie === Core.nothing
        # local Cookie = "Session_ID=request_Key->username:password";  # "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
        # local Cookie = Core.nothing;  # 置空;
        println("用於向服務器發送的請求頭 Cookie 參數「Cookie ∈ ", Base.typeof(Cookie), "」不能被識別.");
        return ["error", Cookie, "argument [ Cookie = " * Base.string(Cookie) * " ] typeof error, no defined."];  # "用於向服務器發送的請求頭 Cookie 參數「Cookie = " * Base.string(Base.typeof(Cookie)) * "」不能被識別.";
    elseif !Core.isa(Cookie, Core.String)
        # 使用 Core.isa(Cookie, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(Cookie) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(Cookie) === Core.String 方法判別 Cookie 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求頭 Cookie 參數「Cookie ∈ ", Base.typeof(Cookie), "」不合法，只接受輸入字符串.");
        return ["error", Cookie, "argument [ Cookie = " * Base.string(Cookie) * " ] typeof error, not String."];  # ["error", Cookie, "用於向服務器發送的請求頭 Cookie 參數「Cookie = " * Base.string(Base.typeof(Cookie)) * "」不合法，只接受輸入字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求頭 URL 參數 URL 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(URL) 判斷 URL 變量是否已經被定義過;
    # "http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1;
    if !Base.@isdefined(URL) || URL === Core.nothing
        # local URL = "";
        # local URL = Core.nothing;  # 置空;
        println("用於向服務器發送的請求頭 URL 參數「URL ∈ ", Base.typeof(URL), "」不能被識別.");
        return ["error", URL, "argument [ URL = " * Base.string(URL) * " ] typeof error, no defined."];  # "用於向服務器發送的請求頭 URL 參數「URL = " * Base.string(Base.typeof(URL)) * "」不能被識別.";
    elseif !Core.isa(URL, Core.String)
        # 使用 Core.isa(URL, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(URL) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(URL) === Core.String 方法判別 URL 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求頭 URL 參數「URL ∈ ", Base.typeof(URL), "」不合法，只接受輸入字符串.");
        return ["error", URL, "argument [ URL = " * Base.string(URL) * " ] typeof error, not String."];  # ["error", URL, "用於向服務器發送的請求頭 URL 參數「URL = " * Base.string(Base.typeof(URL)) * "」不合法，只接受輸入字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求路徑參數 requestPath 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(requestPath) 判斷 requestPath 變量是否已經被定義過;
    if !Base.@isdefined(requestPath) || requestPath === Core.nothing
        # local requestPath = "/";
        # local requestPath = Core.nothing;  # 置空;
        println("用於向服務器發送的請求路徑參數「requestPath ∈ ", Base.typeof(requestPath), "」不能被識別.");
        return ["error", requestPath, "argument [ requestPath = " * Base.string(requestPath) * " ] typeof error, no defined."];  # "用於向服務器發送的請求路徑參數「requestPath = " * Base.string(Base.typeof(requestPath)) * "」不能被識別.";
    elseif !Core.isa(requestPath, Core.String)
        # 使用 Core.isa(requestPath, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(requestPath) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(requestPath) === Core.String 方法判別 requestPath 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求路徑參數「requestPath ∈ ", Base.typeof(requestPath), "」不合法，只接受輸入字符串.");
        return ["error", requestPath, "argument [ requestPath = " * Base.string(requestPath) * " ] typeof error, not String."];  # ["error", requestPath, "用於向服務器發送的請求路徑參數「requestPath = " * Base.string(Base.typeof(requestPath)) * "」不合法，只接受輸入字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求方法參數 requestMethod 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(requestMethod) 判斷 requestMethod 變量是否已經被定義過;
    if !Base.@isdefined(requestMethod) || requestMethod === Core.nothing
        # local requestMethod = "GET",  # "POST";
        # local requestMethod = Core.nothing;  # 置空;
        println("用於向服務器發送的請求方法參數「requestMethod ∈ ", Base.typeof(requestMethod), "」不能被識別.");
        return ["error", requestMethod, "argument [ requestMethod = " * Base.string(requestMethod) * " ] typeof error, no defined."];  # "用於向服務器發送的請求方法參數「requestMethod = " * Base.string(Base.typeof(requestMethod)) * "」不能被識別.";
    elseif !Core.isa(requestMethod, Core.String)
        # 使用 Core.isa(requestMethod, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(requestMethod) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(requestMethod) === Core.String 方法判別 requestMethod 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求方法參數「requestMethod ∈ ", Base.typeof(requestMethod), "」不合法，只接受輸入字符串.");
        return ["error", requestMethod, "argument [ requestMethod = " * Base.string(requestMethod) * " ] typeof error, not String."];  # ["error", requestMethod, "用於向服務器發送的請求方法參數「requestMethod = " * Base.string(Base.typeof(requestMethod)) * "」不合法，只接受輸入字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求協議參數 requestProtocol 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(requestProtocol) 判斷 requestProtocol 變量是否已經被定義過;
    if !Base.@isdefined(requestProtocol) || requestProtocol === Core.nothing
        # local requestProtocol = "HTTP";
        # local requestProtocol = Core.nothing;  # 置空;
        println("用於向服務器發送的請求協議參數「requestProtocol ∈ ", Base.typeof(requestProtocol), "」不能被識別.");
        return ["error", requestProtocol, "argument [ requestProtocol = " * Base.string(requestProtocol) * " ] typeof error, no defined."];  # "用於向服務器發送的請求協議參數「requestProtocol = " * Base.string(Base.typeof(requestProtocol)) * "」不能被識別.";
    elseif !Core.isa(requestProtocol, Core.String)
        # 使用 Core.isa(requestProtocol, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(requestProtocol) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(requestProtocol) === Core.String 方法判別 requestProtocol 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        # Base.Unicode.lowercase(requestProtocol);  # 轉小寫字母;
        println("用於向服務器發送的請求協議參數「requestProtocol ∈ ", Base.typeof(requestProtocol), "」不合法，只接受輸入字符串.");
        return ["error", requestProtocol, "argument [ requestProtocol = " * Base.string(requestProtocol) * " ] typeof error, not String."];  # ["error", requestProtocol, "用於向服務器發送的請求協議參數「requestProtocol = " * Base.string(Base.typeof(requestProtocol)) * "」不合法，只接受輸入字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求者聯係方式 From 參數 requestFrom 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(requestFrom) 判斷 requestFrom 變量是否已經被定義過;
    if !Base.@isdefined(requestFrom) || requestFrom === Core.nothing
        # local requestFrom = "user@email.com";
        # local requestFrom = Core.nothing;  # 置空;
        println("用於向服務器發送的請求者聯係方式 From 參數「requestFrom ∈ ", Base.typeof(requestFrom), "」不能被識別.");
        return ["error", requestFrom, "argument [ requestFrom = " * Base.string(requestFrom) * " ] typeof error, no defined."];  # "用於向服務器發送的請求者聯係方式 From 參數「requestFrom = " * Base.string(Base.typeof(requestFrom)) * "」不能被識別.";
    elseif !Core.isa(requestFrom, Core.String)
        # 使用 Core.isa(requestFrom, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(requestFrom) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(requestFrom) === Core.String 方法判別 requestFrom 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求者聯係方式 From 參數「requestFrom ∈ ", Base.typeof(requestFrom), "」不合法，只接受輸入字符串.");
        return ["error", requestFrom, "argument [ requestFrom = " * Base.string(requestFrom) * " ] typeof error, not String."];  # ["error", requestFrom, "用於向服務器發送的請求者聯係方式 From 參數「requestFrom = " * Base.string(Base.typeof(requestFrom)) * "」不合法，只接受輸入字符串."];
    end

    # # 判斷傳入的參數用於記錄服務器 Session 數據的字典變量 session 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(session) 判斷 session 變量是否已經被定義過;
    # if !Base.@isdefined(session) || session === "" || session === Core.nothing
    #     # session = Base.Dict{Core.String, Core.String}("request_Key->username:password" => Authorization);  # 用於記錄服務器 Session 數據的字典變量;        
    #     println("用於記錄服務器 Session 數據的字典變量「session ∈ ", Base.typeof(session), "」不能被識別.");
    #     return ["error", session, "argument [ session ∈ " * Base.string(session) * " ] typeof error, no defined."];  # "用於保存服務器 Session 數據的字典變量「session ∈ " * Base.string(Base.typeof(session)) * "」不能被識別.";
    # elseif !(Base.typeof(session) <: Base.Dict)
    #     # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於記錄服務器 Session 數據的字典變量「session ∈ ", Base.typeof(session), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
    #     return ["error", session, "argument [ session ∈ " * Base.string(Base.typeof(session)) * " ] typeof error, not Dict."];  # ["error", session, "用於記錄服務器 Session 數據的字典變量「session ∈ " * Base.string(Base.typeof(session)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    # end

    # # 判斷傳入的參數用於具體執行處理客戶端請求數據的函數 do_Function 是否已定義且為函數，使用函數 Base.@isdefined(do_Function) 判斷 do_Function 變量是否已經被定義過;
    # if !Base.@isdefined(do_Function) || do_Function === "" || do_Function === Core.nothing
    #     # local do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # local do_Function = Core.nothing;  # 置空;
    #     println("用於具體執行處理客戶端請求數據的函數「do_Function ∈ ", Base.typeof(do_Function), "」不能被識別.");
    #     return "argument [ do_Function = " * Base.string(do_Function) * " ] typeof error, no defined."  # "用於具體執行處理客戶端請求數據的函數「do_Function = " * Base.string(Base.typeof(do_Function)) * "」不能被識別.";
    # elseif !(Base.typeof(do_Function) <: Core.Function)
    #     # 使用 Core.isa(do_Function, Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_Function) <: Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_Function) <: Function 方法判別 do_Function 變量的類型是否包含於函數Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於具體執行處理客戶端請求數據的函數「do_Function ∈ ", Base.typeof(do_Function), "」不是一個函數類型的變量.");
    #     return "argument [ do_Function = " * Base.string(do_Function) * " ] typeof error, not Function."  # "用於具體執行處理客戶端請求數據的函數「do_Function = " * Base.string(Base.typeof(do_Function)) * "」不是一個函數類型的變量.";

    #     # try
    #     #     if length(methods(do_Function)) > 0
    #     #         global do_Function = do_data;
    #     #     else
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     end
    #     # catch err
    #     #     # println(err);
    #     #     # println(Base.typeof(err));
    #     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
    #     #     if Core.isa(err, Core.UndefVarError)
    #     #         println(err.var, " not defined.");
    #     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     else
    #     #         println(err);
    #     #     end
    #     # finally
    #     #     # global do_Function = Core.nothing;  # 置空;
    #     #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # end
    # end

    # # 判斷傳入的自定義多綫程并發數目參數 number_Worker_threads 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(number_Worker_threads) 判斷 number_Worker_threads 變量是否已經被定義過;
    # if !Base.@isdefined(number_Worker_threads) || number_Worker_threads === "" || number_Worker_threads === Core.nothing
    #     # local number_Worker_threads = Core.UInt8(0);  # Core.UInt8 類型，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
    #     # number_Worker_threads = Core.UInt8(0);  # Core.UInt8 類型，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
    #     # local number_Worker_threads = Core.nothing;  # 置空;
    #     println("傳入的參數，指定的變量「number_Worker_threads ∈ ", Base.typeof(number_Worker_threads), "」不能被識別.");
    #     return "argument [ number_Worker_threads = " * Base.string(number_Worker_threads) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「number_Worker_threads = " * Base.string(Base.typeof(number_Worker_threads)) * "」不能被識別.";
    # elseif !(Base.typeof(number_Worker_threads) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
    #     # 使用 Core.isa(number_Worker_threads, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判別 number_Worker_threads 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("傳入的參數，指定的變量「number_Worker_threads ∈ ", Base.typeof(number_Worker_threads), "」不是一個數值類型的變量.");
    #     return "argument [ number_Worker_threads = " * Base.string(number_Worker_threads) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「number_Worker_threads = " * Base.string(Base.typeof(number_Worker_threads)) * "」不是一個數值類型的變量.";

    #     # try
    #     #     if length(methods(do_data)) > 0
    #     #         global do_Function = do_data;
    #     #     else
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     end
    #     # catch err
    #     #     # println(err);
    #     #     # println(Base.typeof(err));
    #     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
    #     #     if Core.isa(err, Core.UndefVarError)
    #     #         println(err.var, " not defined.");
    #     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     else
    #     #         println(err);
    #     #     end
    #     # finally
    #     #     # global do_Function = Core.nothing;  # 置空;
    #     #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # end
    # end

    # # 判斷傳入的自定義系統暫停時長參數 time_sleep 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(time_sleep) 判斷 time_sleep 變量是否已經被定義過;
    # if !Base.@isdefined(time_sleep) || time_sleep === "" || time_sleep === Core.nothing
    #     # local time_sleep = Core.Float64(0.02);  # Core.Float64 類型變量，20 毫秒，系統暫停等待時長;
    #     time_sleep = Core.Float64(0);  # Float64 類型變量，0.02 === 20 毫秒，系統暫停等待時長;
    #     # local time_sleep = Core.nothing;  # 置空;
    #     # println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不能被識別.");
    #     # return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不能被識別.";
    # elseif !(Base.typeof(time_sleep) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
    #     # 使用 Core.isa(time_sleep, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判別 time_sleep 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不是一個數值類型的變量.");
    #     return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不是一個數值類型的變量.";

    #     # try
    #     #     if length(methods(do_data)) > 0
    #     #         global do_Function = do_data;
    #     #     else
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     end
    #     # catch err
    #     #     # println(err);
    #     #     # println(Base.typeof(err));
    #     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
    #     #     if Core.isa(err, Core.UndefVarError)
    #     #         println(err.var, " not defined.");
    #     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     else
    #     #         println(err);
    #     #     end
    #     # finally
    #     #     # global do_Function = Core.nothing;  # 置空;
    #     #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # end
    # end

    # # 判斷傳入的參數用於指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量 isConcurrencyHierarchy 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(isConcurrencyHierarchy) 判斷 isConcurrencyHierarchy 變量是否已經被定義過;
    # if !Base.@isdefined(isConcurrencyHierarchy) || isConcurrencyHierarchy === "" || isConcurrencyHierarchy === Core.nothing
    #     # local isConcurrencyHierarchy = "Tasks" || "Multi-Threading" || "Multi-Processes";
    #     # local isConcurrencyHierarchy = Core.nothing;  # 置空;
    #     println("指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy ∈ ", Base.typeof(isConcurrencyHierarchy), "」不能被識別.");
    #     return ["error", isConcurrencyHierarchy, "argument [ isConcurrencyHierarchy = " * Base.string(isConcurrencyHierarchy) * " ] typeof error, no defined."];  # "指定監聽并發的層次（多綫程、多進程）的變量「isConcurrencyHierarchy = " * Base.string(Base.typeof(isConcurrencyHierarchy)) * "」不能被識別.";
    # elseif !Core.isa(isConcurrencyHierarchy, Core.String) || (isConcurrencyHierarchy !== "Tasks" && isConcurrencyHierarchy !== "Multi-Threading" && isConcurrencyHierarchy !== "Multi-Processes")
    #     # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy ", Base.typeof(isConcurrencyHierarchy), "」不合法，只接受輸入：\"Tasks\" || \"Multi-Threading\" 兩個值.");
    #     return ["error", isConcurrencyHierarchy, "argument [ isConcurrencyHierarchy = " * Base.string(isConcurrencyHierarchy) * " ] typeof error, not String."];  # ["error", isConcurrencyHierarchy, "指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy = " * Base.string(Base.typeof(isConcurrencyHierarchy)) * "」不合法，只接受輸入：\"Tasks\" || \"Multi-Threading\" 兩個值."];
    # end

    # # 判斷傳入的參數用於保存每個綫程的字典變量 worker_queues_Dict 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(worker_queues_Dict) 判斷 worker_queues_Dict 變量是否已經被定義過;
    # if !Base.@isdefined(worker_queues_Dict) || worker_queues_Dict === "" || worker_queues_Dict === Core.nothing
    #     # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # 保存每個工作子綫程;
    #     worker_queues_Dict = Base.Dict{Core.String, Core.UInt64}();  # 保存每個工作子綫程;
    #     # println("用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ ", Base.typeof(worker_queues_Dict), "」不能被識別.");
    #     # return ["error", worker_queues_Dict, "argument [ worker_queues_Dict ∈ " * Base.string(worker_queues_Dict) * " ] typeof error, no defined."];  # "用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * "」不能被識別.";
    # elseif !(Base.typeof(worker_queues_Dict) <: Base.Dict)
    #     # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ ", Base.typeof(worker_queues_Dict), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
    #     return ["error", worker_queues_Dict, "argument [ worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * " ] typeof error, not Dict."];  # ["error", worker_queues_Dict, "用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    # end

    # # 判斷傳入的參數用於記錄每個綫程纍加的被調用運算的總次數的字典變量 total_worker_called_number 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(total_worker_called_number) 判斷 total_worker_called_number 變量是否已經被定義過;
    # if !Base.@isdefined(total_worker_called_number) || total_worker_called_number === "" || total_worker_called_number === Core.nothing
    #     # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
    #     # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
    #     println("用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ ", Base.typeof(total_worker_called_number), "」不能被識別.");
    #     return ["error", total_worker_called_number, "argument [ total_worker_called_number ∈ " * Base.string(total_worker_called_number) * " ] typeof error, no defined."];  # "用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * "」不能被識別.";
    # elseif !(Base.typeof(total_worker_called_number) <: Base.Dict)
    #     # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ ", Base.typeof(total_worker_called_number), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
    #     return ["error", total_worker_called_number, "argument [ total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * " ] typeof error, not Dict."];  # ["error", total_worker_called_number, "用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    # end


    # 配置客戶端向服務器端發送的請求 Cookie 值;
    # Set-Cookie: name=value[; expires=date][; domain=domain][; path=path][; secure];
    # 其中，參數secure選項只是一個標記沒有其它的值，表示一個secure cookie只有當請求是通過SSL和HTTPS創建時，才會發送到伺服器端;
    # 參數domain選項表示cookie作用域，不支持IP數值，只能使用功能變數名稱，指示cookie將要發送到哪個域或那些域中，預設情況下domain會被設置為創建該cookie的頁面所在的功能變數名稱，domain選項被用來擴展cookie值所要發送域的數量;
    # 參數Path選項（The path option），與domain選項相同的是，path指明了在發Cookie消息頭之前，必須在請求資源中存在一個URL路徑，這個比較是通過將path屬性值與請求的URL從頭開始逐字串比較完成的，如果字元匹配，則發送Cookie消息頭;
    # 參數value部分，通常是一個 name=value 格式的字串，通常性的使用方式是以 name=value 的格式來指定cookie的值;
    # 通常cookie的壽命僅限於單一的會話中，流覽器的關閉意味這一次會話的結束，所以會話cookie只存在於流覽器保持打開的狀態之下，參數expires選項用於設定這個cookie壽命（有效時長），一個expires選項會被附加到登錄的cookie中指定一個截止日期，如果expires選項設置了一個過去的時間點，那麼這個cookie會被立即刪除;
    now_date = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
    # println(Base.string(Dates.now()))
    # after_1_Days = Dates.DateTime(Dates.year(now_date), Dates.month(now_date), Dates.day(now_date) + Dates.day(1), Dates.hour(now_date), Dates.minute(now_date), Dates.second(now_date), Dates.millisecond(now_date));  # 計算 1 日之後的日期，需要先加載原生 Dates 包 using Dates;
    # println(Base.string(after_1_Days));

    # if Base.occursin("=", Cookie)

    #     requestCookieArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
    #     # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
    #     # 函數 Base.split(Cookie, '=') 表示用等號字符'='分割字符串為數組;
    #     for x in Base.split(Cookie, '=')
    #         temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
    #         temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
    #         Base.push!(requestCookieArray, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
    #     end

    #     if Base.length(requestCookieArray) > 1

    #         requestCookieValue = "";
    #         # requestCookieArray = Base.join(Base.deleteat!(Base.deepcopy(requestCookieArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
    #         for j = 2:Base.length(requestCookieArray)
    #             if j === 2
    #                 requestCookieValue = requestCookieValue * requestCookieArray[j];  # 使用星號*拼接字符串;
    #             else
    #                 requestCookieValue = requestCookieValue * "=" * requestCookieArray[j];
    #             end
    #         end

    #         # try
    #         #     eval(:(
    #         #         begin
    #         #             Sys.eval("global " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
    #         #             # Sys.eval("local " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
    #         #             # println($ARGSIArray[1]);
    #         #         end
    #         #     ));
    #         # catch err
    #         #     println(err);
    #         # end

    #         cookie_value::Core.String = Base.string(requestCookieArray[1]) * "=" * Base64.base64encode(requestCookieValue; context=nothing);  # "Session_ID=request_Key->username:password"，將漢字做Base64轉碼Base64.base64encode()，需要事先加載原生的 Base64 模組：using Base64 模組;
    #         # println("Request Cook: ", cookie_value);
    #         # println(Core.String(Base64.base64decode(requestCookieValue)));
    #     end
    # end
    cookie_value::Core.String = Cookie;  # "session_id=request_Key->username:password" -> "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
    # println(Base.convert(Core.String, Base.strip(Base.split(Cookie, '=')[2])));  # "request_Key->username:password"，將漢字做 Base64 轉碼 Base64.base64encode("str"; context=nothing)，Base64 解碼 Base64.base64decode(base64)，需要事先加載原生的 Base64 模組：using Base64 模組;
    # println(Base.convert(Core.String, Base.strip(Base.split(Cookie, '=')[1])) * "=" * Core.String(Base64.base64decode(Base.convert(Core.String, Base.strip(Base.split(Cookie, '=')[2])))));  # "request_Key->username:password"，將漢字做 Base64 轉碼 Base64.base64encode("str"; context=nothing)，Base64 解碼 Base64.base64decode(base64)，需要事先加載原生的 Base64 模組：using Base64 模組;
    # cookie_string::Core.String = cookie_value * "; expires=" * Base.string(after_1_Days) * "; path=/;";  # 拼接 cookie 字符串值;
    # println(cookie_string);

    # 配置客戶端向服務器端發送請求的權限賬號密碼;
    authorization_value::Core.String = "Basic" * " " * Base64.base64encode(Authorization; context=nothing);  # 編碼 "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=" ，需要事先加載原生的 Base64 模組：using Base64 模組;
    # authorization_value::Core.String = Authorization;
    # println(Base.convert(Core.String, Base.strip(Base.split(authorization_value, ' ')[2])));
    # println(Core.String(Base64.base64decode(Base.convert(Core.String, Base.strip(Base.split(authorization_value, ' ')[2])))));  # 讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;

    # 配置客戶端向服務器端發送的請求數據;
    request_data_String::Core.String = "";
    if Base.isa(postData, Core.String)
        request_data_String = postData;  # postData::Core.Union{Core.String, Base.Dict} = "",  # postData::Core.Union{Core.String, Base.Dict{Core.Any, Core.Any}};
        # request_data_String = "{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"Client_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
    elseif Base.isa(postData, Base.Dict)
        # && Base.haskey(postData, "label")
        tempArr = Core.Array{Core.String, 1}();
        for k in Base.keys(postData)
            temp = "\"" * Base.convert(Core.String, Base.strip(Base.string(k))) * "\"" * ":" * "\"" * Base.convert(Core.String, Base.strip(Base.string(postData[k]))) * "\"";  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量，Base.strip(str) 去除字符串首尾兩端的空格;
            # println(temp);
            Base.push!(tempArr, temp);  # 使用 push! 函數在數組末尾追加推入新元素;
        end
        request_data_String = Base.join(tempArr, ",");
        request_data_String = "{" * request_data_String * "}";
        # request_data_String = "{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"Client_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
        # request_data_String = JSONstring(postData);  # 使用自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
        # # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象;
        # # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
    end
    request_data_String_len = Base.sizeof(request_data_String);

    UserAgent::Core.String = "Julia-" * Base.string(Base.VERSION) * " Sockets.connect.";  # "Julia-1.6.2 Sockets.connect."，"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36";

    Line_1::Core.String = "";
    if requestProtocol === "HTTP"
        Line_1 = Base.string(requestMethod) * " " * Base.string(requestPath) * " " * Base.string(requestProtocol) * "/1.1";  # "GET / HTTP/1.1";
    else
        Line_1 = Base.string(requestMethod) * " " * Base.string(requestPath) * " " * Base.string(requestProtocol);  # "GET / HTTP/1.1";
    end

    # 客戶端向服務器端發送的請求字符串;;
    request_String = Base.string(
        Line_1 * "\r\n",  # "GET / HTTP/1.1",
        "Host: " * Base.string(host) * ":" * Base.string(port) * "\r\n",  # "Host: 127.0.0.1:8000",
        "Connection: keep-alive" * "\r\n",  # "close", # 'keep-alive' 維持客戶端和服務端的鏈接關係，當一個網頁打開完成後，客戶端和服務器之間用於傳輸 HTTP 數據的 TCP 鏈接不會關閉，如果客戶端再次訪問這個服務器上的網頁，會繼續使用這一條已經建立的鏈接;
        "Cookie: " * cookie_value * "\r\n",  # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
        "Authorization: " * authorization_value * "\r\n",  # "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
        "Accept-Charset: utf-8" * "\r\n",
        # "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9" * "\r\n",
        "Accept-Language: zh-TW,zh;q=0.9" * "\r\n",  # "zh-Hant-TW; q=0.8, zh-Hant; q=0.7, zh-Hans-CN; q=0.7, zh-Hans; q=0.5, en-US, en; q=0.3";
        "Content-Type:" * "text/html, text/plain; charset=utf-8" * "\r\n",  # 響應數據類型;
        # "Content-Type: text/plain, text/html; charset=utf-8" * "\r\n",  # "application/x-www-form-urlencoded; charset=utf-8"
        # "Cache-Control: no-cache" * "\r\n",
        # "Upgrade: " * "HTTP/1.0, HTTP/1.1, HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11" * "\r\n",
        # "Accept: " * "*/*" * "\r\n",
        # "Accept-Encoding: gzip, deflate, br" * "\r\n",
        "Content-Length: " * Base.string(request_data_String_len) * "\r\n",
        # "sec-ch-ua: \"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"",
        # "sec-ch-ua-mobile: 0",
        # "Upgrade-Insecure-Requests: 1",
        # "Purpose: prefetch",
        # "Sec-Fetch-Site: none",
        # "Sec-Fetch-Mode: navigate",
        # "Sec-Fetch-User: 1",
        # "Sec-Fetch-Dest: document",
        "Date: " * Base.string(now_date) * "\r\n",  # "2021/8/22 02:02:33"，服務端向客戶端返回響應的時間;
        "User-Agent: " * UserAgent * "\r\n",  # "Julia-1.6.2 Sockets.connect."，"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36";
        "From: " * requestFrom * "\r\n\r\n",  # "user@email.com",
        request_data_String
    );

    request_URL::Core.String = "";
    if URL !== ""
        request_URL = URL;
    else
        # Base.Unicode.lowercase(requestProtocol);  # 轉小寫字母;
        if Authorization !== ":" && Authorization !== "" && host !== "" && port !== "" && Core.Int64(port) !== Core.Int64(0) && requestPath !== ""
            if IPVersion === "IPv6"
                request_URL = Base.string(Base.Unicode.lowercase(requestProtocol)) * "://" * Authorization * "@[" * Base.string(host) * "]:" * Base.string(port) * requestPath;
            elseif IPVersion === "IPv4"
                request_URL = Base.string(Base.Unicode.lowercase(requestProtocol)) * "://" * Authorization * "@" * Base.string(host) * ":" * Base.string(port) * requestPath;
            else
            end
        elseif host !== "" && port !== "" && Core.Int64(port) !== Core.Int64(0) && requestPath !== ""
            if IPVersion === "IPv6"
                request_URL = Base.string(Base.Unicode.lowercase(requestProtocol)) * "//[" * Base.string(host) * "]:" * Base.string(port) * requestPath;
            elseif IPVersion === "IPv4"
                request_URL = Base.string(Base.Unicode.lowercase(requestProtocol)) * "://" * Base.string(host) * ":" * Base.string(port) * requestPath;
            else
            end
        end
    end
    # println(request_URL);

    # 客戶端鏈接器 client;
    # Sockets.connect([host], port::Integer) -> TCPSocket;
    # Connect to the host host on port port.
    # Sockets.connect(path::AbstractString) -> PipeEndpoint;
    # Connect to the named pipe / UNIX domain socket at path.
    # 使用 Sockets.connect(name_pipe) 函數建立的客戶端鏈接，返回值為 Base.PipeEndPoint 類型，查看 client.status = 3 ，表示 statusOpen，各狀態碼的意義如下：
    # const StatusUninit      = 0;  # handle is allocated, but not initialized
    # const StatusInit        = 1;  # handle is valid, but not connected/active
    # const StatusConnecting  = 2;  # handle is in process of connecting
    # const StatusOpen        = 3;  # handle is usable
    # const StatusActive      = 4;  # handle is listening for read/write/connect events
    # const StatusClosing     = 5;  # handle is closing / being closed
    # const StatusClosed      = 6;  # handle is closed
    # const StatusEOF         = 7;  # handle is a TTY that has seen an EOF event
    # const StatusPaused      = 8;  # handle is Active, but not consuming events, and will transition to Open if it receives an event

    # 建立客戶端與服務器端鏈接;
    # name_pipe::Core.String = "\\\\.\\pipe\\mypipe-1";  # 定義一個命名管道，使用一個字符串即可命名一個管道;
    # client = Sockets.connect(name_pipe);
    client = Sockets.connect(host, port);
    # client = Sockets.connect(Sockets.IPv4("0.0.0.0"), 5000);
    # client = Sockets.connect(Sockets.IPv6("0:0:0:0:0:0:0:0"), 5000);
    # println(client.status);

    # Base.write(client, "Hello World from the Echo Julia Sockets.connect Client.");  # 執行客戶端向服務器端寫入一段字符串的動作;
    # println(client, "Hello World from the Echo Julia Sockets.connect Client.");  # 執行客戶端向服務器端寫入一段字符串的動作;
    # Base.@async while Base.isopen(client)
    #     # 客戶端，將從管道中讀取到數據後，直接在標準輸出設備（Base.stdout）輸出;
    #     Base.write(Base.stdout, Base.readline(client, keep=true));
    #     Base.close(client);  # # 客戶端傳輸完數據後，需要手動關閉管道，否則會一直保持鏈接而占用住管道;
    # end


    # 如果與服務器端鏈接正常，則由客戶端端向服務器端發送請求數據;
    # if Base.isopen(client)
    if Base.iswritable(client)
        try
            # Base.write(Base.stdout, request_String);
            Base.write(client, request_String);  # 向服務器端發送請求值;
        catch err
            # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
            if Core.isa(err, Core.InterruptException)

                print("\n");
                # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                println("[ Ctrl ] + [ c ] received, will be stop the TCP Client.");

                # # 打印進程被調用數目;
                # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                #     if isConcurrencyHierarchy === "Multi-Processes"

                #         # Base.haskey(collection, key) -> Bool
                #         # workNum = "worker";
                #         for k in Base.keys(total_worker_called_number)
                #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                #         end
                #         # println(workNum);

                #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                #         # Base.haskey(collection, key) -> Bool
                #         # workNum = "worker";
                #         for k in Base.keys(total_worker_called_number)
                #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                #         end
                #         # println(workNum);

                #     end

                #     total_worker_called_number = Core.nothing;
                # end

                # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                #     # Base.haskey(collection, key) -> Bool
                #     # for k in Base.keys(worker_queues_Dict)
                #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                #     # end

                #     worker_queues_Dict = Core.nothing;
                # end

                println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                # Base.exit(0);
                return ["", client, total_worker_called_number];

            else

                # Base.write(stderr, err);
                # Base.write(Base.stdout, err, "\n");
                println(err);
                # Base.close(client);  # 中斷當前的這個鏈接;
                # Base.sleep(time_sleep);
                # continue;
                # break;
            end
        end
    end

    # 讀取服務器端返回的響應數據，獲取服務器端返回的響應頭和響應數據;
    response_head = Base.Dict{Core.String, Core.Any}();
    response_body::Core.String = "";  # Core.Array{Core.Any, 1}();
    response_data_Array = Core.Array{Core.Any, 1}();

    # Base.@async while Base.isopen(client) end
    if Base.isreadable(client)
        try
            # println(countlines(client; eol="\r\n"));  # countlines(client; eol="\r\n") 返回管道中數據的行數;

            # 獲取客戶端發送的請求頭和請求數據;
            # for line in eachline(client; keep=false)
            #     # Base.write(Base.stdout, line * "\n");
            #     # print(line, "\n");
            #     Base.push!(response_data_Array, line);  # 使用 push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
            # end

            response_data_Array = Base.readlines(client; keep=false);

            # response_data_String = Base.read(client, Core.String);
            # for x in split(response_data_String, "\r\n")
            #     x = Base.convert(Core.String, x);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
            #     x = Base.strip(x);  # 使用 Base.strip(str) 去除字符串首尾兩端的空格;
            #     push!(response_data_Array, x);  # 使用 push! 函數在數組末尾追加推入新元素;
            # end

            # while Base.isreadable(client)
            #     response_data_line_String = Base.readline(client, keep=false);
            #     # response_data_line_String = Base.strip(response_data_line_String);  # 使用 Base.strip(str) 去除字符串首尾兩端的空格;
            #     push!(response_data_Array, response_data_line_String);  # 使用 push! 函數在數組末尾追加推入新元素;
            # end

            # # 獲取服務器發送的響應頭和響應數據，注意前面的四個方法讀完數據後，會自動將鏈接關閉，只有下面這個方法讀完之後不會關閉鏈接;
            # begin
            #     response_data_String::Core.String = "";
            #     response_data_bytes_Array = Core.Array{Core.Any, 1}();
            #     # Base.readavailable(stream)
            #     # Read available buffered data from a stream. Actual I/O is performed only if no data has already been buffered. The result is a Vector{UInt8}.
            #     # Warning: The amount of data returned is implementation-dependent; for example it can depend on the internal choice of buffer size. Other functions such as read should generally be used instead.
            #     response_data_bytes_Array = Base.readavailable(client);  # 使用 Base.readavailable() 函數讀取鏈接中的數據，但不關閉鏈接，返回值為二進制 byte 字節形式的編碼構成的數組;

            #     if Base.length(response_data_bytes_Array) > 0
            #         for i = 1:Base.length(response_data_bytes_Array)
            #             if Base.isvalid(Char, response_data_bytes_Array[i])
            #                 # 使用 Base.isvalid() 函數判斷 byte 碼字節形式是否能夠轉換成爲對應的某個字符;
            #                 response_data_String = response_data_String * Core.Char(response_data_bytes_Array[i]);  # 使用 Core.Char() 函數將 byte 碼字節形式轉換成爲對應的某個字符;
            #             else
            #                 continue;
            #             end
            #         end
            #     end
            #     # println(response_data_String);

            #     response_data_SubString_Array = Core.Array{Core.Any, 1}();
            #     if Base.length(response_data_String) > 0
            #         if Base.occursin("\r\n", response_data_String)
            #             response_data_SubString_Array = Base.split(response_data_String, "\r\n", keepempty=true);  # 將字符串使用特定標志分割爲數組;
            #         else
            #             response_data_SubString_Array = [response_data_String];
            #         end
            #     end

            #     if Base.length(response_data_SubString_Array) > 0
            #         for j = 1:Base.length(response_data_SubString_Array)
            #             temp = Base.strip(response_data_SubString_Array[j]);  # 去掉字符串首尾兩端的空格;
            #             temp = Base.convert(Core.String, temp);  # 將 substring 類型的變量轉換爲 Core.String 字符串類型;
            #             # temp = Base.string(temp);
            #             push!(response_data_Array, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量，使用 Base.strip(str) 去除字符串首尾兩端的空格，使用 push! 函數在數組末尾追加推入新元素;
            #         end
            #     end
            #     # println(response_data_Array);
            # end

        catch err

            # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
            if Core.isa(err, Core.InterruptException)

                print("\n");
                # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                println("[ Ctrl ] + [ c ] received, will be stop the TCP Client.");

                # # 打印進程被調用數目;
                # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                #     if isConcurrencyHierarchy === "Multi-Processes"

                #         # Base.haskey(collection, key) -> Bool
                #         # workNum = "worker";
                #         for k in Base.keys(total_worker_called_number)
                #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                #         end
                #         # println(workNum);

                #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                #         # Base.haskey(collection, key) -> Bool
                #         # workNum = "worker";
                #         for k in Base.keys(total_worker_called_number)
                #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                #         end
                #         # println(workNum);

                #     end

                #     total_worker_called_number = Core.nothing;
                # end

                # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                #     # Base.haskey(collection, key) -> Bool
                #     # for k in Base.keys(worker_queues_Dict)
                #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                #     # end

                #     worker_queues_Dict = Core.nothing;
                # end

                println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                # Base.exit(0);
                return ["", client, total_worker_called_number];

            else

                # Base.write(stderr, err);
                # Base.write(Base.stdout, err, "\n");
                println(err);
                # response_data_String = "{\"Server_say\":\"" * "Client read response data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                # cookie_string = "";  # * "; expires=" * Base.string(after_1_Days) * "; path=/;";  # 拼接 cookie 字符串值;
    
                # Base.close(client);  # 中斷當前的這個鏈接;
                # # Base.sleep(time_sleep);
                # continue;
                # # break;
            end
        end
        # println(response_data_Array);
    end

    # 解析客戶端發送的請求頭和請求數據，將之分類保存為結構體類型數據，便於後續提取特定請求頭參數處理數據;
    if Base.length(response_data_Array) > 0

        # response_head = Base.Dict{Core.String, Core.String}();
        spaceIndex = Core.Int64(Base.length(response_data_Array));
        # response_body::Core.String = "";  # Core.Array{Core.Any, 1}();

        for i = 1:Base.length(response_data_Array)
            # Base.write(Base.stdout, response_data_Array[i] * "\n");
            # print(response_data_Array[i], "\n");

            if response_data_Array[i] === "\r\n\r\n" || response_data_Array[i] === ""
                # Base.Unicode.isspace(response_data_Array[i])
                spaceIndex = Core.Int64(i);
                head_key = "Line_" * Base.string(i);
                response_head[head_key] = response_data_Array[i];
                continue;
                # break;
            end

            if Core.Int64(i) === Core.Int64(1)
                head_key = "Line_" * Base.string(i);
                response_head[head_key] = response_data_Array[i];  # "HTTP/1.1 200 6KuL5rGC5oiQ5Yqf OK.";
                # println(response_data_Array[i]);  # "HTTP/1.1 200 6KuL5rGC5oiQ5Yqf OK.";
                if Base.occursin(" ", response_data_Array[i])
                    # Line_1_Array = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                    Line_1_SubString = Base.split(response_data_Array[i], " ");
                    if Base.length(Line_1_SubString) === 2
                        response_head["response_Protocol"] = Base.strip(Base.convert(Core.String, Line_1_SubString[1]));
                        response_head["response_statusCode"] = Base.strip(Base.convert(Core.String, Line_1_SubString[2]));
                        # response_head["response_statusMessage"] = Base.strip(Base.convert(Core.String, Line_1_SubString[3]));
                    elseif Base.length(Line_1_SubString) >= 3
                        response_head["response_Protocol"] = Base.strip(Base.convert(Core.String, Line_1_SubString[1]));
                        response_head["response_statusCode"] = Base.strip(Base.convert(Core.String, Line_1_SubString[2]));
                        temp = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                        for i = 3:Base.length(Line_1_SubString)
                            Base.push!(temp, Line_1_SubString[i]);
                        end
                        response_head["response_statusMessage"] = Base.join(temp, " ");
                    else
                        return ["error", "response_statusCode", "The response status code could not be resolved."];
                    end
                end
            end

            if Core.Int64(i) > Core.Int64(1) && Core.Int64(i) < Core.Int64(spaceIndex)

                # 是否爲空白字符，函數 Base.Unicode.isspace(c:: AbstractChar)，包括 ASCII 字符的 '\t', '\n', '\v', '\f', '\r', ' ', 及 Latin-1 字符 U+0085, 和 Unicode 類別為 Zs 的字符;
                # println("sock line" * Base.string(i) * ": " * Base.string(response_data_Array[i]));  # 通過 Base.ARGS 數組獲取從控制臺傳入的參數;
                # 使用 Core.isa(response_data_Array[i], Core.String) 函數判断「元素(变量实例)」是否属于「集合(变量类型集)」之间的关系，使用 Base.typeof(response_data_Array[i]) <: Core.String 方法判断「集合」是否包含于「集合」之间的关系，或 Base.typeof(response_data_Array[i]) === Core.String 方法判斷傳入的參數是否為 String 字符串類型;
                if Core.isa(response_data_Array[i], Core.String) && !(response_data_Array[i] === "\r\n\r\n" || response_data_Array[i] === "")
                    # Base.Unicode.isspace(response_data_Array[i])

                    if Base.occursin(":", response_data_Array[i])

                        ARGSArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                        # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                        # 函數 Base.split(response_data_Array[i], ':') 表示用等號字符'='分割字符串為數組;
                        for x in Base.split(response_data_Array[i], ':')
                            x = Base.convert(Core.String, x);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                            Base.push!(ARGSArray, Base.strip(x));  # 使用 Base.push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
                        end

                        if Base.length(ARGSArray) > 1

                            ARGSValue = "";
                            # ARGSValue = Base.join(Base.deleteat!(Base.deepcopy(ARGSArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                            for j = 2:Base.length(ARGSArray)
                                if j === 2
                                    ARGSValue = ARGSValue * ARGSArray[j];  # 使用星號*拼接字符串;
                                else
                                    ARGSValue = ARGSValue * ":" * ARGSArray[j];
                                end
                            end

                            # try
                            #     eval(:(
                            #         begin
                            #             Sys.eval("global " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                            #             # Sys.eval("local " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                            #             # println($ARGSIArray[1]);
                            #         end
                            #     ));
                            # catch err
                            #     println(err);
                            # end

                            if ARGSArray[1] !== ""
                                # if ARGSValue !== ""
                                    response_head[ARGSArray[1]] = ARGSValue;
                                    # print(ARGSArray[1], ARGSValue, "\n");
                                # end
                            else
                                head_key = "Line_" * Base.string(i);
                                response_head[head_key] = ARGSValue;
                            end
                        end
                    else
                        head_key = "Line_" * Base.string(i);
                        response_head[head_key] = response_data_Array[i];
                    end
                end
            end

            if Core.Int64(i) > Core.Int64(spaceIndex)
                if Core.Int64(i) === Core.Int64(spaceIndex + 1)
                    response_body = response_body * response_data_Array[i];  # 使用星號*拼接字符串;
                else
                    response_body = response_body * "\r\n" * response_data_Array[i];
                end
            end
        end
    end
    # println(response_head);
    # println(response_body);

    # 解析響應頭中的 "Www-Authenticate" 和 "set-Cookie" 參數值，用以獲取服務器端發送的響應賬號和密碼進行權限驗證;
    response_Authorization::Core.String = "";  # 解析獲取服務器響應頭中的賬號密碼 "Www-Authenticate" 參數;
    response_Cookie::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數;
    response_Cookie_name::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數;
    response_Cookie_value::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數;
    request_Key::Core.String = "";  # 判斷如果服務器端發送的響應的賬號密碼來源，如果響應頭 response.headers["Cookie"] 參數不爲空則使用 response.headers["Cookie"] 的參數值作爲服務器端的賬號密碼，如果響應頭 response.headers["Cookie"] 參數為空但 response.headers["Authorization"] 參數不爲空則使用 response.headers["Authorization"] 的參數值，作爲解析服務器端返回的響應值中賬號密碼的來源;
    request_Nikename::Core.String = "";  # 提取賬號密碼;
    request_Password::Core.String = "";  # 提取賬號密碼;

    if Base.length(response_head) > 0
        # Base.isa(response_head, Base.Dict)

        # 解析獲取客戶端請求頭中的 "Set-Cookie" 參數;
        # response_Cookie::Core.String = "";
        # response_Cookie_name::Core.String = "";
        # response_Cookie_value::Core.String = "";
        if Base.haskey(response_head, "Set-Cookie")
            # println("response Headers Set-Cookie: ", response_head["Set-Cookie"]);  # 打印客戶端請求頭中的 Set-Cookie 參數值;
            # println(Base.typeof(response_head["Set-Cookie"]));
            response_Cookie = response_head["Set-Cookie"];
            # response_Cookie = Core.String(Base64.base64decode(response_head["Set-Cookie"]));  # 讀取客戶端發送的請求頭中的 Set-Cookie 參數值，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
            # response_head["Set-Cookie"] = Base64.base64encode(response_Cookie; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
            # 判斷客戶端發送的請求頭中 Set-Cookie 參數值中是否包含"="符號，如果包含"="符號，則首先使用"="符號分割 Set-Cookie 參數值字符串，否則直接使用 Set-Cookie 參數值字符串;

            if Base.isa(response_head["Set-Cookie"], Core.String) && Base.occursin(";", response_head["Set-Cookie"])
                cookieArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                # 函數 Base.split(response_head["Set-Cookie"], '=') 表示用等號字符'='分割字符串為數組;
                for x in Base.split(response_head["Set-Cookie"], ';')
                    temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                    temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                    Base.push!(cookieArray, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                end

                if Base.isa(cookieArray[1], Core.String) && Base.occursin("=", cookieArray[1])

                    cookieArray_Value = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                    # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                    # 函數 Base.split(cookieArray[1], '=') 表示用等號字符'='分割字符串為數組;
                    for x in Base.split(cookieArray[1], '=')
                        temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                        temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                        Base.push!(cookieArray_Value, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                    end
    
                    if Base.length(cookieArray_Value) > 1
    
                        cookieValue = "";
                        # cookieArray_Value = Base.join(Base.deleteat!(Base.deepcopy(cookieArray_Value), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        for j = 2:Base.length(cookieArray_Value)
                            if j === 2
                                cookieValue = cookieValue * cookieArray_Value[j];  # 使用星號*拼接字符串;
                            else
                                cookieValue = cookieValue * "=" * cookieArray_Value[j];
                            end
                        end
    
                        # try
                        #     eval(:(
                        #         begin
                        #             Sys.eval("global " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # Sys.eval("local " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # println($ARGSIArray[1]);
                        #         end
                        #     ));
                        # catch err
                        #     println(err);
                        # end

                        # println("response Headers Set-Cookie: ", cookieArray_Value[1] * "=" * Core.String(Base64.base64decode(cookieValue)));  # 打印請求頭中的使用函數 Base64.base64decode() 解密之後的用戶 "Set-Cookie"，# 需要事先加載原生的 Base64 模組：using Base64 模組;;
                        response_Cookie_name = Base.convert(Core.String, Base.strip(cookieArray_Value[1]))
                        response_Cookie_value = Core.String(Base64.base64decode(cookieValue));  # 讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                        # Cookie = response_Cookie_name * "=" * Base64.base64encode(response_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
                        # println("response Set-Cookie " * response_Cookie_name * ": ", response_Cookie_value);
                    end
                else
                    response_Cookie_value = Core.String(Base64.base64decode(cookieArray[1]));  # 讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                end
            else
                response_Cookie_value = Core.String(Base64.base64decode(response_head["Set-Cookie"]));  # 讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
            end
        end
        # println("response Headers Set-Cookie: [ " * response_Cookie * " ].");
        # println(response_Cookie_name * ": [ " * response_Cookie_value * " ].");
        # println("Request Cookie: [ " * Cookie * " ].");

        # 解析獲取客戶端請求頭中的賬號密碼 "Www-Authenticate" 參數;
        # response_Authorization::Core.String = "";
        # "Basic realm="domain name -> username:password"
        if Base.haskey(response_head, "Www-Authenticate")
            # println("response Headers Www-Authenticate: ", response_head["Www-Authenticate"]);
            # println(Base.typeof(response_head["Www-Authenticate"]));

            if Base.isa(response_head["Www-Authenticate"], Core.String) && Base.occursin(' ', response_head["Www-Authenticate"])

                authorArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                # 函數 Base.split(response_head["Www-Authenticate"], ' ') 表示用等號字符' '分割字符串為數組;
                for x in Base.split(response_head["Www-Authenticate"], ' ')
                    temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                    temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                    # temp = Base.string(temp);
                    Base.push!(authorArray, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                end

                if Base.isa(authorArray[2], Core.String) && Base.occursin('=', authorArray[2])
    
                    authorArray_realm = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                    # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                    # 函數 Base.split(authorArray[2], ' ') 表示用等號字符' '分割字符串為數組;
                    for x in Base.split(authorArray[2], '=')
                        temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                        temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                        # temp = Base.string(temp);
                        Base.push!(authorArray_realm, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                    end
    
                    if Base.length(authorArray_realm) > 1
    
                        authorValue = "";
                        # authorArray_realm = Base.join(Base.deleteat!(Base.deepcopy(authorArray_realm), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        for j = 2:Base.length(authorArray_realm)
                            if j === 2
                                authorValue = authorValue * authorArray_realm[j];  # 使用星號*拼接字符串;
                            else
                                authorValue = authorValue * "=" * authorArray_realm[j];
                            end
                        end
    
                        # try
                        #     eval(:(
                        #         begin
                        #             Sys.eval("global " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # Sys.eval("local " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # println($ARGSArray[1]);
                        #         end
                        #     ));
                        # catch err
                        #     println(err);
                        # end
    
                        if authorArray_realm[1] === "realm" && Base.isa(authorValue, Core.String) && Base.length(authorValue) > 0
                            # !(authorValue === "\r\n\r\n" || authorValue === "")
                            # Base.Unicode.isspace(authorValue)
                            # println("response Headers Www-Authenticate: ", authorArray_realm[1] * " " * Core.String(Base64.base64decode(authorValue)));  # 打印請求頭中的使用函數 Base64.base64decode() 解密之後的用戶賬號和密碼參數"Www-Authenticate"，# 需要事先加載原生的 Base64 模組：using Base64 模組;;
                            # response_Authorization = Core.String(Base64.base64decode(authorValue));  # 讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                            # response_head["Www-Authenticate"] === "Basic" * " " * authorArray_realm[1] * "=" * Base64.base64encode(response_Authorization; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
    
                            # response_Authorization = Base.convert(Core.String, Base.strip(Base.strip(authorValue), ['"']));  # Base.strip(str) 去除字符串首尾兩端的空格;
                            # # Authorization = Base.convert(Core.String, Base.strip(Base.split(response_Authorization, "->")[2]));

                            temp_realm = Base.convert(Core.String, Base.strip(Base.strip(authorValue), ['"']));  # Base.strip(str) 去除字符串首尾兩端的空格;
                            if Base.isa(temp_realm, Core.String) && Base.occursin("->", temp_realm)
                
                                authorArray_realm_domain = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                                # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                                # 函數 Base.split(, ' ') 表示用等號字符' '分割字符串為數組;
                                for x in Base.split(temp_realm, "->")
                                    temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                                    temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                                    # temp = Base.string(temp);
                                    Base.push!(authorArray_realm_domain, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                                end
                
                                if Base.length(authorArray_realm_domain) > 1
                
                                    authorValue_realm_Key = "";
                                    # authorArray_realm_domain = Base.join(Base.deleteat!(Base.deepcopy(authorArray_realm_domain), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                                    for j = 2:Base.length(authorArray_realm_domain)
                                        if j === 2
                                            authorValue_realm_Key = authorValue_realm_Key * authorArray_realm_domain[j];  # 使用星號*拼接字符串;
                                        else
                                            authorValue_realm_Key = authorValue_realm_Key * "->" * authorArray_realm_domain[j];
                                        end
                                    end
                
                                    # try
                                    #     eval(:(
                                    #         begin
                                    #             Sys.eval("global " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                                    #             # Sys.eval("local " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                                    #             # println($ARGSArray[1]);
                                    #         end
                                    #     ));
                                    # catch err
                                    #     println(err);
                                    # end
                
                                    if authorArray_realm_domain[1] === "domain" && Base.isa(authorValue_realm_Key, Core.String) && Base.length(authorValue_realm_Key) > 0
                                        # !(authorValue_realm_Key === "\r\n\r\n" || authorValue_realm_Key === "")
                                        # Base.Unicode.isspace(authorValue_realm_Key)
                                        # println("response Headers Www-Authenticate: ", authorArray_realm_domain[1] * " " * Core.String(Base64.base64decode(authorValue_realm_Key)));  # 打印請求頭中的使用函數 Base64.base64decode() 解密之後的用戶賬號和密碼參數"Www-Authenticate"，# 需要事先加載原生的 Base64 模組：using Base64 模組;;
                                        # response_Authorization = Core.String(Base64.base64decode(authorValue_realm_Key));  # 讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                                        # response_head["Www-Authenticate"] === "Basic" * " " * authorArray_realm_domain[1] * "=" * Base64.base64encode(response_Authorization; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
                
                                        response_Authorization = Base.convert(Core.String, Base.strip(authorValue_realm_Key));  # Base.strip(str) 去除字符串首尾兩端的空格;
                                        # Authorization = Base.convert(Core.String, Base.strip(Base.split(response_Authorization, "->")[2]));
                                    end
                                end
                            else
                                response_Authorization = Base.convert(Core.String, Base.strip(temp_realm));  # Base.strip(str) 去除字符串首尾兩端的空格;
                                # Authorization = Base.convert(Core.String, Base.strip(Base.split(response_Authorization, "->")[2]));
                            end
                        end
                    end
                end
            end
        end
        # println("response Headers Www-Authenticate: [ " * response_Authorization * " ].");
        # println("Authenticate: [ " * Authorization * " ].");

        # 判斷如果服務器端發送的響應的賬號密碼來源，如果響應頭 response.headers["Cookie"] 參數不爲空則使用 response.headers["Cookie"] 的參數值作爲服務器端的賬號密碼，如果響應頭 response.headers["Cookie"] 參數為空但 response.headers["Authorization"] 參數不爲空則使用 response.headers["Authorization"] 的參數值，作爲解析服務器端返回的響應值中賬號密碼的來源;
        # request_Key::Core.String = "";
        if response_Cookie !== "" && response_Cookie_value !== ""
            if Base.occursin("->", response_Cookie_value)
                request_Key = Base.convert(Core.String, Base.strip(Base.split(response_Cookie_value, "->")[2]));
            end
        elseif response_Authorization !== ""
            if Base.occursin("->", response_Authorization)
                request_Key = Base.convert(Core.String, Base.strip(Base.split(response_Authorization, "->")[2]));
            end
        end
        # println("response Key: [ " * request_Key * " ].");

        # 提取賬號密碼;
        # request_Nikename::Core.String = "";
        # request_Password::Core.String = "";
        if request_Key !== "" && Base.occursin(":", request_Key)

            KeyArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
            # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
            # 函數 Base.split(request_Key, ':') 表示用等號字符'='分割字符串為數組;
            for x in Base.split(request_Key, ':')
                x = Base.convert(Core.String, x);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                Base.push!(KeyArray, Base.strip(x));  # 使用 Base.push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
            end

            if Core.Int64(Base.length(KeyArray)) === Core.Int64(1)
                request_Nikename = KeyArray[1];
            end

            if Base.length(KeyArray) > 1

                KeyValue = "";
                # KeyValue = Base.join(Base.deleteat!(Base.deepcopy(KeyArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                for j = 2:Base.length(KeyArray)
                    if j === 2
                        KeyValue = KeyValue * KeyArray[j];  # 使用星號*拼接字符串;
                    else
                        KeyValue = KeyValue * ":" * KeyArray[j];
                    end
                end

                # try
                #     eval(:(
                #         begin
                #             Sys.eval("global " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                #             # Sys.eval("local " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                #             # println($KeyArray[1]);
                #         end
                #     ));
                # catch err
                #     println(err);
                # end

                request_Nikename = KeyArray[1];
                request_Password = KeyValue;
                # println("response Nikename: [ " * KeyArray[1] * " ], response Password: [ " * KeyValue * " ].");
            end
        else
            request_Nikename = request_Key;
            # request_Password = "";
        end
        # println("response Nikename: [ " * request_Nikename * " ], response Password: [ " * request_Password * " ].");
    end

    if Base.length(response_head) > 0 && Base.haskey(response_head, "response_statusCode")

        if Base.string(response_head["response_statusCode"]) === "401"

            # Cookie = response_Cookie_name * "=" * Base64.base64encode(response_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
            # Authorization = request_Key;

            Cookie_2::Core.String = "";  # 拼接從服務器返回的 Cookie 參數;
            if response_Cookie_name === ""
                Cookie_2 = Base64.base64encode(response_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
            else
                Cookie_2 = response_Cookie_name * "=" * Base64.base64encode(response_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
            end

            Base.write(Base.stdout, "服務器返回響應狀態碼「401」要求身份驗證.\n");
            Base.write(Base.stdout, "「 nikename:password 」 ->  ");
            request_Key_line_String = Base.readline(Base.stdin, keep=false);
            # request_Key_line_String = Base.strip(request_Key_line_String);  # 使用 Base.strip(str) 去除字符串首尾兩端的空格;
            # request_Key_line_String = Base.convert(Core.String, request_Key_line_String);  # 使用 Base.convert(Core.String,str) 將變量解析為字符串類型;
            # println(request_Key_line_String);

            result = TCP_Client(
                host,  # "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
                port;  # 0 ~ 65535，監聽埠號（端口）;
                IPVersion=IPVersion,  # "IPv6"、"IPv4";
                postData=postData,  # postData::Core.Union{Core.String, Base.Dict{Core.Any, Core.Any}}，"{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"time\":\"" * Base.string(now_date) * "\"}";
                URL=URL,  # "http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1;
                requestPath=requestPath,
                requestMethod=requestMethod,  # "POST",  # "GET"; # 請求方法;
                requestProtocol=requestProtocol,
                # time_out=time_out,  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
                Authorization=request_Key_line_String,  # request_Key,  # "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
                Cookie=Cookie_2,  # # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
                requestFrom=requestFrom,
                # do_Function=do_Function,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Response";
                # session=session,  # Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => TCP_Server.key),  # 保存網站的 Session 數據;
                # number_Worker_threads=number_Worker_threads,  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
                # time_sleep=time_sleep,  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
                # isConcurrencyHierarchy=isConcurrencyHierarchy,  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
                # worker_queues_Dict=worker_queues_Dict,  # 記錄每個綫程纍加的被調用運算的總次數;
                # total_worker_called_number=total_worker_called_number  # 記錄每個綫程纍加的被調用運算的總次數;
            );

            return result;
        end

        if Base.string(response_head["response_statusCode"]) === "200"

            # Base.close(client);

            if Base.haskey(response_head, "response_statusMessage")
                return ["success", Base.string(response_head["response_statusCode"], " ", response_head["response_statusMessage"]), response_body];
            else
                return ["success", Base.string(response_head["response_statusCode"]), response_body];
            end

            # # 無并發，就在當前主進程（Master）中，處理輸入任務隊列;
            # if Core.Int8(number_Worker_threads) <= Core.Int8(0)

            #     # 記錄每個協程（Task）纍加的被調用運算的總次數;
            #     # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            #     # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
            #     if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid()))
            #         # global total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid())]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
            #         total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid())]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
            #     else
            #         # global total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
            #         total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
            #     end

            #     result = "";
            #     try
            #         result = do_Function(response_body);
            #         # Base.write(Base.stdout, response_data_String);
            #     catch err

            #         # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
            #         if Core.isa(err, Core.InterruptException)

            #             print("\n");
            #             # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
            #             # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
            #             println("[ Ctrl ] + [ c ] received, will be stop the TCP Client.");

            #             # # 打印進程被調用數目;
            #             # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

            #             #     if isConcurrencyHierarchy === "Multi-Processes"

            #             #         # Base.haskey(collection, key) -> Bool
            #             #         # workNum = "worker";
            #             #         for k in Base.keys(total_worker_called_number)
            #             #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
            #             #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
            #             #         end
            #             #         # println(workNum);

            #             #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

            #             #         # Base.haskey(collection, key) -> Bool
            #             #         # workNum = "worker";
            #             #         for k in Base.keys(total_worker_called_number)
            #             #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
            #             #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
            #             #         end
            #             #         # println(workNum);

            #             #     end

            #             #     total_worker_called_number = Core.nothing;
            #             # end

            #             # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
            #             # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

            #             #     # Base.haskey(collection, key) -> Bool
            #             #     # for k in Base.keys(worker_queues_Dict)
            #             #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
            #             #     # end

            #             #     worker_queues_Dict = Core.nothing;
            #             # end

            #             println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            #             println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

            #             # Base.exit(0);
            #             return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, stop the TCP Client."];

            #         else

            #             # Base.write(stderr, err);
            #             # Base.write(Base.stdout, err, "\n");
            #             println("自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
            #             println(err);
            #             # println(err.msg);
            #             # println(Base.typeof(err));
            #             # Base.close(client);  # 中斷當前的這個鏈接;
            #             # Base.sleep(time_sleep);
            #             return ["error", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), Base.string(err)];
            #         end
            #     end
            #     return ["success", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), result];
            #     # println(result);
            # end

            # # 開啓并發，在子進程（Worker）中，處理輸入任務隊列;
            # if Core.Int8(number_Worker_threads) > Core.Int8(0)

            #     if isConcurrencyHierarchy === "Tasks"
            #         result = "";
            #         try
            #             # 創建一個子協程（worker task）;
            #             f() = do_Function(response_body);
            #             workerTask = Core.Task(f);  # 創建一個協程（任務）task;
            #             workerTask.sticky = false;

            #             Base.schedule(workerTask);  # 用 Base.schedule(t::Task, [val]; error=false) 函數把未啓動的協程(Task)加入等待執行的隊列並啓動，隨後會自動返回 done 狀態，表示已經執行完畢;
            #             # Base.wait(workerTask);  # 阻塞主進程後面的代碼執行，直到該子協程 workerTask 運行完畢;
            #             # 用 istaskstarted(taskname) 和 istaskdone(taskname) 查看 Task 是否已經啓動和結束。Task 有五個狀態：runnable（可被啓動）, waiting（阻塞等待中）, queued（正被調度中）, done（執行結束）, failed（執行異常結束）。Julia 内部有一個調度器，負責維護 task 運行隊列;

            #             # 讀出子協程(task)返回的結果;
            #             result = Base.fetch(workerTask);

            #             # 記錄每個協程（Task）纍加的被調用運算的總次數;
            #             # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            #             # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
            #             if Base.haskey(total_worker_called_number, Base.string(workerTask[1]))
            #                 # global total_worker_called_number[Base.string(workerTask[1])] = Core.UInt64(total_worker_called_number[Base.string(workerTask[1])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
            #                 total_worker_called_number[Base.string(workerTask[1])] = Core.UInt64(total_worker_called_number[Base.string(workerTask[1])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
            #             else
            #                 # global total_worker_called_number[Base.string(workerTask[1])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
            #                 total_worker_called_number[Base.string(workerTask[1])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
            #             end
            #             # if Base.haskey(total_worker_called_number, Base.string(result_Dict["taskID"]))
            #             #     # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
            #             #     total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
            #             # else
            #             #     # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
            #             #     total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
            #             # end

            #         catch err

            #             # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
            #             if Core.isa(err, Core.InterruptException)

            #                 print("\n");
            #                 # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
            #                 # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
            #                 println("[ Ctrl ] + [ c ] received, will be stop the TCP Client.");

            #                 # # 打印進程被調用數目;
            #                 # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

            #                 #     if isConcurrencyHierarchy === "Multi-Processes"

            #                 #         # Base.haskey(collection, key) -> Bool
            #                 #         # workNum = "worker";
            #                 #         for k in Base.keys(total_worker_called_number)
            #                 #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
            #                 #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
            #                 #         end
            #                 #         # println(workNum);

            #                 #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

            #                 #         # Base.haskey(collection, key) -> Bool
            #                 #         # workNum = "worker";
            #                 #         for k in Base.keys(total_worker_called_number)
            #                 #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
            #                 #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
            #                 #         end
            #                 #         # println(workNum);

            #                 #     end

            #                 #     total_worker_called_number = Core.nothing;
            #                 # end

            #                 # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
            #                 # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

            #                 #     # Base.haskey(collection, key) -> Bool
            #                 #     # for k in Base.keys(worker_queues_Dict)
            #                 #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
            #                 #     # end

            #                 #     worker_queues_Dict = Core.nothing;
            #                 # end

            #                 println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            #                 println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

            #                 # Base.exit(0);
            #                 return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, stop the TCP Client."];

            #             else

            #                 # Base.write(stderr, err);
            #                 # Base.write(Base.stdout, err, "\n");
            #                 println("多協程並發（multi-task）時，工作協程（worker-task）中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
            #                 println(err);
            #                 # println(err.msg);
            #                 # println(Base.typeof(err));
            #                 # Base.close(client);  # 中斷當前的這個鏈接;
            #                 # Base.sleep(time_sleep);
            #                 return ["error", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), Base.string(err)];
            #             end
            #         end
            #         return ["success", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), result];
            #         # println(result);
            #     end

            #     # 需要注意，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
            #     if isConcurrencyHierarchy === "Multi-Threading"
            #         result = "";
            #         try
            #             # 創建一個子綫程（worker thread）;
            #             # 需要注意，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
            #             # workerThread = Base.Threads.@spawn begin
            #             #     do_Function(response_body);
            #             # end
            #             workerThread = Base.Threads.@spawn do_Function(response_body);;
            #             # r = Base.fetch(workerThread);  # 等待讀取子綫程運行完畢後的返回值，阻塞後面的代碼執行;
            #             # Base.wait(workerThread);  # 阻塞主進程後面的代碼執行，直到該子綫程 workerThread 運行完畢;

            #             # 讀出子協程(task)返回的結果;
            #             result = Base.fetch(workerThread);

            #             # 記錄每個協程（Task）纍加的被調用運算的總次數;
            #             # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            #             # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
            #             if Base.haskey(total_worker_called_number, Base.string(workerThread[1]))
            #                 # global total_worker_called_number[Base.string(workerThread[1])] = Core.UInt64(total_worker_called_number[Base.string(workerThread[1])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
            #                 total_worker_called_number[Base.string(workerThread[1])] = Core.UInt64(total_worker_called_number[Base.string(workerThread[1])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
            #             else
            #                 # global total_worker_called_number[Base.string(workerThread[1])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
            #                 total_worker_called_number[Base.string(workerThread[1])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
            #             end

            #         catch err

            #             # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
            #             if Core.isa(err, Core.InterruptException)

            #                 print("\n");
            #                 # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
            #                 # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
            #                 println("[ Ctrl ] + [ c ] received, will be stop the TCP Client.");

            #                 # # 打印進程被調用數目;
            #                 # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

            #                 #     if isConcurrencyHierarchy === "Multi-Processes"

            #                 #         # Base.haskey(collection, key) -> Bool
            #                 #         # workNum = "worker";
            #                 #         for k in Base.keys(total_worker_called_number)
            #                 #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
            #                 #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
            #                 #         end
            #                 #         # println(workNum);

            #                 #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

            #                 #         # Base.haskey(collection, key) -> Bool
            #                 #         # workNum = "worker";
            #                 #         for k in Base.keys(total_worker_called_number)
            #                 #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
            #                 #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
            #                 #         end
            #                 #         # println(workNum);

            #                 #     end

            #                 #     total_worker_called_number = Core.nothing;
            #                 # end

            #                 # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
            #                 # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

            #                 #     # Base.haskey(collection, key) -> Bool
            #                 #     # for k in Base.keys(worker_queues_Dict)
            #                 #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
            #                 #     # end

            #                 #     worker_queues_Dict = Core.nothing;
            #                 # end

            #                 println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            #                 println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

            #                 # Base.exit(0);
            #                 return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, stop the TCP Client."];

            #             else

            #                 # Base.write(stderr, err);
            #                 # Base.write(Base.stdout, err, "\n");
            #                 println("多綫程並發（multi-task）時，工作綫程（worker-thread）中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
            #                 println(err);
            #                 # println(err.msg);
            #                 # println(Base.typeof(err));
            #                 # Base.close(client);  # 中斷當前的這個鏈接;
            #                 # Base.sleep(time_sleep);
            #                 return ["error", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), Base.string(err)];
            #             end
            #         end
            #         return ["success", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), result];
            #         # println(result);
            #     end

            #     # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            #     if isConcurrencyHierarchy === "Multi-Processes"

            #         # try
            #         #     # Base.Threads.@spawn
            #         #     # Create and run a Task on any available thread. To wait for the task to finish, call wait on the result of this macro, or call fetch to wait and then obtain its return value.
            #         #     # Values can be interpolated into @spawn via $, which copies the value directly into the constructed underlying closure. This allows you to insert the value of a variable, isolating the asynchronous code from changes to the variable's value in the current task.
            #         #     # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            #         #     wp = Base.Threads.@spawn funcTask(
            #         #         # worker_data_Dict,
            #         #         do_Function,
            #         #         main_to_sub_channel,
            #         #         sub_to_main_channel,
            #         #         control_number_Queues_channel
            #         #     );
            #         #     # r = Base.fetch(wp);
            #         # catch err

            #         #     # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
            #         #     if Core.isa(err, Core.InterruptException)
            #         #         println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            #         #         # Base.exit(0);
            #         #         return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, stop the TCP Client."];
            #         #     else

            #         #         # Base.write(stderr, err);
            #         #         # Base.write(Base.stdout, err, "\n");
            #         #         println("多進程並發（multi-task）時，工作進程（worker-process）中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
            #         #         println(err);
            #         #         # println(err.msg);
            #         #         # println(Base.typeof(err));
            #         #         # Base.close(client);  # 中斷當前的這個鏈接;
            #         #         # Base.sleep(time_sleep);
            #         #         return ["error", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), Base.string(err)];
            #         #     end
            #         # end
            #         # return ["success", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), result];
            #         # # println(result);
            #     end
            # end
        end
    else
        # Base.close(client);
        return ["error", "response_statusCode", "The response status code could not be resolved."];
    end
end


# # 媒介服務器函數客戶端（前端） TCP_Client() 使用説明;
# webPath = Base.string(Base.Filesystem.joinpath(Base.string(Base.Filesystem.abspath(".")), "html"));  # 服務器運行的本地硬盤根目錄，可以使用函數：上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__;
# # webPath = Base.string(Base.Filesystem.abspath("."));  # 服務器運行的本地硬盤根目錄，可以使用函數：上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__;
# host = Sockets.IPv6("::1"); # ::Core.String = "127.0.0.1", # "0.0.0.0" or "localhost"; 監聽主機域名 Host domain name;
# IPVersion = "IPv6";  # "IPv6"、"IPv4";
# port = Core.UInt64(10001);  # ::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String} = Core.UInt8(8000),  # 0 ~ 65535， 監聽埠號（端口）;
# URL = "";  # "http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1;
# requestPath = "/";
# requestMethod = "GET";  # "POST",  # "GET"; # 請求方法;
# requestProtocol = "HTTP";
# # time_out = Core.Float16(0);  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
# Authorization = "username:password";  # 自定義的訪問網站簡單驗證用戶名和密碼 "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
# Cookie_name = "session_id";
# Cookie_value = "request_Key->username:password";
# # Cookie = Cookie_name * "=" * Cookie_value;  # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
# Cookie = Cookie_name * "=" * Base64.base64encode(Cookie_value; context=nothing);  # "Session_ID=request_Key->username:password"，將漢字做Base64轉碼Base64.base64encode()，需要事先加載原生的 Base64 模組：using Base64 模組;
# # println(Core.String(Base64.base64decode(Cookie_value)));
# # println("Request Cook: ", Cookie);
# requestFrom = "user@email.com";
# # do_Function = do_Response;  # (argument) -> begin argument; end; 匿名函數對象，用於接收執行對根目錄(/)的 POST 請求處理功能的函數 "do_Response";
# # session = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => key);  # 保存網站的 Session 數據;
# # number_Worker_threads = Core.UInt8(Base.Sys.CPU_THREADS);  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Base.Sys.CPU_THREADS,  # Core.UInt8(0)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
# # time_sleep = Core.Float16(0);  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
# # isConcurrencyHierarchy = "Tasks";  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
# # print("isConcurrencyHierarchy: ", isConcurrencyHierarchy, "\n");
# # 當 isConcurrencyHierarchy = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
# # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
# # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
# # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
# # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;
# # TCP_Server = TCP_Server;
# # worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
# # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
# postData = Base.Dict{Core.String, Core.Any}("Client_say" => "Julia-1.6.2 Sockets.connect.");  # ::Core.Union{Core.String, Base.Dict}，postData::Core.Union{Core.String, Base.Dict{Core.Any, Core.Any}}，"{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"time\":\"" * Base.string(now_date) * "\"}";

# # a = Array{Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}(Core.nothing, 3);
# a = TCP_Client(
#     host,  # ::Core.String = "127.0.0.1",  # "0.0.0.0" or "localhost"; 監聽主機域名 Host domain name;
#     port;  # ::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String} = 8000, # 0 ~ 65535， 監聽埠號（端口）;
#     IPVersion=IPVersion,  # "IPv6"、"IPv4";
#     postData=postData,  # ::Core.Union{Core.String, Base.Dict} = "";  # Base.Dict{Core.String, Core.Any}("Client_say" => "Julia-1.6.2 Sockets.connect."),  # postData::Core.Union{Core.String, Base.Dict{Core.Any, Core.Any}}，"{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"time\":\"" * Base.string(now_date) * "\"}";
#     URL=URL,  # "http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1;
#     requestPath=requestPath,  # ::Core.String = "/",
#     requestMethod=requestMethod,  # ::Core.String = "GET",  # "POST",  # "GET"; # 請求方法;
#     requestProtocol=requestProtocol,  # ::Core.String = "HTTP",
#     # time_out=time_out,  # ::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
#     Authorization=Authorization,  # ::Core.String = ":",  # "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
#     Cookie=Cookie,  # ::Core.String = "",  # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
#     requestFrom=requestFrom,  # ::Core.String = "user@email.com",
#     # do_Function=do_Function,  # (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Response";
#     # session=session,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => TCP_Server.key),  # 保存網站的 Session 數據;
#     # number_Worker_threads=number_Worker_threads,  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.UInt8(0),  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
#     # time_sleep=time_sleep,  # ::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
#     # isConcurrencyHierarchy=isConcurrencyHierarchy,  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
#     # worker_queues_Dict=worker_queues_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
#     # total_worker_called_number=total_worker_called_number,  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
# );
# # println(typeof(a))
# println(a[1])
# println(a[2])
# println(a[3])




# HTTP_Server_「第三方擴展包 HTTP.jl 的 HTTP.listen!() 函數」;
# https://github.com/JuliaWeb/HTTP.jl
# 如果想臨時更換pkg工具下載鏡像源，在julia解釋器環境命令行輸入命令：
# julia> ENV["JULIA_PKG_SERVER"]="https://mirrors.bfsu.edu.cn/julia/static"
# 或者：
# Windows Powershell: $env:JULIA_PKG_SERVER = 'https://pkg.julialang.org'
# Linux/macOS Bash: export JULIA_PKG_SERVER="https://pkg.julialang.org"
# using HTTP;  # 導入第三方擴展包「HTTP」，用於創建 HTTP server 服務器，需要在控制臺先安裝第三方擴展包「HTTP」：julia> using Pkg; Pkg.add("HTTP") 成功之後才能使用;
# using JSON;  # 導入第三方擴展包「JSON」，用於轉換JSON字符串為字典 Base.Dict 對象，需要在控制臺先安裝第三方擴展包「JSON」：julia> using Pkg; Pkg.add("JSON") 成功之後才能使用;
function http_Server(
    host::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4},  # Sockets.IPv6(0) or Sockets.IPv6("::1") or "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
    port::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String};  # 0 ~ 65535，監聽埠號（端口）;
    do_Function = (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_GET_root_directory";
    key::Core.String = ":",  # "username:password",  # 自定義的訪問網站簡單驗證用戶名和密碼;
    session::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => http_Server.key),  # 保存網站的 Session 數據;
    number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.UInt8(0),  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
    time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
    readtimeout::Core.Int = Core.Int(0),  # 客戶端請求數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
    isConcurrencyHierarchy::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
    # worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
    total_worker_called_number::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}(),  # 記錄每個綫程纍加的被調用運算的總次數;
    verbose::Core.Bool = Core.Bool(false)  # 將連接資訊記錄到輸出到顯示器 Base.stdout 標準輸出流，log connection information to stdout;
) ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}
    # ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}

    # # print("當前協程 task: ", Base.current_task(), "\n");
    # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
    # print("當前綫程 thread 的 ID: ", Base.Threads.threadid(), "\n");
    # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
    # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
    # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
    # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
    # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
    # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
    # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
    # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
    # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
    # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
    # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
    # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
    # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

    # println(Base.Sys.CPU_THREADS)  # 4 可用 CPU 數;
    # println(Base.Filesystem.ispath(Base.Filesystem.pwd()))  # true 判斷目錄是否存在;
    # println(Base.Filesystem.isfile(Base.Filesystem.pwd()))  # true 判斷是否為文檔;
    # println(Base.Filesystem.isdir(Base.Filesystem.pwd()))  # true 判斷是否為文件夾;
    # println(Base.Sys.BINDIR)  # C:\Program Files\Julia 1.5.1\bin;
    # println(Base.PROGRAM_FILE)  # c:\Users\china\Documents\Node.js\Criss\jl\tempCodeRunnerFile.jl;
    # println(Base.Filesystem.basename(Base.Filesystem.pwd()))  # Criss;
    # # "File_Directory_and_Path";
    # println(Base.Filesystem.homedir())  # C:\Users\china;
    # println(Base.Filesystem.pwd())  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath("."))  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js\Criss;
    # # 获取路径的目录;
    # println(Base.Filesystem.dirname(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js;
    # # "/Users/juliauser/Functions_Scripts_Codes_Pipelines/Julia_Codes";
    # # 路径的末端分割;
    # println(Base.Filesystem.splitdir(Base.Filesystem.pwd()));
    # # ("c:\\Users\\china\\Documents\\Node.js", "Criss");
    # # 路径的合成;
    # println(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "temp", "intermediary_write_NodeJS.txt"));  # c:\Users\china\Documents\Node.js\temp\intermediary_write_NodeJS.txt;
    # # Base.Filesystem.cd()  # 更換工作目錄;
    # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl"))
    # # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl").mode) # 返回值為 Core.UInt64 類型數值，例如 Core.UInt64(33206);


    # 判斷傳入的參數用於指定監聽主機的 IP 地址或域名 host 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(host) 判斷 host 變量是否已經被定義過;
    if !Base.@isdefined(host) || host === "" || host === Core.nothing
        # local host = "127.0.0.1",  # "0.0.0.0" or "localhost";
        # local host = Core.nothing;  # 置空;
        println("用於指定監聽主機的 IP 地址或域名「host ∈ ", Base.typeof(host), "」不能被識別.");
        return ["error", host, "argument [ host = " * Base.string(host) * " ] typeof error, no defined."];  # "用於指定監聽主機的 IP 地址或域名「host = " * Base.string(Base.typeof(host)) * "」不能被識別.";
    elseif !Core.isa(host, Core.String) && !Core.isa(host, Sockets.IPv6) && !Core.isa(host, Sockets.IPv4)
        # 使用 Core.isa(host, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(host) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(host) === Core.String 方法判別 host 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Core.Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於指定監聽主機的 IP 地址或域名「host ∈ ", Base.typeof(host), "」不合法，只接受輸入主機 IP 地址或域名字符串或 Sockets.IPv6 類型或 Sockets.IPv4 類型.");
        return ["error", host, "argument [ host = " * Base.string(host) * " ] typeof error, not String or IPv6 or IPv4."];  # ["error", host, "用於指定監聽主機的 IP 地址或域名「host = " * Base.string(Base.typeof(host)) * "」不合法，只接受輸入主機 IP 地址或域名字符串."];
    end
    # host = Sockets.IPv6(host);  # Sockets.IPv4("0.0.0.0"); Sockets.IPv6("0:0:0:0:0:0:0:0");

    # 判斷傳入的參數用於指定監聽主機埠號（端口） port 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(port) 判斷 port 變量是否已經被定義過;
    if !Base.@isdefined(port) || port === "" || port === Core.nothing
        # local port = Core.UInt8(5000);  # Core.UInt8 類型，用於指定監聽主機埠號（端口），自定義函數檢查輸入合規性 CheckString(port, 'arabic_numerals');
        # port = Core.UInt8(5000);  # Core.UInt8 類型，用於指定監聽主機埠號（端口），自定義函數檢查輸入合規性 CheckString(port, 'arabic_numerals');
        # local port = Core.nothing;  # 置空;
        println("傳入的參數用於指定監聽主機埠號（端口）「port ∈ ", Base.typeof(port), "」不能被識別.");
        return "argument [ port = " * Base.string(port) * " ] typeof error, no defined."  # "用於指定監聽主機埠號（端口）「port = " * Base.string(Base.typeof(port)) * "」不能被識別.";
    elseif !(Base.typeof(port) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(port, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(port) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(port) <: Core.UInt64 方法判別 port 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Core.Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於指定監聽主機埠號（端口）「port ∈ ", Base.typeof(port), "」不是一個數值類型的變量.");
        return "argument [ port = " * Base.string(port) * " ] typeof error, not Float and not Int."  # "用於指定監聽主機埠號（端口）「port = " * Base.string(Base.typeof(port)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的參數用於記錄服務器訪問賬號密碼的變量 key 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(key) 判斷 key 變量是否已經被定義過;
    if !Base.@isdefined(key) || key === Core.nothing
        # local key = "username:password";
        # local key = Core.nothing;  # 置空;
        println("用於記錄服務器訪問賬號密碼的變量「key ∈ ", Base.typeof(key), "」不能被識別.");
        return ["error", key, "argument [ key = " * Base.string(key) * " ] typeof error, no defined."];  # "用於記錄服務器訪問賬號密碼的變量「key = " * Base.string(Base.typeof(key)) * "」不能被識別.";
    elseif !Core.isa(key, Core.String)
        # 使用 Core.isa(key, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(key) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(key) === Core.String 方法判別 key 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Core.Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於記錄服務器訪問賬號密碼的變量「key ∈ ", Base.typeof(key), "」不合法，只接受輸入「username:password」形式的字符串.");
        return ["error", key, "argument [ key = " * Base.string(key) * " ] typeof error, not String."];  # ["error", key, "用於記錄服務器訪問賬號密碼的變量「key = " * Base.string(Base.typeof(key)) * "」不合法，只接受輸入「username:password」形式的字符串."];
    end

    # 判斷傳入的參數用於記錄服務器 Session 數據的字典變量 session 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(session) 判斷 session 變量是否已經被定義過;
    if !Base.@isdefined(session) || session === "" || session === Core.nothing
        # session = Base.Dict{Core.String, Core.String}("request_Key->username:password" => key);  # 用於記錄服務器 Session 數據的字典變量;        
        println("用於記錄服務器 Session 數據的字典變量「session ∈ ", Base.typeof(session), "」不能被識別.");
        return ["error", session, "argument [ session ∈ " * Base.string(session) * " ] typeof error, no defined."];  # "用於保存服務器 Session 數據的字典變量「session ∈ " * Base.string(Base.typeof(session)) * "」不能被識別.";
    elseif !(Base.typeof(session) <: Base.Dict)
        # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Core.Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於記錄服務器 Session 數據的字典變量「session ∈ ", Base.typeof(session), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
        return ["error", session, "argument [ session ∈ " * Base.string(Base.typeof(session)) * " ] typeof error, not Dict."];  # ["error", session, "用於記錄服務器 Session 數據的字典變量「session ∈ " * Base.string(Base.typeof(session)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    end

    # # 判斷傳入的參數用於具體執行處理客戶端 POST 請求數據的函數 do_POST 是否已定義且為函數，使用函數 Base.@isdefined(do_POST) 判斷 do_POST 變量是否已經被定義過;
    # if !Base.@isdefined(do_POST) || do_POST === "" || do_POST === Core.nothing
    #     # local do_POST = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     do_POST = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # local do_POST = Core.nothing;  # 置空;
    #     # println("用於具體執行處理客戶端 POST 請求數據的函數「do_POST ∈ ", Base.typeof(do_POST), "」不能被識別.");
    #     # return "argument [ do_POST = " * Base.string(do_POST) * " ] typeof error, no defined."  # "用於具體執行處理客戶端 POST 請求數據的函數「do_POST = " * Base.string(Base.typeof(do_POST)) * "」不能被識別.";
    # elseif !(Base.typeof(do_POST) <: Core.Function)
    #     # 使用 Core.isa(do_POST, Core.Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_POST) <: Core.Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_POST) <: Core.Function 方法判別 do_POST 變量的類型是否包含於函數Core.Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Core.Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於具體執行處理客戶端 POST 請求數據的函數「do_POST ∈ ", Base.typeof(do_POST), "」不是一個函數類型的變量.");
    #     return "argument [ do_POST = " * Base.string(do_POST) * " ] typeof error, not Core.Function."  # "用於具體執行處理客戶端 POST 請求數據的函數「do_POST = " * Base.string(Base.typeof(do_POST)) * "」不是一個函數類型的變量.";

    #     # try
    #     #     if length(methods(do_POST)) > 0
    #     #         global do_POST = do_data;
    #     #     else
    #     #         # global do_POST = Core.nothing;  # 置空;
    #     #         global do_POST = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     end
    #     # catch err
    #     #     # println(err);
    #     #     # println(Base.typeof(err));
    #     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
    #     #     if Core.isa(err, Core.UndefVarError)
    #     #         println(err.var, " not defined.");
    #     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
    #     #         # global do_POST = Core.nothing;  # 置空;
    #     #         global do_POST = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     else
    #     #         println(err);
    #     #     end
    #     # finally
    #     #     # global do_POST = Core.nothing;  # 置空;
    #     #     # global do_POST = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # end
    # end

    # 判斷傳入的參數用於具體執行處理客戶端請求數據的函數 do_Function 是否已定義且為函數，使用函數 Base.@isdefined(do_Function) 判斷 do_Function 變量是否已經被定義過;
    if !Base.@isdefined(do_Function) || do_Function === "" || do_Function === Core.nothing
        # local do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # local do_Function = Core.nothing;  # 置空;
        println("用於具體執行處理客戶端請求數據的函數「do_Function ∈ ", Base.typeof(do_Function), "」不能被識別.");
        return "argument [ do_Function = " * Base.string(do_Function) * " ] typeof error, no defined."  # "用於具體執行處理客戶端請求數據的函數「do_Function = " * Base.string(Base.typeof(do_Function)) * "」不能被識別.";
    elseif !(Base.typeof(do_Function) <: Core.Function)
        # 使用 Core.isa(do_Function, Core.Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_Function) <: Core.Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_Function) <: Core.Function 方法判別 do_Function 變量的類型是否包含於函數Core.Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於具體執行處理客戶端請求數據的函數「do_Function ∈ ", Base.typeof(do_Function), "」不是一個函數類型的變量.");
        return "argument [ do_Function ∈ " * Base.string(Base.typeof(do_Function)) * " ] typeof error, not Core.Function."  # "用於具體執行處理客戶端請求數據的函數「do_Function ∈ " * Base.string(Base.typeof(do_Function)) * "」不是一個函數類型的變量.";

        # try
        #     if length(methods(do_Function)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的自定義多綫程并發數目參數 number_Worker_threads 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(number_Worker_threads) 判斷 number_Worker_threads 變量是否已經被定義過;
    if !Base.@isdefined(number_Worker_threads) || number_Worker_threads === "" || number_Worker_threads === Core.nothing
        # local number_Worker_threads = Core.UInt8(0);  # Core.UInt8 類型，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
        # number_Worker_threads = Core.UInt8(0);  # Core.UInt8 類型，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
        # local number_Worker_threads = Core.nothing;  # 置空;
        println("傳入的參數，指定的變量「number_Worker_threads ∈ ", Base.typeof(number_Worker_threads), "」不能被識別.");
        return "argument [ number_Worker_threads = " * Base.string(number_Worker_threads) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「number_Worker_threads = " * Base.string(Base.typeof(number_Worker_threads)) * "」不能被識別.";
    elseif !(Base.typeof(number_Worker_threads) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(number_Worker_threads, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判別 number_Worker_threads 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Core.Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「number_Worker_threads ∈ ", Base.typeof(number_Worker_threads), "」不是一個數值類型的變量.");
        return "argument [ number_Worker_threads = " * Base.string(number_Worker_threads) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「number_Worker_threads = " * Base.string(Base.typeof(number_Worker_threads)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的自定義系統暫停時長參數 time_sleep 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(time_sleep) 判斷 time_sleep 變量是否已經被定義過;
    if !Base.@isdefined(time_sleep) || time_sleep === "" || time_sleep === Core.nothing
        # local time_sleep = Core.Float64(0.02);  # Core.Float64 類型變量，20 毫秒，系統暫停等待時長;
        # time_sleep = Core.Float64(0);  # Float64 類型變量，0.02 === 20 毫秒，系統暫停等待時長;
        # local time_sleep = Core.nothing;  # 置空;
        println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不能被識別.");
        return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不能被識別.";
    elseif !(Base.typeof(time_sleep) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(time_sleep, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判別 time_sleep 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不是一個數值類型的變量.");
        return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的自定義客戶端請求數據讀取超時，單位：（秒）參數 readtimeout 是否已定義且為整數類型 Core.Int，使用函數 Base.@isdefined(readtimeout) 判斷 readtimeout 變量是否已經被定義過;
    if !Base.@isdefined(readtimeout) || readtimeout === "" || readtimeout === Core.nothing
        # local readtimeout = Core.Int(0);  # Core.Int 類型，客戶端請求數據讀取超時，單位：（秒），自定義函數檢查輸入合規性 CheckString(readtimeout, 'arabic_numerals');
        # readtimeout = Core.Int(0);  # Core.Int 類型，客戶端請求數據讀取超時，單位：（秒），自定義函數檢查輸入合規性 CheckString(readtimeout, 'arabic_numerals');
        # local readtimeout = Core.nothing;  # 置空;
        println("傳入的參數，指定的變量「readtimeout ∈ ", Base.typeof(readtimeout), "」不能被識別.");
        return "argument [ readtimeout = " * Base.string(readtimeout) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「readtimeout = " * Base.string(Base.typeof(readtimeout)) * "」不能被識別.";
    elseif !(Base.typeof(readtimeout) <: Core.Int)
    # elseif !(Base.typeof(readtimeout) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(readtimeout, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(readtimeout) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(readtimeout) <: Core.UInt64 方法判別 readtimeout 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「readtimeout ∈ ", Base.typeof(readtimeout), "」不是一個數值類型的變量.");
        return "argument [ readtimeout = " * Base.string(readtimeout) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「readtimeout = " * Base.string(Base.typeof(readtimeout)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的參數用於指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量 isConcurrencyHierarchy 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(isConcurrencyHierarchy) 判斷 isConcurrencyHierarchy 變量是否已經被定義過;
    if !Base.@isdefined(isConcurrencyHierarchy) || isConcurrencyHierarchy === "" || isConcurrencyHierarchy === Core.nothing
        # local isConcurrencyHierarchy = "Tasks" || "Multi-Threading" || "Multi-Processes";
        # local isConcurrencyHierarchy = Core.nothing;  # 置空;
        println("指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy ∈ ", Base.typeof(isConcurrencyHierarchy), "」不能被識別.");
        return ["error", isConcurrencyHierarchy, "argument [ isConcurrencyHierarchy = " * Base.string(isConcurrencyHierarchy) * " ] typeof error, no defined."];  # "指定監聽并發的層次（多綫程、多進程）的變量「isConcurrencyHierarchy = " * Base.string(Base.typeof(isConcurrencyHierarchy)) * "」不能被識別.";
    elseif !Core.isa(isConcurrencyHierarchy, Core.String) || (isConcurrencyHierarchy !== "Tasks" && isConcurrencyHierarchy !== "Multi-Threading" && isConcurrencyHierarchy !== "Multi-Processes")
        # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy ", Base.typeof(isConcurrencyHierarchy), "」不合法，只接受輸入：\"Tasks\" || \"Multi-Threading\" 兩個值.");
        return ["error", isConcurrencyHierarchy, "argument [ isConcurrencyHierarchy = " * Base.string(isConcurrencyHierarchy) * " ] typeof error, not String."];  # ["error", isConcurrencyHierarchy, "指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy = " * Base.string(Base.typeof(isConcurrencyHierarchy)) * "」不合法，只接受輸入：\"Tasks\" || \"Multi-Threading\" 兩個值."];
    end

    # # 判斷傳入的參數用於保存每個綫程的字典變量 worker_queues_Dict 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(worker_queues_Dict) 判斷 worker_queues_Dict 變量是否已經被定義過;
    # if !Base.@isdefined(worker_queues_Dict) || worker_queues_Dict === "" || worker_queues_Dict === Core.nothing
    #     # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # 保存每個工作子綫程;
    #     worker_queues_Dict = Base.Dict{Core.String, Core.UInt64}();  # 保存每個工作子綫程;
    #     # println("用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ ", Base.typeof(worker_queues_Dict), "」不能被識別.");
    #     # return ["error", worker_queues_Dict, "argument [ worker_queues_Dict ∈ " * Base.string(worker_queues_Dict) * " ] typeof error, no defined."];  # "用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * "」不能被識別.";
    # elseif !(Base.typeof(worker_queues_Dict) <: Base.Dict)
    #     # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Core.Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ ", Base.typeof(worker_queues_Dict), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
    #     return ["error", worker_queues_Dict, "argument [ worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * " ] typeof error, not Dict."];  # ["error", worker_queues_Dict, "用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    # end

    # 判斷傳入的參數用於記錄每個綫程纍加的被調用運算的總次數的字典變量 total_worker_called_number 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(total_worker_called_number) 判斷 total_worker_called_number 變量是否已經被定義過;
    if !Base.@isdefined(total_worker_called_number) || total_worker_called_number === "" || total_worker_called_number === Core.nothing
        # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
        total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
        # println("用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ ", Base.typeof(total_worker_called_number), "」不能被識別.");
        # return ["error", total_worker_called_number, "argument [ total_worker_called_number ∈ " * Base.string(total_worker_called_number) * " ] typeof error, no defined."];  # "用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * "」不能被識別.";
    elseif !(Base.typeof(total_worker_called_number) <: Base.Dict)
        # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Core.Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ ", Base.typeof(total_worker_called_number), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
        return ["error", total_worker_called_number, "argument [ total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * " ] typeof error, not Dict."];  # ["error", total_worker_called_number, "用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    end

    # 判斷傳入的自定義將連接資訊記錄到輸出到顯示器 Base.stdout 標準輸出流參數 verbose 是否已定義且為整數類型 Core.Bool，使用函數 Base.@isdefined(verbose) 判斷 verbose 變量是否已經被定義過;
    if !Base.@isdefined(verbose) || verbose === "" || verbose === Core.nothing
        # local verbose = Core.Bool(true);  # Core.Bool 類型，將連接資訊記錄到輸出到顯示器 Base.stdout 標準輸出流;
        # verbose = Core.Bool(true);  # Core.Bool 類型，將連接資訊記錄到輸出到顯示器 Base.stdout 標準輸出流;
        # local verbose = Core.nothing;  # 置空;
        println("傳入的參數，指定的變量「verbose ∈ ", Base.typeof(verbose), "」不能被識別.");
        return "argument [ verbose = " * Base.string(verbose) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「verbose = " * Base.string(Base.typeof(verbose)) * "」不能被識別.";
    elseif !(Base.typeof(verbose) <: Core.Bool)
        # 使用 Core.isa(number_Worker_threads, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判別 number_Worker_threads 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Core.Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Core.Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「verbose ∈ ", Base.typeof(verbose), "」不是一個數值類型的變量.");
        return "argument [ verbose = " * Base.string(verbose) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「verbose = " * Base.string(Base.typeof(verbose)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    sslconfig = Core.nothing;  # Provide an MbedTLS.SSLConfig object to handle ssl connections.SSLConfig(certfile, keyfile) Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl verification (useful for testing). Construct a custom SSLConfig object with MbedTLS;
    reuseaddr::Core.Bool = false;  # 允許多個伺服器偵聽同一埠，allow multiple servers to listen on the same port. Not supported on some OS platforms. Can check HTTP.Servers.supportsreuseaddr();
    provide_IOServer = Core.nothing;  # ::Base.IOServer = Core.nothing，提供要偵聽的對象，允許手動關閉或配置伺服器套接字，provide an IOServer object to listen on; allows manually closing or configuring the server socket;
    # verbose::Core.Bool = Core.Bool(false);  # ::Core.Bool = false 將連接資訊記錄到輸出到顯示器 Base.stdout 標準輸出流，log connection information to stdout;
    # readtimeout::Core.Int = Core.Int(0);  # ::Core.Int = 0 客戶端請求數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;

    # 自定義函數，指定響應狀態碼對應的文本信息;
    function statusMessage(response_statusCode::Core.Int64)::Core.String
        # response_statusCode::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8}

        # response_statusCode = 200;  // 401, "需要身份驗證賬號密碼", 301, "重定向";
        statusMessage_CN::Core.String = "";
        statusMessage_EN::Core.String = "";
        if response_statusCode === 200
            statusMessage_CN = "請求成功";
            statusMessage_EN = "OK.";
        elseif response_statusCode === 301
            statusMessage_CN = "服務器要求重定向";
            statusMessage_EN = "Moved Permanently.";
        elseif response_statusCode === 307
            statusMessage_CN = "服務器要求臨時重定向";
            statusMessage_EN = "Temporary Redirect.";
        elseif response_statusCode === 401
            statusMessage_CN = "服務器要求客戶端身份驗證出具賬號密碼";
            statusMessage_EN = "Unauthorized.";
        elseif response_statusCode === 404
            statusMessage_CN = "請求路徑(URL)錯誤";
            statusMessage_EN = "Page not Found !";
        elseif response_statusCode === 405
            statusMessage_CN = "請求方法錯誤";
            statusMessage_EN = "Method Not Allowed !";
        else
            statusMessage_CN = "";
            statusMessage_EN = "";
        end

        # using Base64;  # 導入 Julia 的原生標準模組「Base64」，用於按照 Base64 方式編解碼字符串;
        # Base64.base64encode(writefunc, args...; context=nothing)
        # Base64.base64encode(args...; context=nothing)
        # Given a write-like function writefunc, which takes an I/O stream as its first argument, base64encode(writefunc, args...) calls writefunc to write args... to a base64-encoded string, and returns the string. base64encode(args...) is equivalent to base64encode(write, args...): it converts its arguments into bytes using the standard write functions and returns the base64-encoded string.
        # The optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to writefunc or write.
        # Base64.base64decode(string)
        # Decode the base64-encoded string and returns a Base.Vector{UInt8} of the decoded bytes.
        # Core.String(s::AbstractString)
        # Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.
        # "5ZC+" === Base64.base64encode("吾"; context=nothing)
        # "吾" === Core.String(Base64.base64decode("5ZC+"))

        status_Message = Base64.base64encode(statusMessage_CN; context=nothing) * "," * statusMessage_EN;  # 需要事先加載原生的 Base64 模組：using Base64 模組;

        # statusMessage_EN_Array = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}();  # 聲明一個聯合類型的空1維數組;
        # # statusMessage_EN_Array = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
        # # 函數 Base.split(status_Message, ' ') 表示用等號字符 ' ' 分割字符串為數組;
        # for x in Base.split(status_Message, ' ')
        #     x = Base.convert(Core.String, x);  # 使用 convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
        #     Base.push!(statusMessage_EN_Array, x);  # 使用 push! 函數在數組末尾追加推入新元素;
        # end
        # if length(statusMessage_EN_Array) > 1

        #     statusMessage_EN_Value = "";
        #     # statusMessage_EN_Value = join(Base.deleteat!(Base.deepcopy(statusMessage_EN_Array), 1), " ");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(statusMessage_EN_Array, 1) 函數刪除第一個元素時候就不會改變原數組 statusMessage_EN_Array，否則為淺拷貝傳址複製，使用 deleteat!(statusMessage_EN_Array, 1) 刪除第一個元素的時候會影響原數組 statusMessage_EN_Array 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
        #     for j = 2:length(statusMessage_EN_Array)
        #         if j === 2
        #             statusMessage_EN_Value = statusMessage_EN_Value * statusMessage_EN_Array[j];  # 使用星號*拼接字符串;
        #         else
        #             statusMessage_EN_Value = statusMessage_EN_Value * " " * statusMessage_EN_Array[j];
        #         end
        #     end
        # end

        return status_Message;
    end

    # 自定義函數，用於格式化訪問日誌消息的功能，該函數應接受兩個參數 (io::IO, http::HTTP.Stream)，消息應寫入這兩個參數，並可用於從中查詢資訊;
    # access_log = (io::IO, http::HTTP.Stream) -> begin io; http; return; end,  # 用於格式化訪問日誌消息的功能，該函數應接受兩個參數 (io::IO, http::HTTP.Stream)，消息應寫入這兩個參數，並可用於從中查詢資訊，function for formatting access log messages. The function should accept two arguments, io::IO to which the messages should be written, and http::HTTP.Stream which can be used to query information from. See also @logfmt_str;
    function access_log(io::IO, http::HTTP.Stream)::Core.Int
        # io;
        # http;
        return 0;
    end

    # 自定義函數，用於在處理請求之前檢查接受的連接是否有效。例如，執行源IP過濾;
    # tcpisvalid = (tcp_socket::TCPSocket) -> begin tcp_socket; return true; end,  # 自定義函數 f(::TCPSocket)::Core.Bool，用於在處理請求之前檢查接受的連接是否有效。例如，執行源IP過濾，function f(::TCPSocket)::Bool to check if accepted connections are valid before processing requests. e.g. to do source IP filtering;
    function tcpisvalid(tcp_socket::TCPSocket)::Core.Bool
        # tcp_socket;
        return true;
    end

    # 自定義函數，指定伺服器關閉時要運行的一個或多個函數（例如，由 InterruptException）。請注意，如果將對象提供給關鍵字參數 IOServer、server 並由 Base.close(server) 關閉，則關閉函數將不會運行;
    # on_shutdown = (argument) -> begin argument; return; end,  # ::Union{Core.Function, Base.Vector{<:Core.Function}, Nothing} = Core.nothing, 伺服器關閉時要運行的一個或多個函數（例如，由 InterruptException）。請注意，如果將對象提供給關鍵字參數 IOServer、server 並由 Base.close(server) 關閉，則關閉函數將不會運行，one or more functions to be run if the server is closed (for example by an InterruptException). Note, shutdown function(s) will not run if an IOServer object is supplied to the server keyword argument and closed by close(server);
    function on_shutdown(argu::Core.Any)::Core.Int
        # argu;
        return 0;
    end

    # 自定義一個在進程退出前一刻調用的函數 f()，使用 Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并注冊為在對象終結的前一刻運行;
    function func_Exit()

        # if isMonitorThreadsOrProcesses === "Multi-Processes" || isMonitorThreadsOrProcesses === "Multi-Threading"

        #     RemoteChannel_Data_Dict = Base.Dict{Core.String, Core.Any}(
        #         # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
        #         "monitor_file" => monitor_file,
        #         "monitor_dir" => monitor_dir,
        #         # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
        #         "output_dir" => output_dir,
        #         "output_file" => output_file,
        #         "temp_cache_IO_data_dir" => temp_cache_IO_data_dir,
        #         "to_executable" => to_executable,
        #         "to_script" => to_script,
        #         "input_queues_array" => input_queues_array,
        #         "output_queues_array" => output_queues_array,
        #         "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
        #         "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
        #         "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
        #         "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
        #         "label" => "exit",
        #         "message" => "exit worker process."
        #     );

        #     if Base.isopen(rc2to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_file() > worker process-2 be exit.";
        #         Base.put!(rc2to, RemoteChannel_Data_Dict);
        #         Base.close(rc2to);
        #     end

        #     if Base.isopen(rc3to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_input_queues() > worker process-3 be exit.";
        #         Base.put!(rc3to, RemoteChannel_Data_Dict);
        #         Base.close(rc3to);
        #     end

        #     if Base.isopen(rc4to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_output_queues() > worker process-4 be exit.";
        #         Base.put!(rc4to, RemoteChannel_Data_Dict);
        #         Base.close(rc4to);
        #     end

        #     RemoteChannel_Data_Dict = Core.nothing;

        #     if Base.isready(rc2from)
        #         # from2rcDict = Base.take!(rc2from);
        #         for from2rcDict in rc2from
        #             # input_queues_array = from2rcDict["input_queues_array"];
        #             # output_queues_array = from2rcDict["output_queues_array"];
        #             if from2rcDict["label"] === "exit"
        #                 println(from2rcDict["message"]);
        #             end
        #         end
        #         # from2rcDict = Core.nothing;
        #     end

        #     if Base.isready(rc3from)
        #         # from3rcDict = Base.take!(rc3from);
        #         for from3rcDict in rc3from
        #             # input_queues_array = from3rcDict["input_queues_array"];
        #             # output_queues_array = from3rcDict["output_queues_array"];
        #             if from3rcDict["label"] === "exit"
        #                 println(from3rcDict["message"]);
        #             end
        #         end
        #         # from3rcDict = Core.nothing;
        #     end

        #     if Base.isready(rc4from)
        #         # from4rcDict = Base.take!(rc4from);
        #         for from4rcDict in rc4from
        #             # input_queues_array = from4rcDict["input_queues_array"];
        #             # output_queues_array = from4rcDict["output_queues_array"];
        #             if from4rcDict["label"] === "exit"
        #                 println(from4rcDict["message"]);
        #             end
        #         end
        #         # from4rcDict = Core.nothing;
        #     end
        # end
    end
    Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

    # 開啓并發，在子進程（Worker）中，處理輸入任務隊列;
    if Core.Int8(number_Worker_threads) > Core.Int8(0)

        # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.Task}();
        # # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
        # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;

        if isConcurrencyHierarchy === "Tasks" || isConcurrencyHierarchy === "Multi-Threading"

            # 創建通道(Channel);
            main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
            sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
            control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));  # 用於控制并發數目的通道，寫入一個元素相當於記錄一個啓動的子協程(task)，取出一個元素相當於一個子協程(task)執行完畢，如通道已經滿，則阻塞等待;
            # Base.put!(main_to_sub_channel, channel_message_Dict);  # 向通道(Channel)中寫入元素;
            # # Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
            # Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
            # Base.close(main_to_sub_channel);  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗;
        elseif isConcurrencyHierarchy === "Multi-Processes"

            # Distributed.addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers;
            # Distributed.addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers;
            # Distributed.addprocs(Base.Sys.CPU_THREADS; kwargs...) -> List of process identifiers;
            # Distributed.addprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers;
            Distributed.addprocs(number_Worker_threads);  # Base.Sys.CPU_THREADS; # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

            main_to_sub_channel = Distributed.RemoteChannel(()->Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads)), Distributed.myid());  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
            sub_to_main_channel = Distributed.RemoteChannel(()->Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads)), Distributed.myid());
            control_number_Queues_channel = Distributed.RemoteChannel(()->Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads)), Distributed.myid());  # 用於控制并發數目的通道，寫入一個元素相當於記錄一個啓動的子協程(task)，取出一個元素相當於一個子協程(task)執行完畢，如通道已經滿，則阻塞等待;
            # Base.put!(main_to_sub_channel, channel_message_Dict);  # 向通道(Channel)中寫入元素;
            # # Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
            # Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
            # Base.close(main_to_sub_channel);  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗;
            
            Distributed.@everywhere do_Function, main_to_sub_channel, sub_to_main_channel, control_number_Queues_channel;
            # Distributed.@everywhere do_Function = Base.deepcopy(do_Function);
            # Distributed.@everywhere read_file_do_Function = Base.deepcopy(read_file_do_Function);
            # Distributed.@everywhere include(Base.PROGRAM_FILE);  # Distributed.@everywhere include("./script.jl") 將當前正在執行的 Julia 脚本文檔發送到所有子進程可見並在所有子進程中載入，Base.PROGRAM_FILE 為當前正在執行的 Julia 脚本文檔絕對路徑;
        end
    end

    # 當選擇使用多協程（Task）并發運算時，在子協程（Task）中執行的函數;
    function funcTask(
        # worker_data_Dict::Base.Dict{Core.String, Core.Any},
        do_Function,
        main_to_sub_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
        sub_to_main_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
        control_number_Queues_channel::Base.Channel{Core.UInt64}
    ) ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}

        # # print("當前協程 task: ", Base.current_task(), "\n");
        # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
        # print("當前綫程 thread 的 PID: ", Base.Threads.threadid(), "\n");
        # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
        # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
        # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
        # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
        # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
        # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
        # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
        # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
        # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
        # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
        # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
        # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
        # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

        worker_Data_Dict = Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
        # worker_Data_Dict = Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
        # worker_data_Dict = Base.Dict{Core.String, Core.Any}(
        #     # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
        #     "arguments" => request_Dict = Base.Dict{Core.String, Core.Any}(
        #         "request_body_String" => request_body,
        #         "request_Nikename" => request_Nikename,
        #         "request_Password" => request_Password,
        #         "time" => Base.string(now_date),
        #         "request_IP" => request_head["request_IP"],
        #         "request_Method" => request_head["request_Method"],
        #         "Target" => request_head["Target"],
        #         "request_Path" => request_head["request_Path"],
        #         "request_Protocol" => request_head["request_Protocol"].
        #         "Authorization" => request_head["Authorization"],
        #         "Cookie" => request_head["Cookie"],
        #         "From" => request_head["From"],
        #         "User-Agent" => request_head["User-Agent"],
        #         "Host" => request_head["Host"],
        #         "Accept" => request_head["Accept"],
        #         "Accept-Language" => request_head["Accept-Language"],
        #         "Accept-Charset" => request_head["Accept-Charset"],
        #         "Date" => request_head["Date"]
        #     );
        # );

        if Base.isa(worker_Data_Dict, Base.Dict)

            if Base.haskey(worker_Data_Dict, "label") && worker_Data_Dict["label"] === "Run"

                request_Dict = Base.Dict{Core.String, Core.Any}();
        
                if Base.haskey(worker_Data_Dict, "arguments") && Base.isa(worker_Data_Dict["arguments"], Base.Dict)

                    # println(worker_Data_Dict["arguments"]);
                    request_Dict = worker_Data_Dict["arguments"];

                    result::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1} = ["",""];
                    try
                        # Base.push!(result, "success");
                        result[1] = "success";
                        # Base.push!(result, do_Function(request_Dict));
                        result[2] = do_Function(request_Dict);
                        # result[2] = worker_Data_Dict["do_Function"](worker_Data_Dict["arguments"]);
                        # Base.write(Base.stdout, result[2]);
                        # println(result[2]);
                    catch err
                        # Base.write(stderr, err);
                        # Base.write(Base.stdout, err, "\n");
                        # println("自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                        println(err);
                        # println(err.msg);
                        # println(Base.typeof(err));
                        result[1] = "error";
                        result[2] = Base.string(err);
                    end
                    # Base.write(Base.stdout, result[2]);

                    # response_body_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                    # println(response_body_String);
        
                    nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    # println(Base.string(nowTime));
                    # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    # log_text::Core.String = "";
                    # if Base.isa(request_Dict, Base.Dict)
                    #     if Base.haskey(request_Dict, "request_IP") && Base.haskey(request_Dict, "request_Nikename") && Base.haskey(request_Dict, "request_Password") && Base.haskey(request_Dict, "request_Path") && Base.haskey(request_Dict, "User-Agent") && Base.haskey(request_Dict, "From")
                    #         log_text = "error < " * Base.string(result[2]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(request_Dict["request_IP"]) * " > < " * Base.string(request_Dict["request_Nikename"], ":", request_Dict["request_Password"]) * " > < " * Base.string(request_Dict["request_Path"]) * " > < " * Base.string(request_Dict["User-Agent"]) * " > < " * Base.string(request_Dict["From"]) * " >.";
                    #     elseif Base.haskey(request_Dict, "request_IP") && Base.haskey(request_Dict, "request_Nikename") && Base.haskey(request_Dict, "request_Password") && Base.haskey(request_Dict, "request_Path")
                    #         log_text = "error < " * Base.string(result[2]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(request_Dict["request_IP"]) * " > < " * Base.string(request_Dict["request_Nikename"], ":", request_Dict["request_Password"]) * " > < " * Base.string(request_Dict["request_Path"]) * " >.";
                    #     elseif Base.haskey(request_Dict, "request_IP") && Base.haskey(request_Dict, "request_Path")
                    #         log_text = "error < " * Base.string(result[2]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(request_Dict["request_IP"]) * " > < " * Base.string(request_Dict["request_Path"]) * " >.";
                    #     elseif Base.haskey(request_Dict, "request_IP")
                    #         log_text = "error < " * Base.string(result[2]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " < " * Base.string(request_Dict["request_IP"]) * " >.";
                    #     end
                    # else
                    #     log_text = "error < " * Base.string(result[2]) * " > " * Base.string(nowTime) * " process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " .";
                    # end
                    # print(log_text * "\n");
                    # log_file = "";  # 日志文檔;
                    # # 同步寫入用於記錄過程的日志文檔;
                    # try
                    #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                    #     # # write(filename::AbstractString, x)
                    #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                    #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                    #     # println(numBytes);
                    #     # println(Base.stat(log_file).size);
                    #     # println(Base.stat(log_file).mtime);
                    #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    #     # println(Base.stat(log_file).ctime);
                    #     # # Base.displaysize([io::IO]) -> (lines, columns)
                    #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                    #     # # Base.countlines — Function
                    #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                    #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                    #     # println(Base.countlines(log_file, eol='\\n'));
        
                    #     fWIO = Base.open(log_file, "a+");
                    #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                    #     # seekstart(fWIO);  # 指針返回文檔的起始位置;
        
                    #     # Keyword	Description				Default
                    #     # read		open for reading		!write
                    #     # write		open for writing		truncate | append
                    #     # create	create if non-existent	!read & write | truncate | append
                    #     # truncate	truncate to zero size	!read & write
                    #     # append	seek to end				false
        
                    #     # Mode	Description						Keywords
                    #     # r		read							none
                    #     # w		write, create, truncate			write = true
                    #     # a		write, create, append			append = true
                    #     # r+	read, write						read = true, write = true
                    #     # w+	read, write, create, truncate	truncate = true, read = true
                    #     # a+	read, write, create, append		append = true, read = true
        
                    #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                    #     if Base.iswritable(fWIO)
                    #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                    #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                    #         println(numBytes);
                    #         println(Base.stat(log_file).size);
                    #         println(Base.stat(log_file).mtime);
                    #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                    #         println(Base.stat(log_file).ctime);
                    #         # Base.displaysize([io::IO]) -> (lines, columns)
                    #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                    #         # Base.countlines — Function
                    #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                    #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                    #         println(Base.countlines(log_file, eol='\\n'));
                    #     end
        
                    #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（Base.IOBuffer）;
                    #     # io = Base.Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（Base.IOBuffer）;
                    #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                    #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                    #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                    #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                    #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                    #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                    #     # Base.ismarked(io);  # Return true if stream s is marked;
                    #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                    #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                    #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                    #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                    #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                    #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                    #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                    #     # Base.close(io);  # 關閉緩衝區;
                    #     # println(a)
                    #     # Base.redirect_stdout — Function
                    #     # redirect_stdout([stream]) -> (rd, wr)
                    #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                    #     # If called with the optional stream argument, then returns stream itself.
                    #     # Base.redirect_stdout — Method
                    #     # redirect_stdout(f::Function, stream)
                    #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                    #     # Base.redirect_stderr — Function
                    #     # redirect_stderr([stream]) -> (rd, wr)
                    #     # Like redirect_stdout, but for stderr.
                    #     # Base.redirect_stderr — Method
                    #     # redirect_stderr(f::Function, stream)
                    #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                    #     # Base.redirect_stdin — Function
                    #     # redirect_stdin([stream]) -> (rd, wr)
                    #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                    #     # Base.redirect_stdin — Method
                    #     # redirect_stdin(f::Function, stream)
                    #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.
        
                    # catch err
                    #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                    #     println(err);
                    #     # println(Base.typeof(err));
        
                    #     # Julia提供了許多類型的錯誤：
                    #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                    #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                    #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                    #     # DivideError：這是數字除以0時的結果。
                    #     # DomainError：有效域之外的參數。
                    #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                    #     # InexactError：嘗試進行精確類型轉換失敗。
                    #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                    #     # LoadError：載入檔時發生錯誤。
                    #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                    #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                    #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                    #     # OverflowError：當操作結果太大時會發生這種情況。
                    #     # ParseError：解析給定運算式時出現問題。
                    #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                    #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                    #     # UndefRefError：未知引用。
                    #     # UndefVarError：對不存在的變數進行未知引用。
                    #     # InitError：調用模組的init方法時出現此錯誤。
                    #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                    #     # NullException：嘗試訪問Null值
                    #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤
        
                    #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];
        
                    # finally
                    #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                    #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                    #     if Base.eof(fWIO)
                    #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                    #     end
                    # end

                    request_Arguments = Base.Dict{Core.String, Core.String}();
                    if Base.length(request_Dict) > 0
                        # Base.isa(request_Dict, Base.Dict)
        
                        # if Base.haskey(request_Dict, "request_body_String")
                        #     request_Arguments["request_body_String"] = request_Dict["request_body_String"];
                        # end
                        if Base.haskey(request_Dict, "request_Nikename")
                            request_Arguments["request_Nikename"] = request_Dict["request_Nikename"];
                        end
                        if Base.haskey(request_Dict, "request_Password")
                            request_Arguments["request_Password"] = request_Dict["request_Password"];
                        end
                        if Base.haskey(request_Dict, "time")
                            request_Arguments["time"] = request_Dict["time"];
                        end
                        if Base.haskey(request_Dict, "request_IP")
                            request_Arguments["request_IP"] = request_Dict["request_IP"];
                        end
                        if Base.haskey(request_Dict, "request_Method")
                            request_Arguments["request_Method"] = request_Dict["request_Method"];
                        end
                        if Base.haskey(request_Dict, "request_Path")
                            request_Arguments["request_Path"] = request_Dict["request_Path"];
                        end
                        if Base.haskey(request_Dict, "request_Protocol")
                            request_Arguments["request_Protocol"] = request_Dict["request_Protocol"];
                        end
                        if Base.haskey(request_Dict, "Authorization")
                            request_Arguments["Authorization"] = request_Dict["Authorization"];
                        end
                        if Base.haskey(request_Dict, "Cookie")
                            request_Arguments["Cookie"] = request_Dict["Cookie"];
                        end
                        if Base.haskey(request_Dict, "From")
                            request_Arguments["From"] = request_Dict["From"];
                        end
                        if Base.haskey(request_Dict, "User-Agent")
                            request_Arguments["User-Agent"] = request_Dict["User-Agent"];
                        end
                        if Base.haskey(request_Dict, "Host")
                            request_Arguments["Host"] = request_Dict["Host"];
                        end
                        if Base.haskey(request_Dict, "Accept")
                            request_Arguments["Accept"] = request_Dict["Accept"];
                        end
                        if Base.haskey(request_Dict, "Accept-Language")
                            request_Arguments["Accept-Language"] = request_Dict["Accept-Language"];
                        end
                        if Base.haskey(request_Dict, "Accept-Charset")
                            request_Arguments["Accept-Charset"] = request_Dict["Accept-Charset"];
                        end
                        if Base.haskey(request_Dict, "Date")
                            request_Arguments["Date"] = request_Dict["Date"];
                        end
                    end

                    result_Data_Dict = Base.Dict{Core.String, Core.Any}(
                        "request_Arguments" => request_Arguments,
                        # "do_Function" => do_Function,  # worker_Data_Dict["do_Function"]， # do_data ;
                        "result_data" => Base.string(result[2]),
                        "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                        "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                        "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                        "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                        "label" => result[1],
                        "message" => "Function [ do_Function ] return " * result[1] * "."
                    );

                    Base.put!(sub_to_main_channel, result_Data_Dict);  # 向通道(Channel)中寫入元素;
                    num = Base.take!(control_number_Queues_channel);  # 取出用於控制并發數目的通道中的元素，使主進程中可以繼續創建子進程。使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;

                    # result_Data_Dict = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                    # Base.GC.gc();  # 内存回收函數 gc();

                    return [result[1], Base.string(result[2]), result_Data_Dict["message"]];
                else
                    return ["error", "main_to_sub_channel", "[ worker_data_Dict::Base.Dict{Core.String, Core.Any}[\"arguments\"] === request_Dict::Base.Dict{Core.String, Core.String} ] can't found."];
                end
            end

            if Base.haskey(worker_Data_Dict, "label") && worker_Data_Dict["label"] === "Exit"
                Base.close(sub_to_main_channel);
                Base.exit(0);
            end
        else
            return ["error", "main_to_sub_channel", "Base.typeof(Base.take!(main_to_sub_channel)) !== Base.Dict, not recognition."];
        end
    end

    # 注意，需要事先加載 Julia 原生的標準包套接字模組「Sockets」：using Sockets;
    # 異步監聽服務器端，注意，必須要異步監聽，否則將會阻塞後續代碼執行;
    # 使用 Julia 原生的標準包 Sockets 中的 listen(name_pipe) 函數建立服務器端的監聽，返回值為 PipeServer 類型，使用 accpet(PipeServer) 函數調用後，會調用 Base.wait() 函數，等待一個客戶端的鏈接，如果不采用異步形式，則此步驟代碼會阻塞後續的代碼執行，accpet(PipeServer) 函數的返回值為 Base.PipeEndpoint 類型，此類型為 Base 包中的不導出的類型。
    server = Core.nothing;
    # server::Core.Union{HTTP.listen, HTTP.listen!, HTTP.server, HTTP.server!} = Core.nothing;
    # server::Core.Union{TCPServer, TCPSocket} = Core.nothing;
    # sock = Core.nothing;
    # sock::Sockets.PipeServer = Core.nothing;
    # Base.@async begin
    begin

        # 獲取請求數據，獲取客戶端發送的請求頭和請求數據;
        request_head = Base.Dict{Core.String, Core.Any}();
        request_Url_Query_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}();  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict{Core.String, Core.Any}("a" => 1, "b" => 2);
        request_body_bytes_Array::Core.Union{Base.IOStream, Base.IOBuffer, Core.Nothing, Core.String, Core.Array{Core.UInt8, 1}, Base.Vector{UInt8}} = Base.IOBuffer();  # Core.Array{Core.UInt8, 1}();  # Core.Array{Core.UInt8, 1}();  # ::Core.Union{Base.Vector{Core.UInt8}, Core.String, Base.IOBuffer};
        request_body_String::Core.String = "";
        request_body_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}();

        request_Authorization::Core.String = "";  # 解析獲取客戶端請求頭中的賬號密碼 "authorization" 參數 "Basic domain name -> username:password";
        request_Cookie::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數 "Session_ID=request_Key->username:password";
        request_Cookie_name::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數名;
        request_Cookie_value::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數值;
        request_Key::Core.String = "";  # 判斷如果客戶端發送的請求的賬號密碼來源，如果請求頭 request.headers["Authorization"] 參數不爲空則使用 request.headers["Authorization"] 的參數值作爲客戶端的賬號密碼，如果請求頭 request.headers["Authorization"] 參數為空但 request.headers["Cookie"] 參數不爲空則使用 request.headers["Cookie"]  的參數值，作爲在自定義的 Session 對象中查找的"key"對應的"value"值，作爲客戶端的賬號密碼;
        request_Nikename::Core.String = "";  # 提取賬號密碼;
        request_Password::Core.String = "";  # 提取賬號密碼;

        request_Accept::Core.String = "";  # 提取客戶端發送的請求頭裏包含的接受的數據類型參數（"Accept"）;
        response_Content_Type::Core.String = "";  # "application/octet-stream, text/plain, text/html, text/javascript, text/css, image/jpeg, image/svg+xml, image/png; charset=utf-8";

        # non-blocking server;
        # 注意，「HTTP.listen!()」方法是非阻塞運行，執行一遍即會停止，如想保持監聽服務器持續運行，可使用「Base.wait(server)」方法阻塞進程向下繼續運行;
        # 「HTTP.listen!()」 form is non-blocking and returns an HTTP.Server object which can be 「Base.wait(server)」ed on manually, or 「Base.close(server)」ed to gracefully shut down the server. Calling 「HTTP.forceclose(server)」 will immediately force close the server and all active connections. 
        # HTTP.listen! and HTTP.serve! are the non-blocking versions of HTTP.listen/HTTP.serve;
        # HTTP.listen!(handler, host=Sockets.localhost, port=8081; kw...) -> HTTP.Server
        # HTTP.listen!(args...; kw...) -> HTTP.Server
        # The 「handler」 function should be of the form 「f(::HTTP.Stream)::Nothing」, and should at the minimum set a status via 「HTTP.setstatus()」 and call 「HTTP.startwrite()」 either explicitly or implicitly by writing out a response via 「Base.write()」. Failure to do this will result in an HTTP 500 error being transmitted to the client.
        # HTTP.listen!() do http::HTTP.Stream 預設情況下，服務器將監聽 127.0.0.1:8081 網址，The server will start listening on 127.0.0.1:8081 by default;
        server = HTTP.listen!(
            host,
            port;
            # sslconfig = sslconfig,  # Core.nothing,  # Provide an MbedTLS.SSLConfig object to handle ssl connections.SSLConfig(certfile, keyfile) Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl verification (useful for testing). Construct a custom SSLConfig object with MbedTLS;
            # tcpisvalid = tcpisvalid,  # (tcp_socket::TCPSocket) -> begin tcp_socket; return true; end,  # 自定義函數 f(::TCPSocket)::Bool，用於在處理請求之前檢查接受的連接是否有效。例如，執行源IP過濾，function f(::TCPSocket)::Bool to check if accepted connections are valid before processing requests. e.g. to do source IP filtering;
            # reuseaddr = reuseaddr,  # ::Core.Bool = false 允許多個伺服器偵聽同一埠，allow multiple servers to listen on the same port. Not supported on some OS platforms. Can check HTTP.Servers.supportsreuseaddr();
            # server = provide_IOServer,  # Core.nothing,  # ::Base.IOServer = Core.nothing，提供要偵聽的對象，允許手動關閉或配置伺服器套接字，provide an IOServer object to listen on; allows manually closing or configuring the server socket;
            verbose = verbose,  # ::Core.Bool = false 將連接資訊記錄到輸出到顯示器 Base.stdout 標準輸出流，log connection information to stdout;
            # access_log = access_log,  # (io::IO, http::HTTP.Stream) -> begin io; http; return; end,  # 用於格式化訪問日誌消息的功能，該函數應接受兩個參數 (io::IO, http::HTTP.Stream)，消息應寫入這兩個參數，並可用於從中查詢資訊，function for formatting access log messages. The function should accept two arguments, io::IO to which the messages should be written, and http::HTTP.Stream which can be used to query information from. See also @logfmt_str;
            on_shutdown = on_shutdown,  # (argument) -> begin argument; return; end,  # ::Union{Core.Function, Base.Vector{<:Core.Function}, Nothing} = Core.nothing, 伺服器關閉時要運行的一個或多個函數（例如，由 InterruptException）。請注意，如果將對象提供給關鍵字參數 IOServer、server 並由 Base.close(server) 關閉，則關閉函數將不會運行，one or more functions to be run if the server is closed (for example by an InterruptException). Note, shutdown function(s) will not run if an IOServer object is supplied to the server keyword argument and closed by close(server);
            readtimeout = readtimeout  # ::Core.Int = 0 客戶端請求數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
        ) do ioHttpRequest
            # @show ioHttpRequest.message.response;
            # @show ioHttpRequest.message.context;
            # @show ioHttpRequest.message;
            # @show ioHttpRequest.message.parent;
            # @show ioHttpRequest.message.method;
            # @show ioHttpRequest.message.url;
            # @show ioHttpRequest.message.target;
            # @show ioHttpRequest.message.headers;
            # @show ioHttpRequest.message.body;
            # @show HTTP.header(ioHttpRequest, "Content-Type");
            # @show HTTP.header(ioHttpRequest, "Cookie");
            # @show HTTP.header(ioHttpRequest, "Authorization");
            # @show HTTP.header(ioHttpRequest, "Referrer");
            # request_headers_Cookie::Core.String = Base.string(HTTP.header(ioHttpRequest, "Cookie"));
            # println(request_headers_Cookie);
            # request_body_String::Core.String = "";
            # request_body_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}();
            # while !Base.eof(ioHttpRequest)
            #     request_body_bytes_Array = Base.readavailable(ioHttpRequest);  # ::Base.Vector{UInt8} or ::Core.String or ::Base.IOBuffer;
            #     request_body_String = Base.string(Core.String(request_body_bytes_Array));  # ::Core.String;
            #     request_body_Dict = JSONparse(request_body_String);  # ::Base.Dict{Core.String, Core.Any}; 自定義函數 JSONparse() 將 JSON 字符串轉換爲 Julia 字典（Dict）;
            #     # request_body_Dict = JSON.parse(request_body_String);  # ::Base.Dict{Core.String, Core.Any}; 第三方擴展包 JSON 中的函數 JSON.parse() 將 JSON 字符串轉換爲 Julia 字典（Dict）;
            # end
            # println(request_body_String);
            # println(request_body_Dict);


            # 獲取請求數據，獲取客戶端發送的請求頭和請求數據;
            request_head = Base.Dict{Core.String, Core.Any}();
            request_Url_Query_Dict = Base.Dict{Core.String, Core.Any}();  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict{Core.String, Core.Any}("a" => 1, "b" => 2);
            request_body_bytes_Array = Base.IOBuffer();  # ::Core.Union{Base.IOStream, Base.IOBuffer, Core.Nothing, Core.String, Core.Array{Core.UInt8, 1}, Base.Vector{UInt8}}; # Core.Array{Core.UInt8, 1}();  # ::Core.Union{Base.Vector{Core.UInt8}, Core.String, Base.IOBuffer};
            request_body_String = "";  # ::Core.String = "";
            request_body_Dict = Base.Dict{Core.String, Core.Any}();  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}();

            # 獲取客戶端發送的請求頭和請求數據;
            try
                # 讀取發送請求的客戶端 IP 地址;
                IPClient = Sockets.getpeername(ioHttpRequest)[1];
                # IPClient, PortClient = Sockets.getpeername(ioHttpRequest);  # 需要事先加載原生的 Sockets 模組：using Sockets 模組;
                # println(IPClient, PortClient);
                request_head["request_IP"] = Base.string(IPClient);
                # println(request_head["request_IP"]);

                # 讀取請求頭數據;
                # println(!Base.eof(ioHttpRequest))
                # if !Base.eof(ioHttpRequest)

                    # Base.haskey(::Dict, "key") -> Bool 判斷字典中某個關鍵字（key）是否存在？
                    # Base.isa("aaa", Core.String) -> Bool 判斷變量類型是否爲字符串？
                    # HTTP.hasheader(::Message, "key") -> Bool 判斷請求標頭的某個關鍵字（key）是否存在（不區分大小寫），Does header value for key exist (case-insensitive)？
                    # println(HTTP.hasheader(ioHttpRequest, "Cookie"));
                    if HTTP.hasheader(ioHttpRequest, "Cookie")
                        request_head["Cookie"] = Base.string(HTTP.header(ioHttpRequest, "Cookie"));
                    else
                        request_head["Cookie"] = "";
                    end
                    # println(request_head["Cookie"]);

                    # println(HTTP.hasheader(ioHttpRequest, "Authorization"));
                    if HTTP.hasheader(ioHttpRequest, "Authorization")
                        request_head["Authorization"] = Base.string(HTTP.header(ioHttpRequest, "Authorization"));
                    else
                        request_head["Authorization"] = "";
                    end
                    # println(request_head["Authorization"]);

                    if HTTP.hasheader(ioHttpRequest, "Referrer")
                        request_head["Referrer"] = Base.string(HTTP.header(ioHttpRequest, "Referrer"));  # 請求來源頁面的 URL 網址;
                    else
                        request_head["Referrer"] = "";
                    end

                    if ioHttpRequest.message.parent !== Core.nothing
                        request_head["Referrer"] = Base.string(ioHttpRequest.message.parent);
                    end

                    if ioHttpRequest.message.method !== Core.nothing
                        request_head["Method"] = Base.string(ioHttpRequest.message.method);  # 請求類型，例如："GET"、"POST"、"OPTIONS";
                    end

                    # if ioHttpRequest.message.ip !== Core.nothing
                    #     request_head["request_IP"] = Base.string(ioHttpRequest.message.ip);  # 客戶端主機 IP 地址;
                    # end

                    if ioHttpRequest.message.target !== Core.nothing
                        request_head["Target"] = Base.string(ioHttpRequest.message.target);  # 請求路徑，例如：path = /index?a=1&b=2&c=3#a1;
                    end

                    if ioHttpRequest.message.url !== Core.nothing
                        request_head["Url"] = Base.string(ioHttpRequest.message.url);  # 請求完整網址，例如：http://username:password@127.0.0.1:8081/index?a=1&b=2&c=3#a1;
                    end

                    if HTTP.hasheader(ioHttpRequest, "Content-Type")
                        request_head["Content-Type"] = Base.string(HTTP.header(ioHttpRequest, "Content-Type"));  # 客戶端 POST 請求發送數據的類型 "application/x-www-form-urlencoded; charset=utf-8";
                    else
                        request_head["Content-Type"] = "";
                    end

                    if HTTP.hasheader(ioHttpRequest, "Content-Length")
                        request_head["Content-Length"] = Base.string(HTTP.header(ioHttpRequest, "Content-Length"));  # 客戶端 POST 請求發送數據的大小;
                    else
                        request_head["Content-Length"] = "";
                    end

                    if HTTP.hasheader(ioHttpRequest, "Accept")
                        request_head["Accept"] = Base.string(HTTP.header(ioHttpRequest, "Accept"));  # 客戶端接受響應數據的類型，例如：# "*/*"; "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9";
                    else
                        request_head["Accept"] = "";
                    end

                    if HTTP.hasheader(ioHttpRequest, "Accept-Charset")
                        request_head["Accept-Charset"] = Base.string(HTTP.header(ioHttpRequest, "Accept-Charset"));  # 客戶端接受響應數據的編碼類型，例如："utf-8";
                    else
                        request_head["Accept-Charset"] = "";
                    end

                    if HTTP.hasheader(ioHttpRequest, "Accept-Language")
                        request_head["Accept-Language"] = Base.string(HTTP.header(ioHttpRequest, "Accept-Language"));  # 客戶端接受響應數據的語言，例如："zh-TW,zh;q=0.9" # "zh-Hant-TW; q=0.8, zh-Hant; q=0.7, zh-Hans-CN; q=0.7, zh-Hans; q=0.5, en-US, en; q=0.3";
                    else
                        request_head["Accept-Language"] = "";
                    end

                    if HTTP.hasheader(ioHttpRequest, "Date")
                        request_head["Date"] = Base.string(HTTP.header(ioHttpRequest, "Date"));  # 客戶端發送請求的日期時間，例如："2021/8/22 02:02:33";
                    else
                        request_head["Date"] = "";
                    end

                    if HTTP.hasheader(ioHttpRequest, "User-Agent")
                        request_head["User-Agent"] = Base.string(HTTP.header(ioHttpRequest, "User-Agent"));  # 客戶端發送請求鏈接器的名稱，例如："Julia-1.9.3 HTTP.request()"，"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36";
                    else
                        request_head["User-Agent"] = "";
                    end

                    if HTTP.hasheader(ioHttpRequest, "From")
                        request_head["From"] = Base.string(HTTP.header(ioHttpRequest, "From"));  # 客戶端的聯係方式，例如電子郵件："user@email.com";
                    else
                        request_head["From"] = "";
                    end

                    if HTTP.hasheader(ioHttpRequest, "Sec-Ch-Ua-Platform")
                        request_head["Sec-Ch-Ua-Platform"] = Base.string(HTTP.header(ioHttpRequest, "Sec-Ch-Ua-Platform"));  # 客戶端的操作系統名稱，例如："Windows";
                    else
                        request_head["Sec-Ch-Ua-Platform"] = "";
                    end

                    if HTTP.hasheader(ioHttpRequest, "sec-ch-ua-mobile")
                        request_head["sec-ch-ua-mobile"] = Base.string(HTTP.header(ioHttpRequest, "sec-ch-ua-mobile"));  # 客戶端是否爲移動終端 Android 智能電話，例如："0";
                    else
                        request_head["sec-ch-ua-mobile"] = "";
                    end

                    # "Connection" => "keep-alive",  # "close", # 'keep-alive' 維持客戶端和服務端的鏈接關係，當一個網頁打開完成後，客戶端和服務器之間用於傳輸 HTTP 數據的 TCP 鏈接不會關閉，如果客戶端再次訪問這個服務器上的網頁，會繼續使用這一條已經建立的鏈接;
                    # "Cache-Control" => "no-cache",
                    # "Upgrade" => "HTTP/1.0, HTTP/1.1, HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11",
                    # "Accept-Encoding" => "gzip, deflate, br",
                    # "sec-ch-ua" => "\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"",
                    # "Upgrade-Insecure-Requests" => "1",
                    # "Purpose" => "prefetch",
                    # "Sec-Fetch-Site" => "none",
                    # "Sec-Fetch-Mode" => "navigate",
                    # "Sec-Fetch-User" => "1",
                    # "Sec-Fetch-Dest" => "document",

                # else
                # end
                # println(request_head);

                # 讀取請求體數據;
                # println(!Base.eof(ioHttpRequest))
                while !Base.eof(ioHttpRequest)
                    request_body_bytes_Array = Base.readavailable(ioHttpRequest);  # ::Base.Vector{UInt8} or ::Core.String or ::Base.IOBuffer();
                    request_body_String = Base.string(Core.String(request_body_bytes_Array));  # ::Core.String;
                    request_body_Dict = JSONparse(request_body_String);  # ::Base.Dict{Core.String, Core.Any};  # 自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 JUlia 字典（Dict）;
                    # request_body_Dict = JSON.parse(request_body_String);  # ::Base.Dict{Core.String, Core.Any};  # 第三方擴展包 JSON 中的 JSON.parse() 函數，將 JSON 字符串轉換爲 JUlia 字典（Dict）;
                    # 通過函數 HTTP.isjson(content) 進行判斷是否爲 JSON 檢測;
                    # println(HTTP.isjson(ioHttpRequest.message.body)[1]);
                    # if HTTP.isjson(ioHttpRequest.message.body)[1]
                    #     request_body_String = Base.string(Core.String(Base.readavailable(ioHttpRequest)));  # ::Base.Vector{UInt8} or ::Core.String or ::Base.IOBuffer();
                    #     request_body_Dict = JSONparse(request_body_String);  # 自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 JUlia 字典（Dict）;
                    #     # request_body_Dict = JSON.parse(request_body_String);  # 第三方擴展包 JSON 中的 JSON.parse() 函數，將 JSON 字符串轉換爲 JUlia 字典（Dict）;
                    #     # println(request_body_Dict["token"]);
                    # else
                    #     request_body_String = Base.string(Core.String(Base.readavailable(ioHttpRequest)));  # ::Base.Vector{UInt8} or ::Core.String or ::Base.IOBuffer();
                    #     # request_body_Dict = JSONparse(request_body_String);  # 自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 JUlia 字典（Dict）;
                    #     # # request_body_Dict = JSON.parse(request_body_String);  # 第三方擴展包 JSON 中的 JSON.parse() 函數，將 JSON 字符串轉換爲 JUlia 字典（Dict）;
                    #     # println(request_body_Dict["token"]);
                    # end
                end
                # println(request_body_bytes_Array);
                # println(request_body_String);
                # println(request_body_Dict);

                HTTP.Streams.closeread(ioHttpRequest);

            catch err

                # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                if Core.isa(err, Core.InterruptException)

                    print("\n");
                    # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                    # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                    println("[ Ctrl ] + [ c ] received, will be stop the TCP server.");

                    # # 打印進程被調用數目;
                    # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                    #     if isConcurrencyHierarchy === "Multi-Processes"

                    #         # Base.haskey(collection, key) -> Bool
                    #         # workNum = "worker";
                    #         for k in Base.keys(total_worker_called_number)
                    #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                    #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                    #         end
                    #         # println(workNum);

                    #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                    #         # Base.haskey(collection, key) -> Bool
                    #         # workNum = "worker";
                    #         for k in Base.keys(total_worker_called_number)
                    #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                    #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                    #         end
                    #         # println(workNum);

                    #     end

                    #     total_worker_called_number = Core.nothing;
                    # end

                    # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                    # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                    #     # Base.haskey(collection, key) -> Bool
                    #     # for k in Base.keys(worker_queues_Dict)
                    #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                    #     # end

                    #     worker_queues_Dict = Core.nothing;
                    # end

                    println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                    # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
                    Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;
                    # Base.exit(0);  # 立即中止進程;
                    return ["", server, total_worker_called_number];

                else
                    
                    # Base.write(stderr, err);
                    # Base.write(Base.stdout, err, "\n");
                    println(err);

                    response_statusCode = Core.Int64(500);
                    response_status_Message = statusMessage(response_statusCode);
                    # response_body_String = "{\"Server_say\":\"" * "Server read request data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                    # cookie_string = "";  # * "; expires=" * Base.string(after_1_Days) * "; path=/;";  # 拼接 cookie 字符串值;

                    # Base.close(sock);  # 中斷當前的這個鏈接;
                    # # Base.sleep(time_sleep);
                    # continue;
                    # # break;
                end
            end
            # println(request_head);
            # println(request_body_bytes_Array);
            # println(request_body_String);
            # println(request_body_Dict);

            # 解析獲取客戶端請求 url 中的查詢字符串值;
            request_Path::Core.String = "";
            # request_Url_Query_Dict = Base.Dict{Core.String, Core.Any}();  # 客戶端請求 url 中的查詢字符串值解析字典;
            request_Url_Query_String::Core.String = "";  # 客戶端請求 url 中的查詢字符串值;
            if Base.length(request_head) > 0
                # Base.isa(request_head, Base.Dict)

                # 解析獲取客戶端請求 url 中的查询字符串;
                # request_Url_Query::Core.String = "";
                if Base.haskey(request_head, "Target")
                    # println("request URL: ", request_head["Target"]);  # "/index.html?a=1&b=2#idStr";
                    # println(Base.typeof(request_head["Target"]));

                    if Base.isa(request_head["Target"], Core.String) && Base.occursin('?', request_head["Target"])

                        # request_Path = Base.string(Base.strip(Base.split(request_head["Target"], '?')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.string() 表示强制轉換為字符串(String)型變量;
                        request_Path = Base.convert(Core.String, Base.strip(Base.split(request_head["Target"], '?')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.convert() 將子字符串(SubString)型轉換為字符串(String)型變量;

                        # request_Url_Query_String = Base.string(Base.strip(Base.split(request_head["Target"], '?')[2]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.string() 表示强制轉換為字符串(String)型變量;
                        request_Url_Query_String = Base.convert(Core.String, Base.strip(Base.split(request_head["Target"], '?')[2]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.convert() 將子字符串(SubString)型轉換為字符串(String)型變量;
                        if Base.isa(request_Url_Query_String, Core.String) && Base.occursin('#', request_Url_Query_String)
                            request_Url_Query_String = Base.convert(Core.String, Base.strip(Base.split(request_Url_Query_String, '#')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.convert() 將子字符串(SubString)型轉換為字符串(String)型變量;
                            # request_Url_Query_String = Base.string(Base.strip(Base.split(request_Url_Query_String, '#')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.convert() 將子字符串(SubString)型轉換為字符串(String)型變量;
                        end

                        # if Base.isa(request_Url_Query_String, Core.String) && Base.occursin('&', request_Url_Query_String)

                        #     # url_Query_Array = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空1維數組，可以使用 Base.push! 函數在數組末尾追加推入新元素;
                        #     # url_Query_Array = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                        #     # 函數 Base.split(request_Url_Query_String, '&') 表示用等號字符'&'分割字符串為數組;
                        #     for x in Base.split(request_Url_Query_String, '&')
                        #         temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                        #         temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                        #         # temp = Base.string(temp);

                        #         if Base.isa(temp, Core.String) && Base.occursin('=', temp)

                        #             tempKey = Base.split(temp, '=')[1];
                        #             tempKey = Base.strip(tempKey);
                        #             tempKey = Base.convert(Core.String, tempKey);
                        #             # tempKey = Base.string(tempKey);
                        #             tempKey = Core.String(Base64.base64decode(tempKey));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                        #             # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                        #             # Base64.base64decode("base64_Str");  # 解碼;

                        #             tempValue = Base.split(temp, '=')[2];
                        #             tempValue = Base.strip(tempValue);
                        #             tempValue = Base.convert(Core.String, tempValue);
                        #             # tempValue = Base.string(tempValue);
                        #             tempValue = Core.String(Base64.base64decode(tempValue));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                        #             # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                        #             # Base64.base64decode("base64_Str");  # 解碼;

                        #             request_Url_Query_Dict[Base.string(tempKey)] = Base.string(tempValue);  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);

                        #         else

                        #             request_Url_Query_Dict[Base.string(temp)] = Base.string("");  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);

                        #         end

                        #     end
    
                        # else

                        #     if Base.isa(request_Url_Query_String, Core.String) && Base.occursin('=', request_Url_Query_String)

                        #         tempKey = Base.split(request_Url_Query_String, '=')[1];
                        #         tempKey = Base.strip(tempKey);
                        #         tempKey = Base.convert(Core.String, tempKey);
                        #         # tempKey = Base.string(tempKey);
                        #         tempKey = Core.String(Base64.base64decode(tempKey));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                        #         # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                        #         # Base64.base64decode("base64_Str");  # 解碼;

                        #         tempValue = Base.split(request_Url_Query_String, '=')[2];
                        #         tempValue = Base.strip(tempValue);
                        #         tempValue = Base.convert(Core.String, tempValue);
                        #         # tempValue = Base.string(tempValue);
                        #         tempValue = Core.String(Base64.base64decode(tempValue));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                        #         # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                        #         # Base64.base64decode("base64_Str");  # 解碼;

                        #         request_Url_Query_Dict[Base.string(tempKey)] = Base.string(tempValue);  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);

                        #     else

                        #         request_Url_Query_Dict[Base.string(request_Url_Query_String)] = Base.string("");  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);

                        #     end

                        # end

                        # # try
                        # #     eval(:(
                        # #         begin
                        # #             Sys.eval("global " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        # #             # Sys.eval("local " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        # #             # println($ARGSArray[1]);
                        # #         end
                        # #     ));
                        # # catch err
                        # #     println(err);
                        # # end

                    elseif Base.isa(request_head["Target"], Core.String) && Base.occursin('#', request_head["Target"])

                        # request_Path = Base.string(Base.strip(Base.split(request_head["Target"], '#')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.string() 表示强制轉換為字符串(String)型變量;
                        request_Path = Base.convert(Core.String, Base.strip(Base.split(request_head["Target"], '#')[1]));  # 函數 Base.split(request_head["Authorization"], '?') 表示用等號字符'?'分割字符串為數組，函數 Base.strip(str) 去除字符串首尾兩端的空格，函數 Base.convert() 將子字符串(SubString)型轉換為字符串(String)型變量;

                    else

                        request_Path = Base.string(request_head["Target"]);

                    end
                end
            end
            # println("request url query: [ " * request_Url_Query_String * " ].");
            # println("request Path: [ " * request_Path * " ].");
            request_head["request_Path"] = request_Path;
            # println("request url Query: [ " * request_Url_Query_String * " ].");
            request_head["request_Url_Query_String"] = request_Url_Query_String;
            # # println(request_Url_Query_Dict);  # 客戶端請求 url 中的查詢字符串值解析字典 Base.Dict("a" => 1, "b" => 2);
            # request_head["request_Url_Query_Dict"] = request_Url_Query_Dict;

            # 將客戶端請求 url 中的查詢字符串值解析為 Julia 字典類型;
            if Base.isa(request_Url_Query_String, Core.String) && request_Url_Query_String !== ""

                if Base.occursin('&', request_Url_Query_String)

                    # url_Query_Array = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空1維數組，可以使用 Base.push! 函數在數組末尾追加推入新元素;
                    # url_Query_Array = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                    # 函數 Base.split(request_Url_Query_String, '&') 表示用等號字符'&'分割字符串為數組;
                    for x in Base.split(request_Url_Query_String, '&')
                        temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                        temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                        # temp = Base.string(temp);

                        if Base.isa(temp, Core.String) && Base.occursin('=', temp)

                            tempKey = Base.split(temp, '=')[1];
                            tempKey = Base.strip(tempKey);
                            tempKey = Base.convert(Core.String, tempKey);
                            tempKey = Base.string(tempKey);
                            # tempKey = Core.String(Base64.base64decode(tempKey));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                            # # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                            # # Base64.base64decode("base64_Str");  # 解碼;

                            tempValue = Base.split(temp, '=')[2];
                            tempValue = Base.strip(tempValue);
                            tempValue = Base.convert(Core.String, tempValue);
                            tempValue = Base.string(tempValue);
                            # tempValue = Core.String(Base64.base64decode(tempValue));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                            # # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                            # # Base64.base64decode("base64_Str");  # 解碼;

                            request_Url_Query_Dict[Base.string(tempKey)] = Base.string(tempValue);

                        else

                            request_Url_Query_Dict[Base.string(temp)] = Base.string("");
                        end
                    end

                else

                    if Base.isa(request_Url_Query_String, Core.String) && Base.occursin('=', request_Url_Query_String)

                        tempKey = Base.split(request_Url_Query_String, '=')[1];
                        tempKey = Base.strip(tempKey);
                        tempKey = Base.convert(Core.String, tempKey);
                        tempKey = Base.string(tempKey);
                        # tempKey = Core.String(Base64.base64decode(tempKey));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                        # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                        # Base64.base64decode("base64_Str");  # 解碼;

                        tempValue = Base.split(request_Url_Query_String, '=')[2];
                        tempValue = Base.strip(tempValue);
                        tempValue = Base.convert(Core.String, tempValue);
                        tempValue = Base.string(tempValue);
                        # tempValue = Core.String(Base64.base64decode(tempValue));  # 讀取客戶端發送的請求 url 中的查詢字符串 "/index.html?a=1&b=2#id" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                        # Base64.base64encode("text_Str"; context=nothing);  # 編碼;
                        # Base64.base64decode("base64_Str");  # 解碼;

                        request_Url_Query_Dict[Base.string(tempKey)] = Base.string(tempValue);

                    else

                        request_Url_Query_Dict[Base.string(request_Url_Query_String)] = Base.string("");
                    end
                end
            end
            # println(request_Url_Query_Dict);  # Base.Dict("a" => 1, "b" => 2);
            # request_head["request_Url_Query_Dict"] = request_Url_Query_Dict;

            # request_Accept::Core.String = "";  # 提取客戶端發送的請求頭裏包含的接受的數據類型參數（"Accept"）;
            if Base.length(request_head) > 0
                # Base.isa(request_head, Base.Dict)

                # 提取客戶端發送的請求頭裏包含的接受的數據類型參數（"Accept"）;
                # request_Accept::Core.String = "";
                if Base.haskey(request_head, "Accept")
                    request_Accept = request_head["Accept"];
                end
            end

            # response_Content_Type::Core.String = "";  # "application/octet-stream, text/plain, text/html, text/javascript, text/css, image/jpeg, image/svg+xml, image/png; charset=utf-8";
            if request_Accept === ""
                response_Content_Type = "text/html; charset=utf-8";
            elseif Base.occursin("text/html", request_Accept)
                response_Content_Type = "text/html; charset=utf-8";
            elseif Base.occursin("text/javascript", request_Accept)
                response_Content_Type = "text/javascript; charset=utf-8";
            elseif Base.occursin("text/css", request_Accept)
                response_Content_Type = "text/css; charset=utf-8";
            elseif Base.occursin("application/octet-stream", request_Accept)
                response_Content_Type = "application/octet-stream; charset=utf-8";
            else
                response_Content_Type = request_Accept;  # "application/octet-stream, text/plain, text/html, text/javascript, text/css, image/jpeg, image/svg+xml, image/png; charset=utf-8";
            end

            # 解析請求頭中的 "authorization" 和 "cookie" 參數值，用以獲取客戶端發送的請求賬號和密碼進行權限驗證;
            request_Authorization = "";  # ::Core.String = "";  # 解析獲取客戶端請求頭中的賬號密碼 "authorization" 參數 "Basic domain name -> username:password";
            request_Cookie = "";  # ::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數 "Session_ID=request_Key->username:password";
            request_Cookie_name = "";  # ::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數名;
            request_Cookie_value = "";  # ::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數值;
            request_Key = "";  # ::Core.String = "";  # 判斷如果客戶端發送的請求的賬號密碼來源，如果請求頭 request.headers["Authorization"] 參數不爲空則使用 request.headers["Authorization"] 的參數值作爲客戶端的賬號密碼，如果請求頭 request.headers["Authorization"] 參數為空但 request.headers["Cookie"] 參數不爲空則使用 request.headers["Cookie"]  的參數值，作爲在自定義的 Session 對象中查找的"key"對應的"value"值，作爲客戶端的賬號密碼;
            request_Nikename = "";  # ::Core.String = "";  # 提取賬號密碼;
            request_Password = "";  # ::Core.String = "";  # 提取賬號密碼;

            # println(Base.length(request_head));
            if Base.length(request_head) > 0
                # Base.isa(request_head, Base.Dict)

                # 解析獲取客戶端請求頭中的賬號密碼 "authorization" 參數;
                # request_Authorization::Core.String = "";
                # println(Base.haskey(request_head, "Authorization"));
                if Base.haskey(request_head, "Authorization")
                    # println("request Headers Authorization: ", request_head["Authorization"]);
                    # println(Base.typeof(request_head["Authorization"]));

                    if Base.isa(request_head["Authorization"], Core.String) && Base.occursin(' ', request_head["Authorization"])

                        authorArray = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空 1 維數組;
                        # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                        # 函數 Base.split(request_head["Authorization"], ' ') 表示用等號字符'='分割字符串為數組;
                        for x in Base.split(request_head["Authorization"], ' ')
                            temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                            temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                            # temp = Base.string(temp);
                            Base.push!(authorArray, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                        end

                        if Base.length(authorArray) > 1

                            authorValue = "";
                            # authorArray = Base.join(Base.deleteat!(Base.deepcopy(authorArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                            for j = 2:Base.length(authorArray)
                                if j === 2
                                    authorValue = authorValue * authorArray[j];  # 使用星號*拼接字符串;
                                else
                                    authorValue = authorValue * " " * authorArray[j];
                                end
                            end

                            # try
                            #     eval(:(
                            #         begin
                            #             Sys.eval("global " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                            #             # Sys.eval("local " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                            #             # println($ARGSArray[1]);
                            #         end
                            #     ));
                            # catch err
                            #     println(err);
                            # end

                            if authorArray[1] === "Basic" && Base.isa(authorValue, Core.String) && Base.length(authorValue) > 0
                                # !(authorValue === "\r\n\r\n" || authorValue === "")
                                # Base.Unicode.isspace(authorValue)
                                # println("request Headers Authorization: ", authorArray[1] * " " * Core.String(Base64.base64decode(authorValue)));  # 打印請求頭中的使用函數 Base64.base64decode() 解密之後的用戶賬號和密碼參數 "Authorization" 值 "Basic domain name -> username:password"，# 需要事先加載原生的 Base64 模組：using Base64 模組;;
                                request_Authorization = Core.String(Base64.base64decode(authorValue));  # 讀取客戶端發送的請求驗證賬號和密碼 "Basic domain name -> username:password" ，並是使用 Core.String(<object byets>) 方法將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                                # request_head["Authorization"] = "Basic" * " " * Base64.base64encode(request_Authorization; context=nothing);  # 編碼 "Basic domain name -> username:password"，需要事先加載原生的 Base64 模組：using Base64 模組;
                            end
                        end
                    end
                end
                # println("request Headers Authorization: [ " * request_Authorization * " ].");

                # 解析獲取客戶端請求頭中的 "cookie" 參數;
                # request_Cookie::Core.String = "";
                # request_Cookie_name::Core.String = "";
                # request_Cookie_value::Core.String = "";
                # println(Base.haskey(request_head, "Cookie"));
                if Base.haskey(request_head, "Cookie")
                    # println("request Headers Cookie: ", request_head["Cookie"]);  # 打印客戶端請求頭中的 Cookie 參數值;
                    # println(Base.typeof(request_head["Cookie"]));

                    # 判斷客戶端發送的請求頭中 Cookie 參數值中是否包含";"分隔符號;
                    # 若不包含";"分隔符號，則直接使用 Cookie 參數值字符串，然後再判斷 Cookie 參數值中是否包含「"session_id"」關鍵字，若不包含「"session_id"」關鍵字，則將「request_Cookie」變量值賦爲空字符串（""）值，若包含「"session_id"」關鍵字，則將「request_Cookie」變量值賦爲 Cookie 參數值中包含的「"session_id"」關鍵字等於（=）的值字符串;
                    # 若包含";"分隔符號，則説明 Cookie 參數中包含多組參數值，首先使用";"符號分割 Cookie 參數多組參數值字符串，然後再判斷 Cookie 參數多組參數值中是否包含「"session_id"」關鍵字，若不包含「"session_id"」關鍵字，則將「request_Cookie」變量值賦爲空字符串（""）值，若包含「"session_id"」關鍵字，則將「request_Cookie」變量值賦爲 Cookie 參數值中包含的「"session_id"」關鍵字等於（=）的值字符串;
                    cookieArray = Core.Array{Core.Any, 1}();  # 使用";"分隔符號分割 Cookie 多組值中的每一組值，依次保存到數組中，聲明一個任意類型的空 1 維數組;
                    if Base.isa(request_head["Cookie"], Core.String) && Base.string(request_head["Cookie"]) !== ""
                        # Base.length(request_head["Cookie"]) > 0
                        if Base.occursin(";", request_head["Cookie"])
                            # cookieArray = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空 1 維數組;
                            # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                            # 函數 Base.split(request_head["Cookie"], ';') 表示用等號字符';'分割字符串為數組;
                            for x in Base.split(request_head["Cookie"], ';')
                                temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                                temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                                Base.push!(cookieArray, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                            end
                        else
                            Base.push!(cookieArray, Base.string(request_head["Cookie"]));  # Base.convert(Core.String, request_head["Cookie"]) 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量，使用 Base.push! 函數在數組末尾追加推入新元素;
                        end
                    end
                    # println(cookieArray);
                    if Base.length(cookieArray) > 0
                        # cookieArray = Base.join(Base.deleteat!(Base.deepcopy(cookieArray), 1), ";");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        for j = 1:Base.length(cookieArray)
                            if Base.isa(cookieArray[j], Core.String) && Base.occursin("=", cookieArray[j])

                                cookie_session_id_Array = Core.Array{Core.Any, 1}();  # 指定從 Cookie 多組值中提取 session_id 的值，聲明一個任意類型的空 1 維數組;
                                # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                                # 函數 Base.split(cookieArray[j], '=') 表示用等號字符'='分割字符串為數組;
                                for x in Base.split(cookieArray[j], '=')
                                    temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                                    temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                                    Base.push!(cookie_session_id_Array, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                                end
        
                                # Base.convert(Core.String, cookie_session_id_Array[1]);  # "Session_ID=request_Key->username:password";
                                if Base.length(cookie_session_id_Array) > 0 && Base.isa(cookie_session_id_Array[1], Core.String) && Base.string(cookie_session_id_Array[1]) === "session_id"
                                    # cookieValue = Base.join(Base.deleteat!(Base.deepcopy(cookie_session_id_Array), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                                    # println("request Headers Cookie: ", cookie_session_id_Array[1] * "=" * Core.String(Base64.base64decode(Base.join(Base.deleteat!(Base.deepcopy(cookie_session_id_Array), 1), "="))));  # 打印請求頭中的使用函數 Base64.base64decode() 解密之後的用戶 "Cookie"，# 需要事先加載原生的 Base64 模組：using Base64 模組;;
                                    # request_Cookie_name = Base.convert(Core.String, cookie_session_id_Array[1]);  # "Session_ID=request_Key->username:password";
                                    # request_Cookie_value = Core.String(Base64.base64decode(cookieValue));  # "Session_ID=request_Key->username:password"，讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                                    # request_head["cookie"] = request_Cookie_name * "=" * Base64.base64encode(request_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
                                    request_Cookie = Base.string(cookieArray[j]);  # Base.convert(Core.String, cookieArray[j]);  # "Session_ID=request_Key->username:password";  # "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";

                                    break;
                                end
                            end
                        end
                    end
                    # println("request Cookie: ", request_Cookie);

                    # 使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組，將 "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk" 解析爲 "Session_ID=request_Key->username:password" 值，並解析提取 request_Cookie_name 和 request_Cookie_value 值;
                    # request_Cookie = Core.String(Base64.base64decode(request_head["Cookie"]));  # 讀取客戶端發送的請求頭中的 Cookie 參數值，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                    # request_head["Cookie"] = Base64.base64encode(request_Cookie; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
                    # 判斷客戶端發送的請求頭中 Cookie 參數值中是否包含"="符號，如果包含"="符號，則首先使用"="符號分割 Cookie 參數值字符串，否則直接使用 Cookie 參數值字符串;
                    if Base.isa(request_Cookie, Core.String) && Base.occursin("=", request_Cookie)

                        cookie_session_id_Array = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空 1 維數組;
                        # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                        # 函數 Base.split(request_Cookie, '=') 表示用等號字符'='分割字符串為數組;
                        for x in Base.split(request_Cookie, '=')
                            temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                            temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                            Base.push!(cookie_session_id_Array, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                        end

                        if Base.length(cookie_session_id_Array) > 1

                            cookie_session_id_Value = "";
                            # cookie_session_id_Array = Base.join(Base.deleteat!(Base.deepcopy(cookie_session_id_Array), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                            for i = 2:Base.length(cookie_session_id_Array)
                                if i === 2
                                    cookie_session_id_Value = cookie_session_id_Value * cookie_session_id_Array[i];  # 使用星號*拼接字符串;
                                else
                                    cookie_session_id_Value = cookie_session_id_Value * "=" * cookie_session_id_Array[i];
                                end
                            end

                            # try
                            #     eval(:(
                            #         begin
                            #             Sys.eval("global " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                            #             # Sys.eval("local " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                            #             # println($ARGSIArray[1]);
                            #         end
                            #     ));
                            # catch err
                            #     println(err);
                            # end

                            # println("request Headers Cookie: ", cookie_session_id_Array[1] * "=" * Core.String(Base64.base64decode(cookie_session_id_Value)));  # 打印請求頭中的使用函數 Base64.base64decode() 解密之後的用戶 "Cookie"，# 需要事先加載原生的 Base64 模組：using Base64 模組;;
                            request_Cookie_name = Base.convert(Core.String, cookie_session_id_Array[1]);  # "Session_ID=request_Key->username:password";
                            request_Cookie_value = Core.String(Base64.base64decode(cookie_session_id_Value));  # "Session_ID=request_Key->username:password"，讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                            # request_head["cookie"] = request_Cookie_name * "=" * Base64.base64encode(request_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
                            # println("request Cookie name: ", request_Cookie_name);
                            # println("request Cookie value: ", request_Cookie_value);
                        end
                    else
                        request_Cookie_value = Core.String(Base64.base64decode(request_Cookie));  # "Session_ID=request_Key->username:password"，讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                    end
                end
                # println("request Headers Cookie session_id: [ " * request_Cookie * " ].");
                # println("[ " * request_Cookie_name * " ] : " * "[ " * request_Cookie_value * " ].");

                # 判斷如果客戶端發送的請求的賬號密碼來源，如果請求頭 request.headers["Authorization"] 參數不爲空則使用 request.headers["Authorization"] 的參數值作爲客戶端的賬號密碼，如果請求頭 request.headers["Authorization"] 參數為空但 request.headers["Cookie"] 參數不爲空則使用 request.headers["Cookie"]  的參數值，作爲在自定義的 Session 對象中查找的"key"對應的"value"值，作爲客戶端的賬號密碼;
                # request_Key::Core.String = "";
                if request_Authorization !== ""
                    # 如果請求頭 request.headers["Authorization"] 參數不爲空，則使用 request.headers["Authorization"] 的參數值，作爲客戶端的賬號密碼;
                    request_Key = request_Authorization;
                elseif request_Cookie !== "" && request_Cookie_value !== ""
                    # 如果客戶端發送的請求頭 request.headers["Authorization"] 參數為空，但如果客戶端發送的請求頭的 request.headers["Cookie"] 參數不爲空，則使用 request.headers["Cookie"]  的參數值，作爲在自定義的 Session 對象中查找的"key"對應的"value"值，作爲客戶端的賬號密碼;
                    if Base.isa(session, Base.Dict)
                        if Base.length(session) > 0 && Base.haskey(session, request_Cookie_value) && (request_Cookie_name === "" || request_Cookie_name === "session_id")
                            # if Base.isa(session[request_Cookie_value], Core.String) && !(session[request_Cookie_value] === "\r\n\r\n" || session[request_Cookie_value] === "")
                                # Base.Unicode.isspace(session[request_Cookie_value])
                                request_Key = session[request_Cookie_value];
                            # end
                        end
                    end
                end
                # println("request Key: [ " * request_Key * " ].");

                # 提取賬號密碼;
                # request_Nikename::Core.String = "";
                # request_Password::Core.String = "";
                if request_Key !== "" && Base.occursin(":", request_Key)

                    KeyArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                    # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                    # 函數 Base.split(request_Key, ':') 表示用等號字符'='分割字符串為數組;
                    for x in Base.split(request_Key, ':')
                        x = Base.convert(Core.String, x);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                        Base.push!(KeyArray, Base.strip(x));  # 使用 Base.push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
                    end

                    if Core.Int64(Base.length(KeyArray)) === Core.Int64(1)
                        request_Nikename = KeyArray[1];
                    end

                    if Base.length(KeyArray) > 1

                        KeyValue = "";
                        # KeyValue = Base.join(Base.deleteat!(Base.deepcopy(KeyArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        for j = 2:Base.length(KeyArray)
                            if j === 2
                                KeyValue = KeyValue * KeyArray[j];  # 使用星號*拼接字符串;
                            else
                                KeyValue = KeyValue * ":" * KeyArray[j];
                            end
                        end

                        # try
                        #     eval(:(
                        #         begin
                        #             Sys.eval("global " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # Sys.eval("local " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # println($KeyArray[1]);
                        #         end
                        #     ));
                        # catch err
                        #     println(err);
                        # end

                        request_Nikename = KeyArray[1];
                        request_Password = KeyValue;
                        # println("request Nikename: [ " * KeyArray[1] * " ], request Password: [ " * KeyValue * " ].");
                    end
                else
                    request_Nikename = request_Key;
                    # request_Password = "";
                end
                # println("request Nikename: [ " * request_Nikename * " ], request Password: [ " * request_Password * " ].");

            end

            # println(Base.length(request_Url_Query_Dict));
            if Base.length(request_Url_Query_Dict) > 0
                # Base.isa(request_Url_Query_Dict, Base.Dict)

                # 解析獲取客戶端請求 url 中的賬號密碼 "key" 參數;
                # request_Key::Core.String = "";
                # println(Base.haskey(request_Url_Query_Dict, "key"));
                if Base.haskey(request_Url_Query_Dict, "key")
                    # if Base.isa(request_Url_Query_Dict["key"], Core.String) && Base.occursin(':', request_Url_Query_Dict["key"])
                        request_Key = Base.string(request_Url_Query_Dict["key"]);  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
                    # end
                elseif Base.haskey(request_Url_Query_Dict, "Key")
                    request_Key = Base.string(request_Url_Query_Dict["Key"]);  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
                elseif Base.haskey(request_Url_Query_Dict, "KEY")
                    request_Key = Base.string(request_Url_Query_Dict["KEY"]);  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
                end
                # println("request url query key: [ " * request_Key * " ].");

                # 提取賬號密碼;
                # request_Nikename::Core.String = "";
                # request_Password::Core.String = "";
                if request_Key !== "" && Base.occursin(":", request_Key)

                    KeyArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
                    # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                    # 函數 Base.split(request_Key, ':') 表示用等號字符'='分割字符串為數組;
                    for x in Base.split(request_Key, ':')
                        x = Base.convert(Core.String, x);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                        Base.push!(KeyArray, Base.strip(x));  # 使用 Base.push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
                    end

                    if Core.Int64(Base.length(KeyArray)) === Core.Int64(1)
                        request_Nikename = KeyArray[1];
                    end

                    if Base.length(KeyArray) > 1

                        KeyValue = "";
                        # KeyValue = Base.join(Base.deleteat!(Base.deepcopy(KeyArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        for j = 2:Base.length(KeyArray)
                            if j === 2
                                KeyValue = KeyValue * KeyArray[j];  # 使用星號*拼接字符串;
                            else
                                KeyValue = KeyValue * ":" * KeyArray[j];
                            end
                        end

                        # try
                        #     eval(:(
                        #         begin
                        #             Sys.eval("global " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # Sys.eval("local " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # println($KeyArray[1]);
                        #         end
                        #     ));
                        # catch err
                        #     println(err);
                        # end

                        request_Nikename = KeyArray[1];
                        request_Password = KeyValue;
                        # println("request Nikename: [ " * KeyArray[1] * " ], request Password: [ " * KeyValue * " ].");
                    end
                else
                    request_Nikename = request_Key;
                    # request_Password = "";
                end
                # println("request Nikename: [ " * request_Nikename * " ], request Password: [ " * request_Password * " ].");
            end

            # 配置服務器端向客戶端發送的響應數據;
            # Set-Cookie: name=value[; expires=date][; domain=domain][; path=path][; secure];
            # 其中，參數secure選項只是一個標記沒有其它的值，表示一個secure cookie只有當請求是通過SSL和HTTPS創建時，才會發送到伺服器端;
            # 參數domain選項表示cookie作用域，不支持IP數值，只能使用功能變數名稱，指示cookie將要發送到哪個域或那些域中，預設情況下domain會被設置為創建該cookie的頁面所在的功能變數名稱，domain選項被用來擴展cookie值所要發送域的數量;
            # 參數Path選項（The path option），與domain選項相同的是，path指明了在發Cookie消息頭之前，必須在請求資源中存在一個URL路徑，這個比較是通過將path屬性值與請求的URL從頭開始逐字串比較完成的，如果字元匹配，則發送Cookie消息頭;
            # 參數value部分，通常是一個 name=value 格式的字串，通常性的使用方式是以 name=value 的格式來指定cookie的值;
            # 通常cookie的壽命僅限於單一的會話中，流覽器的關閉意味這一次會話的結束，所以會話cookie只存在於流覽器保持打開的狀態之下，參數expires選項用於設定這個cookie壽命（有效時長），一個expires選項會被附加到登錄的cookie中指定一個截止日期，如果expires選項設置了一個過去的時間點，那麼這個cookie會被立即刪除;

            # 需要先加載 Julia 原生的 Dates 模組：using Dates;
            # 函數 Dates.now() 返回當前日期時間對象 2021-06-28T12:12:50.544，使用 Base.string(Dates.now()) 方法，可以返回當前日期時間字符串 2021-06-28T12:12:50.544。
            # 函數 Dates.time() 當前日期時間的 Unix 值 1.652232489777e9，UNIX 時間，或稱爲 POSIX 時間，是 UNIX 或類 UNIX 系統使用的時間表示方式：從 UTC 1970 年 1 月 1 日 0 時 0 分 0 秒起至現在的縂秒數，不考慮閏秒。
            # 函數 Dates.unix2datetime() 將 Unix 時間轉化爲日期（時間）對象，使用 Base.string(Dates.time()) 方法，可以返回當前日期時間字符串 2021-06-28T12:12:50。
            now_date = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
            # println(Base.string(Dates.now()))
            after_1_Days = Dates.DateTime(Dates.year(now_date), Dates.month(now_date), Dates.day(now_date) + Dates.day(1), Dates.hour(now_date), Dates.minute(now_date), Dates.second(now_date), Dates.millisecond(now_date));  # 計算 1 日之後的日期，需要先加載原生 Dates 包 using Dates;
            # println(Base.string(after_1_Days));

            response_Cookie_name::Core.String = "session_id";  # "session_id=request_Key->username:password";
            response_Cookie_value::Core.String = Base64.base64encode("request_Key->" * request_Key; context=nothing);  # "session_id=request_Key->username:password"，將漢字做Base64轉碼Base64.base64encode()，需要事先加載原生的 Base64 模組：using Base64 模組;
            # println(response_Cookie_name * "=" * Core.String(Base64.base64decode(response_Cookie_value)));  # Base64解碼 Base64.base64decode(base64)，需要事先加載原生的 Base64 模組：using Base64 模組;
            response_Cookie_string::Core.String = "";
            if response_Cookie_name === ""
                # response_Cookie_string = "request_Key->" * request_Key * "; expires=" * Base.string(after_1_Days) * "; domain=abc.com; path=/; HTTPOnly;");
                response_Cookie_string = response_Cookie_value * ";" * "expires=" * Base.string(after_1_Days) * ";" * "path=/;";  # 拼接 cookie 字符串值 "session_id=request_Key->username:password; expires=2021-06-28T12:12:50.544; path=/";
            else
                # response_Cookie_string = response_Cookie_name * "=" * "request_Key->" * request_Key * "; expires=" * Base.string(after_1_Days) * "; domain=abc.com; path=/; HTTPOnly;");
                response_Cookie_string = response_Cookie_name * "=" * response_Cookie_value * ";" * "expires=" * Base.string(after_1_Days) * ";" * "path=/;";  # 拼接 cookie 字符串值 "session_id=request_Key->username:password; expires=2021-06-28T12:12:50.544; path=/";
            end
            # println(response_Cookie_string);

            server_info::Core.String = "Julia-" * Base.string(Base.VERSION) * " HTTP.listen!()";  # "Julia-1.9.3 HTTP.listen!()";

            response_statusCode::Core.Int64 = 0;
            response_status_Message::Core.String = "";

            # 配置響應數據，向客戶端發送的響應頭和響應數據;
            # response_head = Base.Dict{Core.String, Core.Any}();
            # response_body_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}();
            response_body_String::Core.String = "";
            response_body_String_len::Core.Int64 = 0;
            # response_body_bytes_Array = Core.Array{Core.UInt8, 1}();  # ::Core.Union{Base.Vector{Core.UInt8}, Core.String, Base.Base.IOBuffer()};
            # response_String::Core.String = "";  # 完整的響應值字符串（包括：響應頭、響應躰）;

            # 當服務器端預設的賬號密碼變量不爲空（key !== ""）時，且客戶端發送的請求賬戶密碼空或錯誤時，發送的響應值;
            # if (key !== "" && key !== ":") && ((request_Authorization === "" && request_Cookie === "" && (Base.length(request_Url_Query_Dict) === 0 || (!Base.haskey(request_Url_Query_Dict, "key") && !Base.haskey(request_Url_Query_Dict, "Key") && !Base.haskey(request_Url_Query_Dict, "KEY")))) || request_Nikename !== Base.convert(Core.String, Base.strip(Base.split(key, ':')[1])) || request_Password !== Base.convert(Core.String, Base.strip(Base.split(key, ':')[2])))
            if (key !== "" && key !== ":") && ((request_Authorization === "" && request_Cookie === "" && request_Key === "") || request_Nikename !== Base.convert(Core.String, Base.strip(Base.split(key, ':')[1])) || request_Password !== Base.convert(Core.String, Base.strip(Base.split(key, ':')[2])))

                # response_body_Dict = Base.Dict{Core.String, Core.String}(
                #     "Server_say" => "No request Headers Authorization or Cookie received.",
                #     "Server_Authorization" => key,
                #     "time" => Base.string(now_date)
                # );
                # response_body_String = JSONstring(response_body_Dict);  # 將Julia的字典Dict對象轉換為JSON字符串，自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
                # # response_body_String = JSON.json(response_body_Dict);  # 將Julia的字典Dict對象轉換為JSON字符串，第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                # # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                # # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                # if request_Authorization === "" && request_Cookie === "" && (Base.length(request_Url_Query_Dict) === 0 || (!Base.haskey(request_Url_Query_Dict, "key") && !Base.haskey(request_Url_Query_Dict, "Key") && !Base.haskey(request_Url_Query_Dict, "KEY")))
                if request_Authorization === "" && request_Cookie === "" && request_Key === ""
                    response_body_String = "{\"Server_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                else request_Nikename !== Base.strip(Base.convert(Core.String, Base.split(key, ':')[1])) || request_Password !== Base.strip(Base.convert(Core.String, Base.split(key, ':')[2]))
                    response_body_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                end
                # response_body_String_len = Base.sizeof(response_body_String);

                response_statusCode = Core.Int64(401);
                response_status_Message = statusMessage(response_statusCode);
                response_Cookie_string = "";  # * "; expires=" * Base.string(after_1_Days) * "; path=/;";  # 拼接 cookie 字符串值;
            end

            # 當服務器端預設的賬號密碼變量爲空（key === ""）時，或者客戶端發送的請求賬戶密碼通過服務器端的預設變量 key 的驗證時，發送的響應值;
            if (key === "" || key === ":") || (request_Nikename === Base.convert(Core.String, Base.strip(Base.split(key, ':')[1])) && request_Password === Base.convert(Core.String, Base.strip(Base.split(key, ':')[2])))

                # 處理請求數據;
                # Julia_Dict = JSONparse(JSON_Str);  # 自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
                # JSON_Str = JSONstring(Julia_Dict);  # 自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
                # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                request_Dict = Base.Dict{Core.String, Core.Any}(
                    "request_body_String" => request_body_String,
                    "request_Nikename" => request_Nikename,
                    "request_Password" => request_Password,
                    "time" => Base.string(now_date)
                );
                # if Base.length(request_head) > 0
                #     # Base.isa(request_head, Base.Dict)

                #     if Base.haskey(request_head, "request_IP")
                #         request_Dict["request_IP"] = request_head["request_IP"];
                #     end
                #     if Base.haskey(request_head, "request_Method")
                #         request_Dict["request_Method"] = request_head["request_Method"];
                #     end
                #     if Base.haskey(request_head, "Target")
                #         request_Dict["Target"] = request_head["Target"];
                #     end
                #     if Base.haskey(request_head, "request_Path")
                #         request_Dict["request_Path"] = request_head["request_Path"];
                #     end
                #     if Base.haskey(request_head, "request_Protocol")
                #         request_Dict["request_Protocol"] = request_head["request_Protocol"];
                #     end
                #     if Base.haskey(request_head, "Authorization")
                #         request_Dict["Authorization"] = request_head["Authorization"];
                #     end
                #     if Base.haskey(request_head, "Cookie")
                #         request_Dict["Cookie"] = request_head["Cookie"];
                #     end
                #     if Base.haskey(request_head, "From")
                #         request_Dict["From"] = request_head["From"];
                #     end
                #     if Base.haskey(request_head, "User-Agent")
                #         request_Dict["User-Agent"] = request_head["User-Agent"];
                #     end
                #     if Base.haskey(request_head, "Host")
                #         request_Dict["Host"] = request_head["Host"];
                #     end
                #     if Base.haskey(request_head, "Accept")
                #         request_Dict["Accept"] = request_head["Accept"];
                #     end
                #     if Base.haskey(request_head, "Accept-Language")
                #         request_Dict["Accept-Language"] = request_head["Accept-Language"];
                #     end
                #     if Base.haskey(request_head, "Accept-Charset")
                #         request_Dict["Accept-Charset"] = request_head["Accept-Charset"];
                #     end
                #     if Base.haskey(request_head, "Date")
                #         request_Dict["Date"] = request_head["Date"];
                #     end
                # end
                for (itemKey, itemValue) in request_head
                    request_Dict[itemKey] = itemValue;
                end

                request_Dict["request_Url_Query_Dict"] = request_Url_Query_Dict;

                # try
                #     eval(:(
                #         begin
                #             Sys.eval("global " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                #             # Sys.eval("local " * ARGSArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                #             # println($ARGSArray[1]);
                #         end
                #     ));
                # catch err
                #     println(err);
                # end

                # 判斷變量 do_Function 是否已經被定義，并且是否為函數類型;
                if Base.@isdefined(do_Function) && Base.typeof(do_Function) <: Core.Function
                    # response_body_Dict = Base.Dict{Core.String, Core.String}(
                    #     "Server_say" => "No request Headers Authorization or Cookie received.",
                    #     "Server_Authorization" => key,
                    #     "time" => Base.string(now_date)
                    # );
                    # response_body_String = JSONstring(response_body_Dict);  # 將Julia的字典Dict對象轉換為JSON字符串，自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
                    # # response_body_String = JSON.json(response_body_Dict);  # 將Julia的字典Dict對象轉換為JSON字符串，第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                    # # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;
                    # # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串：需要先安裝并且導入後：julia> using Pkg; Pkg.add("JSON"); using JSON; 成功之後才能使用;

                    # 無并發，就在當前主進程（Master）中，處理輸入任務隊列;
                    if Core.Int8(number_Worker_threads) <= Core.Int8(0)

                        # 記錄每個協程（Task）纍加的被調用運算的總次數;
                        # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                        # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                        if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid()))
                            # global total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid())]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                            total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid())]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                        else
                            # global total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                            total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                        end

                        try
                            response_statusCode = Core.Int64(200);
                            response_status_Message = statusMessage(response_statusCode);

                            # response_body_String = do_Function(request_head["Target"], request_body_String, request_head);
                            response_body_String = do_Function(request_Dict);
                            # Base.write(Base.stdout, response_body_String);
                            # println(response_body_String);

                            # log_text = "";
                            # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                            #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                            #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * Base.string(response_statusCode) * " .";
                            #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                            #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                            #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                            #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                            #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                            #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * Base.string(response_statusCode) * " .";
                            #     end
                            # else
                            #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * Base.string(request_head["request_IP"]) * Base.string(request_head["Target"]) * Base.string(response_statusCode) * " .";
                            # end
                            # print(log_text * "\n");

                        catch err

                            # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                            if Core.isa(err, Core.InterruptException)

                                print("\n");
                                # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                                # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                                println("[ Ctrl ] + [ c ] received, will be stop the TCP Server.");

                                # # 打印進程被調用數目;
                                # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                                #     if isConcurrencyHierarchy === "Multi-Processes"

                                #         # Base.haskey(collection, key) -> Bool
                                #         # workNum = "worker";
                                #         for k in Base.keys(total_worker_called_number)
                                #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                #         end
                                #         # println(workNum);

                                #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                                #         # Base.haskey(collection, key) -> Bool
                                #         # workNum = "worker";
                                #         for k in Base.keys(total_worker_called_number)
                                #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                #         end
                                #         # println(workNum);

                                #     end

                                #     total_worker_called_number = Core.nothing;
                                # end

                                # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                                # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                                #     # Base.haskey(collection, key) -> Bool
                                #     # for k in Base.keys(worker_queues_Dict)
                                #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                                #     # end

                                #     worker_queues_Dict = Core.nothing;
                                # end

                                println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                                # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
                                # Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;
                                # Base.exit(0);  # 立即中止進程;
                                return ["", server, total_worker_called_number];

                            else

                                # Base.write(stderr, err);
                                # Base.write(Base.stdout, err, "\n");
                                println("自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                                println(err);
                                # println(err.msg);
                                # println(Base.typeof(err));

                                response_statusCode = Core.Int64(500);
                                response_status_Message = statusMessage(response_statusCode);
                                response_body_String = "{\"Server_say\":\"" * "Server calculate data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;

                                # Base.close(sock);  # 中斷當前的這個鏈接;
                                # Base.sleep(time_sleep);
                                # continue;
                                # # break;
                            end
                        end
                        # response_body_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                        # println(response_body_String);
                    end

                    # 開啓并發，在子進程（Worker）中，處理輸入任務隊列;
                    if Core.Int8(number_Worker_threads) > Core.Int8(0)

                        # # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.Task}();
                        # # # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
                        # # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
                    
                        # # 創建通道(Channel);
                        # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                        # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                        # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));  # 用於控制并發數目的通道，寫入一個元素相當於記錄一個啓動的子協程(task)，取出一個元素相當於一個子協程(task)執行完畢，如通道已經滿，則阻塞等待;
                        # # Base.put!(main_to_sub_channel, channel_message_Dict);  # 向通道(Channel)中寫入元素;
                        # # # Base.fetch(main_to_sub_channel);  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
                        # # Base.take!(main_to_sub_channel);  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                        # # Base.close(main_to_sub_channel);  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗;

                        if isConcurrencyHierarchy === "Tasks"

                            # 在 Julia 中，稱協程（Coroutine）為任務（Task）。創建任務（Task）的方式有兩種，
                            # 用構造方法：
                            # taskname = Task(f)
                            # 用構造方法 Task(f) 將一個函數對象 f 封裝成名為 taskname 的任務（Task）。此時要求函數對象 f 必須是無參數的，即沒有參數或所有參數都有預設值。假如函數對象 f 有參數，那麼 f 就變成了運算式，在傳入 Task() 前會被執行，於是傳入 Task() 的不再是函數對象而是執行結果。為解決此問題，可以定義一個 f1()=f(參數)，然後 taskname = Task(f1)。
                            # 巨集（宏）命令 @task 將一個運算式封裝成任務（Task）
                            # taskname = @task 運算式
                            # 用巨集（宏）命令 @task 將一個運算式封裝成名為 taskname 的任務（Task）。注意大小寫。
                            # 創建後，可用 istaskstarted(taskname) 函數和 istaskdone(taskname) 函數查看創建的任務（Task）是否啟動和結束。Task 有五個狀態：runnable（可被啟動）, waiting（阻塞等待中）, queued（正被調度中）, done（執行結束）, failed（執行異常結束）。在 Julia 內部有一個調度器，負責維護 task 運行佇列。用 schedule(taskname) 函數可以把 Task 加入佇列並啟動，隨後會自動返回 done 狀態，表示已完成。
                            # 對於運算式，有個「合二為一」的巨集命令：@async 運算式。它會創建 Task 並直接啟動。例如：
                            # using Distributed
                            # a=zeros(1,5)
                            # 1×5 Array{Float64,2}:
                            # 0.0  0.0  0.0  0.0  0.0
                            # @async fill!(a, 4)
                            # Task (done) @0x00000000063059f0
                            # println(a)
                            # 1×5 Array{Float64,2}:
                            # 4.0  4.0  4.0  4.0  4.0
                            # 1
                            # 2
                            # 3
                            # 4
                            # 5
                            # 6
                            # 7
                            # 8
                            # 9
                            # 10
                            # 11
                            # 12
                            # 可以在被傳給 Task() 的函數對象 f 內部使用某些命令強迫這一 Task 改變狀態，包括：
                            # Base.sleep(N)  睡眠N秒
                            # yield()  請求切換為其他 task
                            # yieldto(taskname)  請求切換為指定的task，一般不建議使用
        
                            # 通道、管道(Channel);
                            # Base.Channel{T=Any}(size::Int=0);
                            # 如果一個 Channel 是空的，讀取的 task（即執行 v = Base.take!(c::Channel) 的 task）會被阻塞直到有新的資料準備好了。
                            # 如果一個 Channel 是滿的，那麼寫入的 task（即執行 Base.put!(c::Channel, v) 的 task）則會被阻塞，直到 Channel 有空餘。
                            # Base.isready(c::Channel) 可以用來檢查一個 channel 中是否有已經準備好的元素，而等待一個元素準備好 則用 Base.wait(r::Future) 函數。
                            # 一個 Channel 一開始處於開啟狀態，也就是說可以被 take! 讀取和 put! 寫入。Base.close(c::Channel[, excp::Exception]) 會關閉一個 Channel，對於一個已經關閉的 Channel，put! 會失敗。
                            # Channel 可以在 for 迴圈中遍歷，此時，迴圈會一直運行直到 Channel 中有資料，遍歷過程中會取遍加入到 Channel 中的所有值。一旦 Channel關閉或者取空了，for 迴圈就會終止。
                            # c = Channel{Int}(10)
                            # foreach(i->put!(c, i), 1:3)
                            # 此時，如果直接用 for 去遍歷通道 c 中的內容，則在讀取完後會一直等待通道(Channel)中有新的資料進來，如果在控制臺REPL上運行，則會停在那裡。
                            # data = [i for i in c]
                            # 如果先把Channel關閉，再用for去遍歷，則會讀出Channel中的內容，因此此時c已經關閉，for不會再等待寫入了。
                            # close(c);
                            # data = [i for i in c]
        
                            # 使用 Base.bind(chnl::Channel, task::Task) 方法，將通道(Channel)的生存期與任務或叫協程(task)相關聯。當協程(task)終止時，通道(Channel)自動關閉。任務中任何未捕獲的異常都會傳播到通道(Channel)上的所有等待者。
                            # 通道(Channel)對象可以獨立於協程(task)終止顯式關閉。終止協程(task)對已關閉的通道(Channel)對象沒有影響。
                            # 當通道(Channel)綁定到多個協程(task)時，第一個終止的協程(task)將關閉通道(Channel)。當多個通道(Channel)綁定到同一個協程(task)時，協程(task)的終止將關閉所有綁定的通道(Channel)。
                            # task = Base.@async foreach(i->put!(c, i), 1:4);
                            # Base.bind(c,task);
                            # for i in c
                            #     Base.@show i
                            #     println(Base.current_task())
                            # end;
                            # i = 1
                            # i = 2
                            # i = 3
                            # i = 4
                            # Base.isopen(c)
                            # false
                            # c2 = Base.Channel{Core.Float64}(32)  # 創建一個長度爲 32，元素(item)類型爲 Float64 的通道(Channel);
                            # Base.put!(c2, 2)  # 向通道(Channel)中寫入元素;
                            # itme1 = Base.fetch(c2)  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
                            # itme1 = Base.take!(c2)  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                            # Base.close(c2)  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗，take!() 和 fetch() 爲空時，將會關閉這個通道;
                            # Base.isready(c2)
        
                            # # 用Channel完成多工（多任務 task）之間的資料交互
                            # # 新建兩個Channel，一個是Int型，一個是Tuple型，對於每個任務，延時一段時間後，開始執行該任務的內容，並將結果放入到results中。
                            # const jobs = Channel{Int}(32)
                            # const results = Channel{Tuple}(32)
                            # function do_work()
                            #     for job_id in jobs
                            #         exec_time = rand()
                            #         Base.sleep(exec_time)  # simulates elapsed time doing actual work typically performed externally.
                            #         put!(results, (job_id, exec_time))
                            #     end
                            # end
                            # # 向jobs中放入數據
                            # function make_jobs(n)
                            #     for i in 1:n
                            #         put!(jobs, i)
                            #     end
                            # end
                            # # 寫入12個資料
                            # n = 12
                            # @async make_jobs(n)
                            # # @async表示把後面的運算式放到Task裡，並加入到程式的執行清單中
                            # # 開四個任務來處理
                            # for i in 1:4
                            #     # start 4 tasks to process requests in parallel
                            #     @async do_work()
                            # end
                            # # 取出4個任務的執行結果
                            # @elapsed while n > 0
                            #     # print out results
                            #     job_id, exec_time = take!(results)
                            #     println("$job_id finished in $(round(exec_time; digits=2)) seconds")
                            #     global n = n - 1
                            # end
                            # # >>1 finished in 0.51 seconds
                            # # 4 finished in 0.62 seconds
                            # # 3 finished in 0.75 seconds
                            # # 2 finished in 0.81 seconds
                            # # 5 finished in 0.55 seconds
                            # # 8 finished in 0.35 seconds
                            # # 6 finished in 0.77 seconds
                            # # 9 finished in 0.38 seconds
                            # # 12 finished in 0.11 seconds
                            # # 7 finished in 0.88 seconds
                            # # 11 finished in 0.25 seconds
                            # # 10 finished in 0.75 seconds

                            # 控制並發數;
                            # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                            Base.put!(control_number_Queues_channel, Core.UInt64(1));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                            worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                "arguments" => request_Dict,
                                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                "label" => "Run",
                                "message" => "Run"
                            );

                            # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                            # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                            Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                            # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                            #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                            # end

                            try
                                # 創建一個子協程（worker task）;
                                f() = funcTask(
                                    # worker_data_Dict,
                                    do_Function,
                                    main_to_sub_channel,
                                    sub_to_main_channel,
                                    control_number_Queues_channel
                                );
                                workerTask = Core.Task(f);  # 創建一個協程（任務）task;
                                workerTask.sticky = false;

                                # # 保存每個被創建的協程(task)在一個字典中;
                                # # 使用 Base.objectid(Base.current_task()) 方法返回當前協程（task） ID 號;
                                # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                # if Base.haskey(worker_queues_Dict, Base.string(Base.objectid(workerTask)))
                                #     # global worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                #     worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                # else
                                #     # global worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                #     worker_queues_Dict[Base.string(Base.objectid(workerTask))] = workerTask;
                                # end
                                # # 記錄每個綫程纍加的被調用運算的總次數;
                                # # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                # if Base.haskey(total_worker_called_number, Base.string(Base.objectid(workerTask)))
                                #     # global total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(workerTask))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                #     total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(total_worker_called_number[Base.string(Base.objectid(workerTask))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                # else
                                #     # global total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                #     total_worker_called_number[Base.string(Base.objectid(workerTask))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                # end

                                Base.schedule(workerTask);  # 用 Base.schedule(t::Task, [val]; error=false) 函數把未啓動的協程(Task)加入等待執行的隊列並啓動，隨後會自動返回 done 狀態，表示已經執行完畢;
                                # Base.wait(workerTask);  # 阻塞主進程後面的代碼執行，直到該子協程 workerTask 運行完畢;
                                # 用 istaskstarted(taskname) 和 istaskdone(taskname) 查看 Task 是否已經啓動和結束。Task 有五個狀態：runnable（可被啓動）, waiting（阻塞等待中）, queued（正被調度中）, done（執行結束）, failed（執行異常結束）。Julia 内部有一個調度器，負責維護 task 運行隊列;

                                # 讀出輸出通道中子協程(task)返回的結果;
                                # Base.take!(sub_to_main_channel);
                                # 這裏 for 結構本質上是一串自動執行的從通道中取出元素 take!() 的操作，和 take!() 操作一樣會移除元素。當通道 Channel 中元素取為空時，for 結構會阻塞;
                                # 使用 close(channelname) 强制關閉通道 Channel 的入口並釋放所有 put!() 和 take!() 的阻塞，此時 for 循環取完通道 Channel 中元素為空時，將不再阻塞會自行退出;
                                for result_Dict in sub_to_main_channel

                                    # result_Dict = Base.Dict{Core.String, Core.Any}(
                                    #     # "do_Function" => do_Function,  # worker_Data_Dict["do_Function"]， # do_data ;
                                    #     "result_data" => response_body_String,
                                    #     "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                    #     "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                    #     "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                    #     "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #     "label" => result[1],
                                    #     "message" => "Function [ do_Function ] return " * result[1] * ".",
                                    #     "request_Arguments" => request_Arguments = Base.Dict{Core.String, Core.String}(
                                    #         "request_body_String" => request_body_String,
                                    #         "request_Nikename" => request_Nikename,
                                    #         "request_Password" => request_Password,
                                    #         "time" => Base.string(now_date),
                                    #         "request_IP" => request_head["request_IP"],
                                    #         "request_Method" => request_head["request_Method"],
                                    #         "request_Path" => request_head["Target"],
                                    #         "request_Protocol" => request_head["request_Protocol"].
                                    #         "Authorization" => request_head["Authorization"],
                                    #         "Cookie" => request_head["Cookie"],
                                    #         "From" => request_head["From"],
                                    #         "User-Agent" => request_head["User-Agent"],
                                    #         "Host" => request_head["Host"],
                                    #         "Accept" => request_head["Accept"],
                                    #         "Accept-Language" => request_head["Accept-Language"],
                                    #         "Accept-Charset" => request_head["Accept-Charset"],
                                    #         "Date" => request_head["Date"]
                                    #     )
                                    # );

                                    if Base.isa(result_Dict, Base.Dict)

                                        # 記錄每個協程（Task）纍加的被調用運算的總次數;
                                        # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                        if Base.haskey(total_worker_called_number, Base.string(result_Dict["threadID"]))
                                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                        else
                                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                        end
                                        # if Base.haskey(total_worker_called_number, Base.string(result_Dict["taskID"]))
                                        #     # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                        #     total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                        # else
                                        #     # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                        #     total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                        # end
    
                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "error"
                                            if Base.haskey(result_Dict, "taskID") && result_Dict["taskID"] !== Core.nothing && Base.isa(result_Dict["taskID"], Core.String) && result_Dict["taskID"] !== ""
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                end
                                            else
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task return error.");
                                                end
                                            end
    
                                            response_statusCode = Core.Int64(500);
                                            response_status_Message = statusMessage(response_statusCode);

                                            # Base.close(sock);  # 中斷當前的這個鏈接;
                                            # Base.sleep(time_sleep);
                                            # continue;
                                            # # break;
                                        end
    
                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "success"
                                            response_statusCode = Core.Int64(200);
                                            response_status_Message = statusMessage(response_statusCode);
                                        end
    
                                        response_body_String =  response_body_String * Base.string(result_Dict["result_data"]);
                                        # response_body_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                        # println(response_body_String);

                                        # log_text = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * Base.string(response_statusCode) * " .";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * Base.string(request_head["request_IP"]) * Base.string(request_head["Target"]) * Base.string(response_statusCode) * " .";
                                        # end
                                        # print(log_text * "\n");

                                        # response_body_String = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                        # Base.GC.gc();  # 内存回收函數 gc();

                                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        # println(Base.string(nowTime));
                                        # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # log_text::Core.String = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " >.";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " .";
                                        # end
                                        # print(log_text * "\n");
                                        # log_file = "";  # 日志文檔;
                                        # # 同步寫入用於記錄過程的日志文檔;
                                        # try
                                        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #     # # write(filename::AbstractString, x)
                                        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                        #     # println(numBytes);
                                        #     # println(Base.stat(log_file).size);
                                        #     # println(Base.stat(log_file).mtime);
                                        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #     # println(Base.stat(log_file).ctime);
                                        #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #     # # Base.countlines — Function
                                        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #     # println(Base.countlines(log_file, eol='\\n'));

                                        #     fWIO = Base.open(log_file, "a+");
                                        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                        #     # Keyword	Description				Default
                                        #     # read		open for reading		!write
                                        #     # write		open for writing		truncate | append
                                        #     # create	create if non-existent	!read & write | truncate | append
                                        #     # truncate	truncate to zero size	!read & write
                                        #     # append	seek to end				false

                                        #     # Mode	Description						Keywords
                                        #     # r		read							none
                                        #     # w		write, create, truncate			write = true
                                        #     # a		write, create, append			append = true
                                        #     # r+	read, write						read = true, write = true
                                        #     # w+	read, write, create, truncate	truncate = true, read = true
                                        #     # a+	read, write, create, append		append = true, read = true

                                        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                        #     if Base.iswritable(fWIO)
                                        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #         println(numBytes);
                                        #         println(Base.stat(log_file).size);
                                        #         println(Base.stat(log_file).mtime);
                                        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #         println(Base.stat(log_file).ctime);
                                        #         # Base.displaysize([io::IO]) -> (lines, columns)
                                        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #         # Base.countlines — Function
                                        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #         println(Base.countlines(log_file, eol='\\n'));
                                        #     end

                                        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（Base.IOBuffer）;
                                        #     # io = Base.Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（Base.IOBuffer）;
                                        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                        #     # Base.ismarked(io);  # Return true if stream s is marked;
                                        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                        #     # Base.close(io);  # 關閉緩衝區;
                                        #     # println(a)
                                        #     # Base.redirect_stdout — Function
                                        #     # redirect_stdout([stream]) -> (rd, wr)
                                        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                        #     # If called with the optional stream argument, then returns stream itself.
                                        #     # Base.redirect_stdout — Method
                                        #     # redirect_stdout(f::Function, stream)
                                        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                        #     # Base.redirect_stderr — Function
                                        #     # redirect_stderr([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stderr.
                                        #     # Base.redirect_stderr — Method
                                        #     # redirect_stderr(f::Function, stream)
                                        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                        #     # Base.redirect_stdin — Function
                                        #     # redirect_stdin([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                        #     # Base.redirect_stdin — Method
                                        #     # redirect_stdin(f::Function, stream)
                                        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                        # catch err
                                        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                        #     println(err);
                                        #     # println(Base.typeof(err));

                                        #     # Julia提供了許多類型的錯誤：
                                        #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                                        #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                                        #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                                        #     # DivideError：這是數字除以0時的結果。
                                        #     # DomainError：有效域之外的參數。
                                        #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                                        #     # InexactError：嘗試進行精確類型轉換失敗。
                                        #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                                        #     # LoadError：載入檔時發生錯誤。
                                        #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                                        #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                                        #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                                        #     # OverflowError：當操作結果太大時會發生這種情況。
                                        #     # ParseError：解析給定運算式時出現問題。
                                        #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                                        #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                                        #     # UndefRefError：未知引用。
                                        #     # UndefVarError：對不存在的變數進行未知引用。
                                        #     # InitError：調用模組的init方法時出現此錯誤。
                                        #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                                        #     # NullException：嘗試訪問Null值
                                        #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                                        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                        # finally
                                        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                        #     if Base.eof(fWIO)
                                        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                        #     end
                                        # end
                                    end

                                    # 使用 Base.isready(c::Channel) 函數判斷通道中元素是否已經取空，如果已經取空 Base.isready(c::Channel) 返回為 false 值，則跳出 for 循環，如果一個空通道從未寫入過元素，則 Base.isready(sub_to_main_channel) 值爲 true，因此會一直阻塞等待不會跳出循環;
                                    if !Base.isready(sub_to_main_channel)
                                        break;
                                    end
                                end
                                # response_body_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                # println(response_body_String);

                            catch err

                                while Base.isreadable(sub_to_main_channel)
                                    Base.take!(sub_to_main_channel);
                                end
                                # for result_Dict in sub_to_main_channel
                                # end
                                # for i = 1:Base.length(sub_to_main_channel)
                                #     Base.take!(sub_to_main_channel);
                                # end

                                # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                                if Core.isa(err, Core.InterruptException)

                                    print("\n");
                                    # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                                    # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                                    println("[ Ctrl ] + [ c ] received, will be stop the TCP Server.");

                                    # # 打印進程被調用數目;
                                    # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                                    #     if isConcurrencyHierarchy === "Multi-Processes"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     end

                                    #     total_worker_called_number = Core.nothing;
                                    # end

                                    # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                                    # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                                    #     # Base.haskey(collection, key) -> Bool
                                    #     # for k in Base.keys(worker_queues_Dict)
                                    #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                                    #     # end

                                    #     worker_queues_Dict = Core.nothing;
                                    # end

                                    println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                                    # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
                                    # Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;
                                    # Base.exit(0);  # 立即中止進程;
                                    return ["", server, total_worker_called_number];

                                else

                                    # Base.write(stderr, err);
                                    # Base.write(Base.stdout, err, "\n");
                                    println("多協程並發（multi-task）時，工作協程（worker-task）中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                                    println(err);
                                    # println(err.msg);
                                    # println(Base.typeof(err));

                                    response_statusCode = Core.Int64(500);
                                    response_status_Message = statusMessage(response_statusCode);
                                    # response_body_String = "{\"Server_say\":\"" * "Server calculate data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;

                                    # Base.close(sock);  # 中斷當前的這個鏈接;
                                    # Base.sleep(time_sleep);
                                    # continue;
                                    # # break;
                                end
                            end
                        end

                        # 需要注意，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
                        if isConcurrencyHierarchy === "Multi-Threading"

                            # 必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
                            # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
                            # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
                            # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
                            # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;

                            # 通道、管道(Channel);
                            # Base.Channel{T=Any}(size::Int=0);
                            # 如果一個 Channel 是空的，讀取的 task（即執行 v = Base.take!(c::Channel) 的 task）會被阻塞直到有新的資料準備好了。
                            # 如果一個 Channel 是滿的，那麼寫入的 task（即執行 Base.put!(c::Channel, v) 的 task）則會被阻塞，直到 Channel 有空餘。
                            # Base.isready(c::Channel) 可以用來檢查一個 channel 中是否有已經準備好的元素，而等待一個元素準備好 則用 Base.wait(r::Future) 函數。
                            # 一個 Channel 一開始處於開啟狀態，也就是說可以被 take! 讀取和 put! 寫入。Base.close(c::Channel[, excp::Exception]) 會關閉一個 Channel，對於一個已經關閉的 Channel，put! 會失敗。
                            # Channel 可以在 for 迴圈中遍歷，此時，迴圈會一直運行直到 Channel 中有資料，遍歷過程中會取遍加入到 Channel 中的所有值。一旦 Channel關閉或者取空了，for 迴圈就會終止。
                            # c = Channel{Int}(10)
                            # foreach(i->put!(c, i), 1:3)
                            # 此時，如果直接用 for 去遍歷通道 c 中的內容，則在讀取完後會一直等待通道(Channel)中有新的資料進來，如果在控制臺REPL上運行，則會停在那裡。
                            # data = [i for i in c]
                            # 如果先把Channel關閉，再用for去遍歷，則會讀出Channel中的內容，因此此時c已經關閉，for不會再等待寫入了。
                            # close(c);
                            # data = [i for i in c]

                            # 使用 Base.bind(chnl::Channel, task::Task) 方法，將通道(Channel)的生存期與任務或叫協程(task)相關聯。當協程(task)終止時，通道(Channel)自動關閉。任務中任何未捕獲的異常都會傳播到通道(Channel)上的所有等待者。
                            # 通道(Channel)對象可以獨立於協程(task)終止顯式關閉。終止協程(task)對已關閉的通道(Channel)對象沒有影響。
                            # 當通道(Channel)綁定到多個協程(task)時，第一個終止的協程(task)將關閉通道(Channel)。當多個通道(Channel)綁定到同一個協程(task)時，協程(task)的終止將關閉所有綁定的通道(Channel)。
                            # task = Base.@async foreach(i->put!(c, i), 1:4);
                            # Base.bind(c,task);
                            # for i in c
                            #     Base.@show i
                            #     println(Base.current_task())
                            # end;
                            # i = 1
                            # i = 2
                            # i = 3
                            # i = 4
                            # Base.isopen(c)
                            # false
                            # c2 = Base.Channel{Core.Float64}(32)  # 創建一個長度爲 32，元素(item)類型爲 Float64 的通道(Channel);
                            # Base.put!(c2, 2)  # 向通道(Channel)中寫入元素;
                            # itme1 = Base.fetch(c2)  # 使用 fetch() 函數只能讀取到通道(Channel)中的第一個元素，但不會把該數據從通道(Channel)中刪除;
                            # itme1 = Base.take!(c2)  # 使用 take!() 函數會会讀取到通道(Channel)中的第一個元素後並將第一個元素從通道(Channel)中刪除;
                            # Base.close(c2)  # 關閉通道(Channel)，通道被關閉後不能再寫入元素，但能繼續讀出元素，也就是說可以被 take!() 讀取，但對其 put!() 寫入會失敗，take!() 和 fetch() 爲空時，將會關閉這個通道;
                            # Base.isready(c2)

                            # # 用Channel完成多工（多任務 task）之間的資料交互
                            # # 新建兩個Channel，一個是Int型，一個是Tuple型，對於每個任務，延時一段時間後，開始執行該任務的內容，並將結果放入到results中。
                            # const jobs = Channel{Int}(32)
                            # const results = Channel{Tuple}(32)
                            # function do_work()
                            #     for job_id in jobs
                            #         exec_time = rand()
                            #         Base.sleep(exec_time)  # simulates elapsed time doing actual work typically performed externally.
                            #         put!(results, (job_id, exec_time))
                            #     end
                            # end
                            # # 向jobs中放入數據
                            # function make_jobs(n)
                            #     for i in 1:n
                            #         put!(jobs, i)
                            #     end
                            # end
                            # # 寫入12個資料
                            # n = 12
                            # @async make_jobs(n)
                            # # @async表示把後面的運算式放到Task裡，並加入到程式的執行清單中
                            # # 開四個任務來處理
                            # for i in 1:4
                            #     # start 4 tasks to process requests in parallel
                            #     @async do_work()
                            # end
                            # # 取出4個任務的執行結果
                            # @elapsed while n > 0
                            #     # print out results
                            #     job_id, exec_time = take!(results)
                            #     println("$job_id finished in $(round(exec_time; digits=2)) seconds")
                            #     global n = n - 1
                            # end
                            # # >>1 finished in 0.51 seconds
                            # # 4 finished in 0.62 seconds
                            # # 3 finished in 0.75 seconds
                            # # 2 finished in 0.81 seconds
                            # # 5 finished in 0.55 seconds
                            # # 8 finished in 0.35 seconds
                            # # 6 finished in 0.77 seconds
                            # # 9 finished in 0.38 seconds
                            # # 12 finished in 0.11 seconds
                            # # 7 finished in 0.88 seconds
                            # # 11 finished in 0.25 seconds
                            # # 10 finished in 0.75 seconds

                            # 控制並發數;
                            # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                            Base.put!(control_number_Queues_channel, Core.UInt64(1));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                            worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                "arguments" => request_Dict,
                                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                "label" => "Run",
                                "message" => "Run"
                            );

                            # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                            # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                            Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                            # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                            #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                            # end

                            try
                                # 創建一個子綫程（worker thread）;
                                # 需要注意，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
                                # workerThread = Base.Threads.@spawn begin
                                #     funcTask(
                                #         # worker_data_Dict,
                                #         do_Function,
                                #         main_to_sub_channel,
                                #         sub_to_main_channel,
                                #         control_number_Queues_channel
                                #     );
                                # end
                                workerThread = Base.Threads.@spawn funcTask(
                                    # worker_data_Dict,
                                    do_Function,
                                    main_to_sub_channel,
                                    sub_to_main_channel,
                                    control_number_Queues_channel
                                );
                                # r = Base.fetch(workerThread);  # 等待讀取子綫程運行完畢後的返回值，阻塞後面的代碼執行;
                                # Base.wait(workerThread);  # 阻塞主進程後面的代碼執行，直到該子綫程 workerThread 運行完畢;

                                # # 保存每個被創建的綫程（worker thread）在一個字典中;
                                # # 使用 Base.Threads.threadid() 方法返回當前綫程 ID 號;
                                # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                # if Base.haskey(worker_queues_Dict, Base.string(Base.Threads.threadid(workerThread)))
                                #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                # else
                                #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                # end
                                # # 記錄每個綫程纍加的被調用運算的總次數;
                                # # 使用 Base.Threads.threadid() 方法返回當前子綫程(thread) ID 號;
                                # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                # if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid(workerThread)))
                                #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                # else
                                #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                # end

                                # # Base.Threads.@threads for...end
                                # # A macro to parallelize a for-loop to run with multiple threads. This spawns nthreads() number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.
                                # # 使用 Base.Threads.@threads for...end 方法創建子綫程，多綫程并發執行 for...end 循環，在每次 for 循環中具體動作;
                                # Base.Threads.@threads for i in 1:input_queues_length

                                #     if Base.isa(input_queues_array[i], Base.Dict)

                                #         # 控制並發數;
                                #         # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                                #         Base.put!(control_number_Queues_channel, Core.UInt64(i));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                                #         worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                #             # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                #             "arguments" => input_queues_array[i]
                                #             );

                                #         # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                                #         # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                                #         Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                                #         # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                                #         #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                                #         # end

                                #         resultArray = funcTask(
                                #             # worker_data_Dict,
                                #             do_Function,
                                #             main_to_sub_channel,
                                #             sub_to_main_channel,
                                #             control_number_Queues_channel
                                #             );
                                #         # println(resultArray);

                                #         # # 保存每個被創建的綫程（worker thread）在一個字典中;
                                #         # # 使用 Base.Threads.threadid() 方法返回當前綫程 ID 號;
                                #         # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                #         # if Base.haskey(worker_queues_Dict, Base.string(Base.Threads.threadid(workerThread)))
                                #         #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #         #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #         # else
                                #         #     # global worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #         #     worker_queues_Dict[Base.string(Base.Threads.threadid(workerThread))] = workerThread;
                                #         # end
                                #         # # 記錄每個綫程纍加的被調用運算的總次數;
                                #         # # 使用 Base.Threads.threadid() 方法返回當前子綫程(thread) ID 號;
                                #         # # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                #         # if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid(workerThread)))
                                #         #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                #         #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))]) + Core.UInt64(1);  # 每被調用一次，就在相應子進程號下加 1 ;
                                #         # else
                                #         #     # global total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                #         #     total_worker_called_number[Base.string(Base.Threads.threadid(workerThread))] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                #         # end
                                #     end
                                # end


                                # 讀出輸出通道中子協程(task)返回的結果;
                                # Base.take!(sub_to_main_channel);
                                # 這裏 for 結構本質上是一串自動執行的從通道中取出元素 take!() 的操作，和 take!() 操作一樣會移除元素。當通道 Channel 中元素取為空時，for 結構會阻塞;
                                # 使用 close(channelname) 强制關閉通道 Channel 的入口並釋放所有 put!() 和 take!() 的阻塞，此時 for 循環取完通道 Channel 中元素為空時，將不再阻塞會自行退出;
                                for result_Dict in sub_to_main_channel

                                    # result_Dict = Base.Dict{Core.String, Core.Any}(
                                    #     # "do_Function" => do_Function,  # worker_Data_Dict["do_Function"]， # do_data ;
                                    #     "result_data" => response_body_String,
                                    #     "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                    #     "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                    #     "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                    #     "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #     "label" => result[1],
                                    #     "message" => "Function [ do_Function ] return " * result[1] * ".",
                                    #     "request_Arguments" => request_Arguments = Base.Dict{Core.String, Core.String}(
                                    #         "request_body_String" => request_body_String,
                                    #         "request_Nikename" => request_Nikename,
                                    #         "request_Password" => request_Password,
                                    #         "time" => Base.string(now_date),
                                    #         "request_IP" => request_head["request_IP"],
                                    #         "request_Method" => request_head["request_Method"],
                                    #         "request_Path" => request_head["Target"],
                                    #         "request_Protocol" => request_head["request_Protocol"].
                                    #         "Authorization" => request_head["Authorization"],
                                    #         "Cookie" => request_head["Cookie"],
                                    #         "From" => request_head["From"],
                                    #         "User-Agent" => request_head["User-Agent"],
                                    #         "Host" => request_head["Host"],
                                    #         "Accept" => request_head["Accept"],
                                    #         "Accept-Language" => request_head["Accept-Language"],
                                    #         "Accept-Charset" => request_head["Accept-Charset"],
                                    #         "Date" => request_head["Date"]
                                    #     )
                                    # );

                                    if Base.isa(result_Dict, Base.Dict)

                                        # 記錄每個協程（Task）纍加的被調用運算的總次數;
                                        # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                        if Base.haskey(total_worker_called_number, Base.string(result_Dict["threadID"]))
                                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["threadID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                        else
                                            # global total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                            total_worker_called_number[Base.string(result_Dict["threadID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                        end

                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "error"
                                            if Base.haskey(result_Dict, "taskID") && result_Dict["taskID"] !== Core.nothing && Base.isa(result_Dict["taskID"], Core.String) && result_Dict["taskID"] !== ""
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                end
                                            else
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task return error.");
                                                end
                                            end
    
                                            response_statusCode = Core.Int64(500);
                                            response_status_Message = statusMessage(response_statusCode);

                                            # Base.close(sock);  # 中斷當前的這個鏈接;
                                            # Base.sleep(time_sleep);
                                            # continue;
                                            # # break;
                                        end

                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "success"
                                            response_statusCode = Core.Int64(200);
                                            response_status_Message = statusMessage(response_statusCode);
                                        end

                                        response_body_String =  response_body_String * Base.string(result_Dict["result_data"]);
                                        # response_body_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                        # println(response_body_String);

                                        # log_text = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * Base.string(response_statusCode) * " .";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * Base.string(request_head["request_IP"]) * Base.string(request_head["Target"]) * Base.string(response_statusCode) * " .";
                                        # end
                                        # print(log_text * "\n");

                                        # response_body_String = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                        # Base.GC.gc();  # 内存回收函數 gc();

                                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        # println(Base.string(nowTime));
                                        # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # log_text::Core.String = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " >.";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " .";
                                        # end
                                        # print(log_text * "\n");
                                        # log_file = "";  # 日志文檔;
                                        # # 同步寫入用於記錄過程的日志文檔;
                                        # try
                                        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #     # # write(filename::AbstractString, x)
                                        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                        #     # println(numBytes);
                                        #     # println(Base.stat(log_file).size);
                                        #     # println(Base.stat(log_file).mtime);
                                        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #     # println(Base.stat(log_file).ctime);
                                        #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #     # # Base.countlines — Function
                                        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #     # println(Base.countlines(log_file, eol='\\n'));

                                        #     fWIO = Base.open(log_file, "a+");
                                        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                        #     # Keyword	Description				Default
                                        #     # read		open for reading		!write
                                        #     # write		open for writing		truncate | append
                                        #     # create	create if non-existent	!read & write | truncate | append
                                        #     # truncate	truncate to zero size	!read & write
                                        #     # append	seek to end				false

                                        #     # Mode	Description						Keywords
                                        #     # r		read							none
                                        #     # w		write, create, truncate			write = true
                                        #     # a		write, create, append			append = true
                                        #     # r+	read, write						read = true, write = true
                                        #     # w+	read, write, create, truncate	truncate = true, read = true
                                        #     # a+	read, write, create, append		append = true, read = true

                                        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                        #     if Base.iswritable(fWIO)
                                        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #         println(numBytes);
                                        #         println(Base.stat(log_file).size);
                                        #         println(Base.stat(log_file).mtime);
                                        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #         println(Base.stat(log_file).ctime);
                                        #         # Base.displaysize([io::IO]) -> (lines, columns)
                                        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #         # Base.countlines — Function
                                        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #         println(Base.countlines(log_file, eol='\\n'));
                                        #     end

                                        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（Base.IOBuffer）;
                                        #     # io = Base.Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（Base.IOBuffer）;
                                        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                        #     # Base.ismarked(io);  # Return true if stream s is marked;
                                        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                        #     # Base.close(io);  # 關閉緩衝區;
                                        #     # println(a)
                                        #     # Base.redirect_stdout — Function
                                        #     # redirect_stdout([stream]) -> (rd, wr)
                                        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                        #     # If called with the optional stream argument, then returns stream itself.
                                        #     # Base.redirect_stdout — Method
                                        #     # redirect_stdout(f::Function, stream)
                                        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                        #     # Base.redirect_stderr — Function
                                        #     # redirect_stderr([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stderr.
                                        #     # Base.redirect_stderr — Method
                                        #     # redirect_stderr(f::Function, stream)
                                        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                        #     # Base.redirect_stdin — Function
                                        #     # redirect_stdin([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                        #     # Base.redirect_stdin — Method
                                        #     # redirect_stdin(f::Function, stream)
                                        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                        # catch err
                                        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                        #     println(err);
                                        #     # println(Base.typeof(err));

                                        #     # Julia提供了許多類型的錯誤：
                                        #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                                        #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                                        #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                                        #     # DivideError：這是數字除以0時的結果。
                                        #     # DomainError：有效域之外的參數。
                                        #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                                        #     # InexactError：嘗試進行精確類型轉換失敗。
                                        #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                                        #     # LoadError：載入檔時發生錯誤。
                                        #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                                        #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                                        #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                                        #     # OverflowError：當操作結果太大時會發生這種情況。
                                        #     # ParseError：解析給定運算式時出現問題。
                                        #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                                        #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                                        #     # UndefRefError：未知引用。
                                        #     # UndefVarError：對不存在的變數進行未知引用。
                                        #     # InitError：調用模組的init方法時出現此錯誤。
                                        #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                                        #     # NullException：嘗試訪問Null值
                                        #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                                        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                        # finally
                                        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                        #     if Base.eof(fWIO)
                                        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                        #     end
                                        # end
                                    end

                                    # 使用 Base.isready(c::Channel) 函數判斷通道中元素是否已經取空，如果已經取空 Base.isready(c::Channel) 返回為 false 值，則跳出 for 循環，如果一個空通道從未寫入過元素，則 Base.isready(sub_to_main_channel) 值爲 true，因此會一直阻塞等待不會跳出循環;
                                    if !Base.isready(sub_to_main_channel)
                                        break;
                                    end
                                end
                                # response_body_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                # println(response_body_String);

                            catch err
                                
                                while Base.isreadable(sub_to_main_channel)
                                    Base.take!(sub_to_main_channel);
                                end
                                # for result_Dict in sub_to_main_channel
                                # end
                                # for i = 1:Base.length(sub_to_main_channel)
                                #     Base.take!(sub_to_main_channel);
                                # end

                                # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                                if Core.isa(err, Core.InterruptException)

                                    print("\n");
                                    # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                                    # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                                    println("[ Ctrl ] + [ c ] received, will be stop the TCP Server.");

                                    # # 打印進程被調用數目;
                                    # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                                    #     if isConcurrencyHierarchy === "Multi-Processes"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     end

                                    #     total_worker_called_number = Core.nothing;
                                    # end

                                    # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                                    # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                                    #     # Base.haskey(collection, key) -> Bool
                                    #     # for k in Base.keys(worker_queues_Dict)
                                    #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                                    #     # end

                                    #     worker_queues_Dict = Core.nothing;
                                    # end

                                    println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                                    # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
                                    # Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;
                                    # Base.exit(0);  # 立即中止進程;
                                    return ["", server, total_worker_called_number];

                                else

                                    # Base.write(stderr, err);
                                    # Base.write(Base.stdout, err, "\n");
                                    println("多綫程並發（multi-thread）時，工作綫程（worker-thread）中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                                    println(err);
                                    # println(err.msg);
                                    # println(Base.typeof(err));

                                    response_statusCode = Core.Int64(500);
                                    response_status_Message = statusMessage(response_statusCode);
                                    # response_body_String = "{\"Server_say\":\"" * "Server calculate data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;

                                    # Base.close(sock);  # 中斷當前的這個鏈接;
                                    # Base.sleep(time_sleep);
                                    # continue;
                                    # # break;
                                end
                            end
                        end

                        # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                        if isConcurrencyHierarchy === "Multi-Processes"

                            # 控制並發數;
                            # control_number_Queues_channel = Base.Channel{Core.UInt64}(Core.UInt64(number_Worker_threads));
                            Base.put!(control_number_Queues_channel, Core.UInt64(1));  # 通道 control_number_Queues_channel 為自定義用於控制并發數目，向通道(Channel)中寫入元素，即相當於記錄增加一個子協程task數目;

                            worker_data_Dict = Base.Dict{Core.String, Core.Any}(
                                # "do_Function" => do_Function,  # input_queues_array[i]["do_Function"];
                                "arguments" => request_Dict,
                                "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                "label" => "Run",
                                "message" => "Run"
                            );

                            # main_to_sub_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));  # 創建一個長度爲 number_Worker_threads，元素類型爲 Base.Dict{Core.String, Core.Any} 的通道(Channel);
                            # sub_to_main_channel = Base.Channel{Base.Dict{Core.String, Core.Any}}(Core.UInt64(number_Worker_threads));
                            Base.put!(main_to_sub_channel, worker_data_Dict);  # 向通道(Channel)中寫入元素;
                            # if Core.UInt64(i) === Core.UInt64(input_queues_length)
                            #     Base.close(main_to_sub_channel);  # 關閉通道入口，使讀出端的 for 循環讀完畢後，退出循環不在等待阻塞;
                            # end

                            try
                                # # 子進程 2 運行輪詢 funcTask 函數;
                                # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                # # Distributed.@spawnat p expr
                                # function func_wp2(
                                #     funcTask,
                                #     # worker_data_Dict::Base.Dict{Core.String, Core.Any},
                                #     do_Function,
                                #     main_to_sub_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
                                #     sub_to_main_channel::Base.Channel{Base.Dict{Core.String, Core.Any}},
                                #     control_number_Queues_channel::Base.Channel{Core.UInt64}
                                # )
                                # # wp2 = Distributed.@spawnat 2 begin

                                #     function func_Exit()
                                #         # Base.close(sub_to_main_channel);
                                #         # Base.exit(0);
                                #     end
                                #     Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

                                #     funcTask(
                                #         # worker_data_Dict,
                                #         do_Function,
                                #         main_to_sub_channel,
                                #         sub_to_main_channel,
                                #         control_number_Queues_channel
                                #     );
                                # end
                                # # Distributed.remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future;
                                # wp2 = Distributed.remotecall(
                                #     func_wp2,
                                #     2,
                                #     funcTask,
                                #     # worker_data_Dict,
                                #     do_Function,
                                #     main_to_sub_channel,
                                #     sub_to_main_channel,
                                #     control_number_Queues_channel
                                # );
                                # r2 = Base.fetch(wp2);

                                # Base.Threads.@spawn
                                # Create and run a Task on any available thread. To wait for the task to finish, call wait on the result of this macro, or call fetch to wait and then obtain its return value.
                                # Values can be interpolated into @spawn via $, which copies the value directly into the constructed underlying closure. This allows you to insert the value of a variable, isolating the asynchronous code from changes to the variable's value in the current task.
                                # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                wp = Base.Threads.@spawn funcTask(
                                    # worker_data_Dict,
                                    do_Function,
                                    main_to_sub_channel,
                                    sub_to_main_channel,
                                    control_number_Queues_channel
                                );
                                # r = Base.fetch(wp);


                                # 讀出輸出通道中子協程(task)返回的結果;
                                # Base.take!(sub_to_main_channel);
                                # 這裏 for 結構本質上是一串自動執行的從通道中取出元素 take!() 的操作，和 take!() 操作一樣會移除元素。當通道 Channel 中元素取為空時，for 結構會阻塞;
                                # 使用 close(channelname) 强制關閉通道 Channel 的入口並釋放所有 put!() 和 take!() 的阻塞，此時 for 循環取完通道 Channel 中元素為空時，將不再阻塞會自行退出;
                                for result_Dict in sub_to_main_channel

                                    # result_Dict = Base.Dict{Core.String, Core.Any}(
                                    #     # "do_Function" => do_Function,  # worker_Data_Dict["do_Function"]， # do_data ;
                                    #     "result_data" => response_body_String,
                                    #     "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
                                    #     "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
                                    #     "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
                                    #     "time" => Base.string(nowTime),  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                    #     "label" => result[1],
                                    #     "message" => "Function [ do_Function ] return " * result[1] * ".",
                                    #     "request_Arguments" => request_Arguments = Base.Dict{Core.String, Core.String}(
                                    #         "request_body_String" => request_body_String,
                                    #         "request_Nikename" => request_Nikename,
                                    #         "request_Password" => request_Password,
                                    #         "time" => Base.string(now_date),
                                    #         "request_IP" => request_head["request_IP"],
                                    #         "request_Method" => request_head["request_Method"],
                                    #         "request_Path" => request_head["Target"],
                                    #         "request_Protocol" => request_head["request_Protocol"].
                                    #         "Authorization" => request_head["Authorization"],
                                    #         "Cookie" => request_head["Cookie"],
                                    #         "From" => request_head["From"],
                                    #         "User-Agent" => request_head["User-Agent"],
                                    #         "Host" => request_head["Host"],
                                    #         "Accept" => request_head["Accept"],
                                    #         "Accept-Language" => request_head["Accept-Language"],
                                    #         "Accept-Charset" => request_head["Accept-Charset"],
                                    #         "Date" => request_head["Date"]
                                    #     )
                                    # );

                                    if Base.isa(result_Dict, Base.Dict)

                                        # 記錄每個協程（Task）纍加的被調用運算的總次數;
                                        # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
                                        if Base.haskey(total_worker_called_number, Base.string(result_Dict["processID"]))
                                            # global total_worker_called_number[Base.string(result_Dict["processID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["processID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                            total_worker_called_number[Base.string(result_Dict["processID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["processID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
                                        else
                                            # global total_worker_called_number[Base.string(result_Dict["processID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                            total_worker_called_number[Base.string(result_Dict["processID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
                                        end

                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "error"
                                            if Base.haskey(result_Dict, "taskID") && result_Dict["taskID"] !== Core.nothing && Base.isa(result_Dict["taskID"], Core.String) && result_Dict["taskID"] !== ""
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task < " * Base.string(result_Dict["taskID"]) * " > return error:");
                                                end
                                            else
                                                if Base.haskey(result_Dict, "message") && result_Dict["message"] !== Core.nothing && Base.isa(result_Dict["message"], Core.String) && result_Dict["message"] !== ""
                                                    println("task return error:");
                                                    println(result_Dict["message"]);  # error;
                                                else
                                                    println("task return error.");
                                                end
                                            end

                                            response_statusCode = Core.Int64(500);
                                            response_status_Message = statusMessage(response_statusCode);

                                            # Base.close(sock);  # 中斷當前的這個鏈接;
                                            # Base.sleep(time_sleep);
                                            # continue;
                                            # # break;
                                        end

                                        if Base.haskey(result_Dict, "label") && result_Dict["label"] === "success"
                                            response_statusCode = Core.Int64(200);
                                            response_status_Message = statusMessage(response_statusCode);
                                        end

                                        response_body_String =  response_body_String * Base.string(result_Dict["result_data"]);
                                        # response_body_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                        # println(response_body_String);

                                        # log_text = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * Base.string(response_statusCode) * " .";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * Base.string(response_statusCode) * " .";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * Base.string(request_head["request_IP"]) * Base.string(request_head["Target"]) * Base.string(response_statusCode) * " .";
                                        # end
                                        # print(log_text * "\n");

                                        # response_body_String = Core.nothing;  # 將已經使用完畢後續不再使用的變量置空，便於内存回收機制回收内存;
                                        # Base.GC.gc();  # 内存回收函數 gc();

                                        # nowTime = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        # println(Base.string(nowTime));
                                        # 使用 Distributed.myid() 方法獲取當前進程的 PID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                        # log_text::Core.String = "";
                                        # if Base.isa(result_Dict["request_Arguments"], Base.Dict)
                                        #     if Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path") && Base.haskey(result_Dict["request_Arguments"], "User-Agent") && Base.haskey(result_Dict["request_Arguments"], "From")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " > < " * Base.string(result_Dict["request_Arguments"]["User-Agent"]) * " > < " * Base.string(result_Dict["request_Arguments"]["From"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Nikename") && Base.haskey(result_Dict["request_Arguments"], "request_Password") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Nikename"], ":", result_Dict["request_Arguments"]["request_Password"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP") && Base.haskey(result_Dict["request_Arguments"], "request_Path")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " > < " * Base.string(result_Dict["request_Arguments"]["request_Path"]) * " >.";
                                        #     elseif Base.haskey(result_Dict["request_Arguments"], "request_IP")
                                        #         log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " < " * Base.string(result_Dict["request_Arguments"]["request_IP"]) * " >.";
                                        #     end
                                        # else
                                        #     log_text = Base.string(result_Dict["label"]) * " < " * Base.string(result_Dict["message"]) * " > " * Base.string(result_Dict["time"]) * " process-" * Base.string(result_Dict["processID"]) * " thread-" * Base.string(result_Dict["threadID"]) * " task-" * Base.string(result_Dict["taskID"]) * " .";
                                        # end
                                        # print(log_text * "\n");
                                        # log_file = "";  # 日志文檔;
                                        # # 同步寫入用於記錄過程的日志文檔;
                                        # try
                                        #     # numBytes = write(log_file, log_text, "\n");  # 一次全部寫入字符串數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #     # # write(filename::AbstractString, x)
                                        #     # # Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).
                                        #     # # You can write multiple values with the same write call. i.e. the following are equivalent:
                                        #     # println(numBytes);
                                        #     # println(Base.stat(log_file).size);
                                        #     # println(Base.stat(log_file).mtime);
                                        #     # # println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #     # println(Base.stat(log_file).ctime);
                                        #     # # Base.displaysize([io::IO]) -> (lines, columns)
                                        #     # # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #     # # Base.countlines — Function
                                        #     # # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #     # # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #     # println(Base.countlines(log_file, eol='\\n'));

                                        #     fWIO = Base.open(log_file, "a+");
                                        #     # nb = countlines(fWIO);  # 計算文檔中數據行數;
                                        #     # seekstart(fWIO);  # 指針返回文檔的起始位置;

                                        #     # Keyword	Description				Default
                                        #     # read		open for reading		!write
                                        #     # write		open for writing		truncate | append
                                        #     # create	create if non-existent	!read & write | truncate | append
                                        #     # truncate	truncate to zero size	!read & write
                                        #     # append	seek to end				false

                                        #     # Mode	Description						Keywords
                                        #     # r		read							none
                                        #     # w		write, create, truncate			write = true
                                        #     # a		write, create, append			append = true
                                        #     # r+	read, write						read = true, write = true
                                        #     # w+	read, write, create, truncate	truncate = true, read = true
                                        #     # a+	read, write, create, append		append = true, read = true

                                        #     # 使用 iswritable(io) 函數判斷文檔是否可寫;
                                        #     if Base.iswritable(fWIO)
                                        #         numBytes = Base.write(fWIO, log_text, "\\n");  # Base.write(io::IO, x) 一次全部寫入緩衝中的數據到指定文檔中，字符串類型 "utf-8"，返回值為寫入的字節數;
                                        #         Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #         println(numBytes);
                                        #         println(Base.stat(log_file).size);
                                        #         println(Base.stat(log_file).mtime);
                                        #         println(Dates.now());  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
                                        #         println(Base.stat(log_file).ctime);
                                        #         # Base.displaysize([io::IO]) -> (lines, columns)
                                        #         # Return the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.
                                        #         # Base.countlines — Function
                                        #         # Base.countlines(io::IO; eol::AbstractChar = '\n')
                                        #         # Read io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\n' are supported by passing them as the second argument. The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.
                                        #         println(Base.countlines(log_file, eol='\\n'));
                                        #     end

                                        #     # 在内存中創建一個用於輸入輸出的管道流（IOStream）的緩衝區（Base.IOBuffer）;
                                        #     # io = Base.Base.IOBuffer();  # 在内存中創建一個輸入輸出管道流（IOStream）的緩衝區（Base.IOBuffer）;
                                        #     # Base.write(io, "How are you.", "Fine, thankyou, and you?");  # 向緩衝區寫入數據;
                                        #     # println(Base.string(Base.take!(io)));  # 使用 take!(io) 方法取出緩衝區數據，使用 String() 方法，將從緩衝區取出的數據强制轉換爲字符串類型;
                                        #     # println(Base.position(io));  # position(io) 表示顯示指定緩衝區當前所在的讀寫位置（position）;
                                        #     # Base.mark(io);  # Add a mark at the current position of stream s. Return the marked position;
                                        #     # Base.unmark(io);  # Remove a mark from stream s. Return true if the stream was marked, false otherwise;
                                        #     # Base.reset(io);  # Reset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked;
                                        #     # Base.ismarked(io);  # Return true if stream s is marked;
                                        #     # Base.eof(stream);  # -> Bool，測試 I/O 流是否在文檔末尾，如果流還沒有用盡，這個函數將阻塞以等待更多的數據（如果需要），然後返回 false 值，因此，在看到 eof() 函數返回 false 值後讀取一個字節總是安全的，只要緩衝區的數據仍然可用，即使鏈接的遠端已關閉，eof() 函數也將返回 false 值;
                                        #     # Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.
                                        #     # Base.skip(io, 3);  # skip(io, 3) 表示將指定緩衝區的讀寫位置（position），從當前所在的讀寫位置（position）跳轉到後延 3 個字符之後的讀寫位置（position）;
                                        #     # Base.seekstart(io);  # 移動讀寫位置（position）到緩衝區首部;
                                        #     # Base.seekend(io);  # 移動讀寫位置（position）到緩衝區尾部;
                                        #     # Base.seek(io, 0);  # 移動讀寫位置（position）到緩衝區首部，因爲剛才的寫入 write() 操作之後，讀寫位置（position）已經被移動到了文檔尾部了，如果不移動到首部，則讀出爲空;
                                        #     # a = Base.read(io, Core.String);  # 從緩衝區讀出數據;
                                        #     # Base.close(io);  # 關閉緩衝區;
                                        #     # println(a)
                                        #     # Base.redirect_stdout — Function
                                        #     # redirect_stdout([stream]) -> (rd, wr)
                                        #     # Create a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.
                                        #     # If called with the optional stream argument, then returns stream itself.
                                        #     # Base.redirect_stdout — Method
                                        #     # redirect_stdout(f::Function, stream)
                                        #     # Run the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.
                                        #     # Base.redirect_stderr — Function
                                        #     # redirect_stderr([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stderr.
                                        #     # Base.redirect_stderr — Method
                                        #     # redirect_stderr(f::Function, stream)
                                        #     # Run the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.
                                        #     # Base.redirect_stdin — Function
                                        #     # redirect_stdin([stream]) -> (rd, wr)
                                        #     # Like redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.
                                        #     # Base.redirect_stdin — Method
                                        #     # redirect_stdin(f::Function, stream)
                                        #     # Run the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.

                                        # catch err
                                        #     println("往日志文檔: " * log_file * " 中寫入記錄發生錯誤.");
                                        #     println(err);
                                        #     # println(Base.typeof(err));

                                        #     # Julia提供了許多類型的錯誤：
                                        #     # ArgumentError：傳遞給函數的參數與函數最初期望的參數不相似。
                                        #     # AssertionError：這是在寫入錯誤的斷言語句並且計算結果為false時的結果。
                                        #     # BoundsError：在索引陣列時嘗試訪問越界元素。
                                        #     # DivideError：這是數字除以0時的結果。
                                        #     # DomainError：有效域之外的參數。
                                        #     # EOFError：這意味著您已到達檔的末尾，因此無需再從中讀取任何內容。
                                        #     # InexactError：嘗試進行精確類型轉換失敗。
                                        #     # KeyError：嘗試訪問不是關鍵元素的元素 - 也就是說，不存在。
                                        #     # LoadError：載入檔時發生錯誤。
                                        #     # MethodError：嘗試使用不受支援的函數的簽名時出錯。換句話說，使用者嘗試使用未在方法清單（函數）中列出的方法。
                                        #     # OutOfMemoryError：計算需要的記憶體多於分配的記憶體。
                                        #     # ReadOnlyMemoryError：嘗試寫入唯讀記憶體。
                                        #     # OverflowError：當操作結果太大時會發生這種情況。
                                        #     # ParseError：解析給定運算式時出現問題。
                                        #     # StackOverflowError：當函式呼叫超出調用範圍時會發生這種情況 疊加。
                                        #     # SystemError：由於系統調用失敗而導致的錯誤。 TypeError：類型檢查的斷言失敗。當將錯誤類型的參數傳遞給函數時，這種情況最常發生。
                                        #     # UndefRefError：未知引用。
                                        #     # UndefVarError：對不存在的變數進行未知引用。
                                        #     # InitError：調用模組的init方法時出現此錯誤。
                                        #     # ErrorException：發生錯誤InterruptException：計算中發生外部中斷
                                        #     # NullException：嘗試訪問Null值
                                        #     # ProcessExitedException：進程結束，因此進一步嘗試訪問此進程將導致錯誤

                                        #     return ["error", log_file, "document [ log file = " * Base.string(log_file) * " ] not write."];

                                        # finally
                                        #     Base.flush(fWIO);  # 將當前寫入操作的緩衝區所有數據都提交給傳出傳入流;
                                        #     # 使用 Base.eof() 函數判斷是否已經寫到最後一個位置;
                                        #     if Base.eof(fWIO)
                                        #         Base.close(fWIO);  # Close an I/O stream. Performs a flush first;
                                        #     end
                                        # end
                                    end

                                    # 使用 Base.isready(c::Channel) 函數判斷通道中元素是否已經取空，如果已經取空 Base.isready(c::Channel) 返回為 false 值，則跳出 for 循環，如果一個空通道從未寫入過元素，則 Base.isready(sub_to_main_channel) 值爲 true，因此會一直阻塞等待不會跳出循環;
                                    if !Base.isready(sub_to_main_channel)
                                        break;
                                    end
                                end
                                # response_body_String = "{\"Server_say\":\"" * "request Header Authorization [ " * request_Nikename * " ] not authenticated." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                                # println(response_body_String);

                            catch err

                                while Base.isreadable(sub_to_main_channel)
                                    Base.take!(sub_to_main_channel);
                                end
                                # for result_Dict in sub_to_main_channel
                                # end
                                # for i = 1:Base.length(sub_to_main_channel)
                                #     Base.take!(sub_to_main_channel);
                                # end

                                # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                                if Core.isa(err, Core.InterruptException)

                                    print("\n");
                                    # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                                    # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                                    println("[ Ctrl ] + [ c ] received, will be stop the TCP Server.");

                                    # # 打印進程被調用數目;
                                    # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                                    #     if isConcurrencyHierarchy === "Multi-Processes"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                                    #         # Base.haskey(collection, key) -> Bool
                                    #         # workNum = "worker";
                                    #         for k in Base.keys(total_worker_called_number)
                                    #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                                    #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                                    #         end
                                    #         # println(workNum);

                                    #     end

                                    #     total_worker_called_number = Core.nothing;
                                    # end

                                    # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                                    # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                                    #     # Base.haskey(collection, key) -> Bool
                                    #     # for k in Base.keys(worker_queues_Dict)
                                    #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                                    #     # end

                                    #     worker_queues_Dict = Core.nothing;
                                    # end

                                    println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                                    println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                                    # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
                                    # Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;
                                    # Base.exit(0);  # 立即中止進程;
                                    return ["", server, total_worker_called_number];

                                else

                                    # Base.write(stderr, err);
                                    # Base.write(Base.stdout, err, "\n");
                                    println("多協程並發 ( multi-task ) 時，工作協程 ( worker task ) 中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
                                    println(err);
                                    # println(err.msg);
                                    # println(Base.typeof(err));

                                    response_statusCode = Core.Int64(500);
                                    response_status_Message = statusMessage(response_statusCode);
                                    # response_body_String = "{\"Server_say\":\"" * "Server calculate data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;

                                    # Base.close(sock);  # 中斷當前的這個鏈接;
                                    # Base.sleep(time_sleep);
                                    # continue;
                                    # # break;
                                end
                            end
                        end
                    end
                else
                    response_statusCode = Core.Int64(500);
                    response_status_Message = statusMessage(response_statusCode);

                    response_body_String = request_body_String;
                    # response_body_String = "{\"Server_say\":\"" * "Server calculate data error." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                    # println(response_body_String);
                end
            end

            response_body_String_len = Base.sizeof(response_body_String);

            # response_String = Base.string(
            #     "HTTP/1.1" * " " * Base.string(response_statusCode) * " " * Base.string(response_status_Message) * "\r\n",  # "HTTP/1.1 401 Unauthorized\r\n"，401 表示用戶沒有訪問權限 Unauthorized;
            #     "Content-Type:" * "text/html, text/plain; charset=utf-8" * "\r\n",  # 響應數據類型;
            #     "Content-Length:" * Base.string(response_body_String_len) * "\r\n",  # 設置響應體數據長度 response_body_String_len = Buffer.byteLength(post_Data_String, "utf8");
            #     "Set-Cookie:" * response_Cookie_string * "\r\n",  # 設置 Set-Cookie = "Session_ID=request_Key->username:password; expires=2021-06-28T12:12:50.544; path=/" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk; expires=2021-06-28T12:12:50.544; path=/";
            #     "Www-Authenticate:" * "Basic realm=\"domain name -> " * Base.string(key) * "\"" * "\r\n",  # 告訴客戶端應該在請求頭Authorization中提供什麽類型的身份驗證信息 Www-Authenticate = "Basic realm=\"domain name -> username:password\"" -> "Basic realm=\"domain name -> dXNlcm5hbWU6cGFzc3dvcmQ=\"";
            #     "Content-Language:" * "zh-Hant-TW; q=0.8, zh-Hant; q=0.7, zh-Hans-CN; q=0.7, zh-Hans; q=0.5, en-US, en; q=0.3" * "\r\n",  # 服務器發送響應的自然語言類型;
            #     # "Content-Disposition:" * "attachment; filename=Test.zip" * "\r\n",  # 服務端要求客戶端以下載文檔的方式打開該文檔;
            #     # "Transfer-Encoding:" * "chunked" * "\r\n",  # 以數據流形式分塊發送響應數據到客戶端;
            #     # "Expires:" * "100-continue header" * "\r\n",  # 服務端禁止客戶端緩存頁面數據;
            #     # "Cache-Control:" * "no-cache" * "\r\n",  # 'max-age=0' 或 no-store, must-revalidate 設置不允許瀏覽器緩存，必須刷新數據;
            #     # "Pragma:" * "no-cache" * "\r\n",  # 服務端禁止客戶端緩存頁面數據;
            #     "Date:" * Base.string(now_date) * "\r\n",  # 服務端向客戶端返回響應的時間 2021-06-28T12:12:50.544;
            #     # "Access-Control-Allow-Methods:" * "GET, POST, HEAD, PATCH" * "\r\n",  # 設置響應頭，但是并不發送響應頭;
            #     # "Access-Control-Allow-Origin:" * "*" * "\r\n",  # 設置響應頭，但是并不發送響應頭;
            #     # "Access-Control-Allow-Headers:" * "content-type, Accept" * "\r\n",  # 設置響應頭，但是并不發送響應頭;
            #     # "Access-Control-Allow-Credentials:" * "true" * "\r\n",  # 設置響應頭，但是并不發送響應頭;
            #     "Connection:" * "close" * "\r\n",  # 'keep-alive' 維持客戶端和服務端的鏈接關係，當一個網頁打開完成後，客戶端和服務器之間用於傳輸 HTTP 數據的 TCP 鏈接不會關閉，如果客戶端再次訪問這個服務器上的網頁，會繼續使用這一條已經建立的鏈接;
            #     "Server:" * Base.string(server_info) * "\r\n\r\n",  # web 服務器名稱版本信息 "Julia-1.9.3 HTTP.listen!()";
            #     response_body_String
            # );

            # 如果客戶端鏈接正常，則由服務器端向客戶端發送響應數據;
            try
                # if !Base.eof(ioHttpRequest) && Base.iswritable(ioHttpRequest)
                # end

                # 向客戶端發送響應狀態碼;
                HTTP.setstatus(ioHttpRequest, response_statusCode);  # "HTTP/1.1 401\r\n"，401 表示用戶沒有訪問權限 Unauthorized;
                # HTTP.setstatus(ioHttpRequest, response_statusCode, Base.string(response_status_Message));  # "HTTP/1.1 401 Unauthorized\r\n"，401 表示用戶沒有訪問權限 Unauthorized;

                # 向客戶端發送響應頭;
                HTTP.setheader(ioHttpRequest, "Content-Type" => response_Content_Type);  # "text/html, text/plain, text/event-stream; charset=utf-8" 響應數據類型; # "application/octet-stream, text/plain, text/html, text/javascript, text/css, image/jpeg, image/svg+xml, image/png; charset=utf-8";
                HTTP.setheader(ioHttpRequest, "Content-Length" => Base.string(response_body_String_len));  # 設置響應體數據長度 response_body_String_len = Buffer.byteLength(post_Data_String, "utf8");
                HTTP.setheader(ioHttpRequest, "Set-Cookie" => response_Cookie_string);  # 設置 Set-Cookie = "Session_ID=request_Key->username:password; expires=2021-06-28T12:12:50.544; path=/" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk; expires=2021-06-28T12:12:50.544; path=/";
                HTTP.setheader(ioHttpRequest, "Www-Authenticate" => "Basic realm=\"domain name -> " * Base.string(key) * "\"");  # 告訴客戶端應該在請求頭 Authorization 中提供什麽類型的身份驗證信息 Www-Authenticate = "Basic realm=\"domain name -> username:password\"" -> "Basic realm=\"domain name -> dXNlcm5hbWU6cGFzc3dvcmQ=\"";
                HTTP.setheader(ioHttpRequest, "Content-Language" => "zh-Hant-TW; q=0.8, zh-Hant; q=0.7, zh-Hans-CN; q=0.7, zh-Hans; q=0.5, en-US, en; q=0.3");  # 服務器發送響應的自然語言類型;
                # HTTP.setheader(ioHttpRequest, "Content-Disposition" => "attachment; filename=Test.zip");  # 服務端要求客戶端以下載文檔的方式打開該文檔;
                # HTTP.setheader(ioHttpRequest, "Transfer-Encoding" => "chunked");  # 以數據流形式分塊發送響應數據到客戶端;
                # HTTP.setheader(ioHttpRequest, "Expires" => "100-continue header");  # 服務端禁止客戶端緩存頁面數據;
                # HTTP.setheader(ioHttpRequest, "Cache-Control" => "no-cache");  # 'max-age=0' 或 no-store, must-revalidate 設置不允許瀏覽器緩存，必須刷新數據;
                # HTTP.setheader(ioHttpRequest, "Pragma" => "no-cache");  # 服務端禁止客戶端緩存頁面數據;
                HTTP.setheader(ioHttpRequest, "Date" => Base.string(now_date));  # 服務端向客戶端返回響應的時間 2021-06-28T12:12:50.544;
                # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Methods" => "GET, POST, HEAD, PATCH, OPTIONS");  # 設置響應頭，但是并不發送響應頭;
                # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Origin" => "*");  # 設置響應頭，但是并不發送響應頭;
                # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Headers" => "content-type, Accept");  # 設置響應頭，但是并不發送響應頭;
                # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Credentials" => "true");  # 設置響應頭，但是并不發送響應頭;
                HTTP.setheader(ioHttpRequest, "Connection" => "close");  # 'keep-alive' 維持客戶端和服務端的鏈接關係，當一個網頁打開完成後，客戶端和服務器之間用於傳輸 HTTP 數據的 TCP 鏈接不會關閉，如果客戶端再次訪問這個服務器上的網頁，會繼續使用這一條已經建立的鏈接;
                HTTP.setheader(ioHttpRequest, "Server" => Base.string(server_info));  # web 服務器名稱版本信息 "Julia-1.9.3 HTTP.listen!()";
                # HTTP.appendheader(ioHttpRequest, "Content-Type" => "text/event-stream");

                # 向客戶端發送響應值;
                HTTP.startwrite(ioHttpRequest);
                # Base.write(ioHttpRequest, Base.string(Core.String(Base.readavailable(ioHttpRequest))));
                # Base.write(ioHttpRequest, "<body><p>$(JSONstring(Base.Dict{Core.String, Core.String}("user"=>"RAO...tjN", "token"=>"NzU...Wnp", "message"=>"Hello!")))</p><br></body>");
                # # Base.write(ioHttpRequest, "<body><p>$(JSON.json(Base.Dict{Core.String, Core.String}("user"=>"RAO...tjN", "token"=>"NzU...Wnp", "message"=>"Hello!")))</p><br></body>");
                # Base.write(ioHttpRequest, "<body><p>$(JSONstring(response_body_Dict))</p><br></body>");
                # # Base.write(ioHttpRequest, "<body><p>$(JSON.json(response_body_Dict))</p><br></body>");
                # Base.write(ioHttpRequest, JSONstring(response_body_Dict));
                # # Base.write(ioHttpRequest, JSON.json(response_body_Dict));
                Base.write(ioHttpRequest, response_body_String);
                HTTP.Streams.closebody(ioHttpRequest);
                # Base.write(Base.stdout, response_String);
            catch err
                # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
                if Core.isa(err, Core.InterruptException)

                    print("\n");
                    # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
                    # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
                    println("[ Ctrl ] + [ c ] received, will be stop the TCP server.");

                    # # 打印進程被調用數目;
                    # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                    #     if isConcurrencyHierarchy === "Multi-Processes"

                    #         # Base.haskey(collection, key) -> Bool
                    #         # workNum = "worker";
                    #         for k in Base.keys(total_worker_called_number)
                    #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                    #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                    #         end
                    #         # println(workNum);

                    #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                    #         # Base.haskey(collection, key) -> Bool
                    #         # workNum = "worker";
                    #         for k in Base.keys(total_worker_called_number)
                    #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                    #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                    #         end
                    #         # println(workNum);

                    #     end

                    #     total_worker_called_number = Core.nothing;
                    # end

                    # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
                    # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

                    #     # Base.haskey(collection, key) -> Bool
                    #     # for k in Base.keys(worker_queues_Dict)
                    #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
                    #     # end

                    #     worker_queues_Dict = Core.nothing;
                    # end

                    println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
                    println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

                    response_body_String = "{\"Server_say\":\"" * "$(err)." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                    # response_body_String = "{\"Server_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                    response_body_String_len = Base.sizeof(response_body_String);

                    response_statusCode = Core.Int64(500);
                    response_status_Message = statusMessage(response_statusCode);
                    # 向客戶端發送響應狀態碼;
                    HTTP.setstatus(ioHttpRequest, response_statusCode);  # "HTTP/1.1 401\r\n"，401 表示用戶沒有訪問權限 Unauthorized;
                    # HTTP.setstatus(ioHttpRequest, response_statusCode, Base.string(response_status_Message));  # "HTTP/1.1 401 Unauthorized\r\n"，401 表示用戶沒有訪問權限 Unauthorized;

                    # 向客戶端發送響應頭;
                    HTTP.setheader(ioHttpRequest, "Content-Type" => "text/html, text/plain, text/event-stream; charset=utf-8");  # 響應數據類型;
                    HTTP.setheader(ioHttpRequest, "Content-Length" => Base.string(response_body_String_len));  # 設置響應體數據長度 response_body_String_len = Buffer.byteLength(post_Data_String, "utf8");
                    HTTP.setheader(ioHttpRequest, "Set-Cookie" => response_Cookie_string);  # 設置 Set-Cookie = "Session_ID=request_Key->username:password; expires=2021-06-28T12:12:50.544; path=/" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk; expires=2021-06-28T12:12:50.544; path=/";
                    HTTP.setheader(ioHttpRequest, "Www-Authenticate" => "Basic realm=\"domain name -> " * Base.string(key) * "\"");  # 告訴客戶端應該在請求頭Authorization中提供什麽類型的身份驗證信息 Www-Authenticate = "Basic realm=\"domain name -> username:password\"" -> "Basic realm=\"domain name -> dXNlcm5hbWU6cGFzc3dvcmQ=\"";
                    HTTP.setheader(ioHttpRequest, "Content-Language" => "zh-Hant-TW; q=0.8, zh-Hant; q=0.7, zh-Hans-CN; q=0.7, zh-Hans; q=0.5, en-US, en; q=0.3");  # 服務器發送響應的自然語言類型;
                    # HTTP.setheader(ioHttpRequest, "Content-Disposition" => "attachment; filename=Test.zip");  # 服務端要求客戶端以下載文檔的方式打開該文檔;
                    # HTTP.setheader(ioHttpRequest, "Transfer-Encoding" => "chunked");  # 以數據流形式分塊發送響應數據到客戶端;
                    # HTTP.setheader(ioHttpRequest, "Expires" => "100-continue header");  # 服務端禁止客戶端緩存頁面數據;
                    # HTTP.setheader(ioHttpRequest, "Cache-Control" => "no-cache");  # 'max-age=0' 或 no-store, must-revalidate 設置不允許瀏覽器緩存，必須刷新數據;
                    # HTTP.setheader(ioHttpRequest, "Pragma" => "no-cache");  # 服務端禁止客戶端緩存頁面數據;
                    HTTP.setheader(ioHttpRequest, "Date" => Base.string(now_date));  # 服務端向客戶端返回響應的時間 2021-06-28T12:12:50.544;
                    # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Methods" => "GET, POST, HEAD, PATCH, OPTIONS");  # 設置響應頭，但是并不發送響應頭;
                    # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Origin" => "*");  # 設置響應頭，但是并不發送響應頭;
                    # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Headers" => "content-type, Accept");  # 設置響應頭，但是并不發送響應頭;
                    # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Credentials" => "true");  # 設置響應頭，但是并不發送響應頭;
                    HTTP.setheader(ioHttpRequest, "Connection" => "close");  # 'keep-alive' 維持客戶端和服務端的鏈接關係，當一個網頁打開完成後，客戶端和服務器之間用於傳輸 HTTP 數據的 TCP 鏈接不會關閉，如果客戶端再次訪問這個服務器上的網頁，會繼續使用這一條已經建立的鏈接;
                    HTTP.setheader(ioHttpRequest, "Server" => Base.string(server_info));  # web 服務器名稱版本信息 "Julia-1.9.3 HTTP.listen!";
                    # HTTP.appendheader(ioHttpRequest, "Content-Type" => "text/event-stream");

                    # 向客戶端發送響應值;
                    HTTP.startwrite(ioHttpRequest);
                    # Base.write(ioHttpRequest, Base.string(Core.String(Base.readavailable(ioHttpRequest))));
                    # Base.write(ioHttpRequest, "<body><p>$(JSONstring(Base.Dict{Core.String, Core.String}("user"=>"RAO...tjN", "token"=>"NzU...Wnp", "message"=>"Hello!")))</p><br></body>");
                    # # Base.write(ioHttpRequest, "<body><p>$(JSON.json(Base.Dict{Core.String, Core.String}("user"=>"RAO...tjN", "token"=>"NzU...Wnp", "message"=>"Hello!")))</p><br></body>");
                    # Base.write(ioHttpRequest, "<body><p>$(JSONstring(response_body_Dict))</p><br></body>");
                    # # Base.write(ioHttpRequest, "<body><p>$(JSON.json(response_body_Dict))</p><br></body>");
                    # Base.write(ioHttpRequest, JSONstring(response_body_Dict));
                    # # Base.write(ioHttpRequest, JSON.json(response_body_Dict));
                    Base.write(ioHttpRequest, response_body_String);
                    HTTP.Streams.closebody(ioHttpRequest);
                    # Base.write(Base.stdout, response_String);

                    # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
                    Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;
                    # Base.exit(0);  # 立即中止進程;
                    return ["", server, total_worker_called_number];

                else

                    # Base.write(stderr, err);
                    # Base.write(Base.stdout, err, "\n");
                    println(err);

                    response_body_String = "{\"Server_say\":\"" * "$(err)." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                    # response_body_String = "{\"Server_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"Server_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
                    response_body_String_len = Base.sizeof(response_body_String);

                    response_statusCode = Core.Int64(500);
                    response_status_Message = statusMessage(response_statusCode);
                    # 向客戶端發送響應狀態碼;
                    HTTP.setstatus(ioHttpRequest, response_statusCode);  # "HTTP/1.1 401\r\n"，401 表示用戶沒有訪問權限 Unauthorized;
                    # HTTP.setstatus(ioHttpRequest, response_statusCode, Base.string(response_status_Message));  # "HTTP/1.1 401 Unauthorized\r\n"，401 表示用戶沒有訪問權限 Unauthorized;

                    # 向客戶端發送響應頭;
                    HTTP.setheader(ioHttpRequest, "Content-Type" => "text/html, text/plain, text/event-stream; charset=utf-8");  # 響應數據類型;
                    HTTP.setheader(ioHttpRequest, "Content-Length" => Base.string(response_body_String_len));  # 設置響應體數據長度 response_body_String_len = Buffer.byteLength(post_Data_String, "utf8");
                    HTTP.setheader(ioHttpRequest, "Set-Cookie" => response_Cookie_string);  # 設置 Set-Cookie = "Session_ID=request_Key->username:password; expires=2021-06-28T12:12:50.544; path=/" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk; expires=2021-06-28T12:12:50.544; path=/";
                    HTTP.setheader(ioHttpRequest, "Www-Authenticate" => "Basic realm=\"domain name -> " * Base.string(key) * "\"");  # 告訴客戶端應該在請求頭Authorization中提供什麽類型的身份驗證信息 Www-Authenticate = "Basic realm=\"domain name -> username:password\"" -> "Basic realm=\"domain name -> dXNlcm5hbWU6cGFzc3dvcmQ=\"";
                    HTTP.setheader(ioHttpRequest, "Content-Language" => "zh-Hant-TW; q=0.8, zh-Hant; q=0.7, zh-Hans-CN; q=0.7, zh-Hans; q=0.5, en-US, en; q=0.3");  # 服務器發送響應的自然語言類型;
                    # HTTP.setheader(ioHttpRequest, "Content-Disposition" => "attachment; filename=Test.zip");  # 服務端要求客戶端以下載文檔的方式打開該文檔;
                    # HTTP.setheader(ioHttpRequest, "Transfer-Encoding" => "chunked");  # 以數據流形式分塊發送響應數據到客戶端;
                    # HTTP.setheader(ioHttpRequest, "Expires" => "100-continue header");  # 服務端禁止客戶端緩存頁面數據;
                    # HTTP.setheader(ioHttpRequest, "Cache-Control" => "no-cache");  # 'max-age=0' 或 no-store, must-revalidate 設置不允許瀏覽器緩存，必須刷新數據;
                    # HTTP.setheader(ioHttpRequest, "Pragma" => "no-cache");  # 服務端禁止客戶端緩存頁面數據;
                    HTTP.setheader(ioHttpRequest, "Date" => Base.string(now_date));  # 服務端向客戶端返回響應的時間 2021-06-28T12:12:50.544;
                    # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Methods" => "GET, POST, HEAD, PATCH, OPTIONS");  # 設置響應頭，但是并不發送響應頭;
                    # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Origin" => "*");  # 設置響應頭，但是并不發送響應頭;
                    # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Headers" => "content-type, Accept");  # 設置響應頭，但是并不發送響應頭;
                    # HTTP.setheader(ioHttpRequest, "Access-Control-Allow-Credentials" => "true");  # 設置響應頭，但是并不發送響應頭;
                    HTTP.setheader(ioHttpRequest, "Connection" => "close");  # 'keep-alive' 維持客戶端和服務端的鏈接關係，當一個網頁打開完成後，客戶端和服務器之間用於傳輸 HTTP 數據的 TCP 鏈接不會關閉，如果客戶端再次訪問這個服務器上的網頁，會繼續使用這一條已經建立的鏈接;
                    HTTP.setheader(ioHttpRequest, "Server" => Base.string(server_info));  # web 服務器名稱版本信息 "Julia-1.9.3 HTTP.listen!";
                    # HTTP.appendheader(ioHttpRequest, "Content-Type" => "text/event-stream");

                    # 向客戶端發送響應值;
                    HTTP.startwrite(ioHttpRequest);
                    # Base.write(ioHttpRequest, Base.string(Core.String(Base.readavailable(ioHttpRequest))));
                    # Base.write(ioHttpRequest, "<body><p>$(JSONstring(Base.Dict{Core.String, Core.String}("user"=>"RAO...tjN", "token"=>"NzU...Wnp", "message"=>"Hello!")))</p><br></body>");
                    # # Base.write(ioHttpRequest, "<body><p>$(JSON.json(Base.Dict{Core.String, Core.String}("user"=>"RAO...tjN", "token"=>"NzU...Wnp", "message"=>"Hello!")))</p><br></body>");
                    # Base.write(ioHttpRequest, "<body><p>$(JSONstring(response_body_Dict))</p><br></body>");
                    # # Base.write(ioHttpRequest, "<body><p>$(JSON.json(response_body_Dict))</p><br></body>");
                    # Base.write(ioHttpRequest, JSONstring(response_body_Dict));
                    # # Base.write(ioHttpRequest, JSON.json(response_body_Dict));
                    Base.write(ioHttpRequest, response_body_String);
                    HTTP.Streams.closebody(ioHttpRequest);
                    # Base.write(Base.stdout, response_String);

                    # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
                    # Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;
                    # Base.sleep(time_sleep);
                    # Base.exit(0);  # 立即中止進程;
                end
            end

            # log_text::Core.String = Base.string(now_date) * " " * Base.string(request_head["request_IP"]) * " " * Base.string(request_head["Target"]) * " " * Base.string(response_statusCode) * " .";
            log_text::Core.String = "";
            log_text = log_text * Base.string(now_date);
            if Base.haskey(request_head, "request_IP")
                log_text = log_text * " " * Base.string(request_head["request_IP"]);
            end
            if Base.haskey(request_head, "Target")
                log_text = log_text * " " * Base.string(request_head["Target"]);
            end
            log_text = log_text * " " * Base.string(response_statusCode) * " .";
            print(log_text * "\n");

            # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
            # Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;
            # Base.sleep(time_sleep);
            # Base.exit(0);  # 立即中止進程;

        end
        Base.wait(server);  # 阻塞進程保持監聽服務器持續運行，will immediately force close the server and all active connections;
        # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
        # Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;

    end

    return ["", server, total_worker_called_number];

end


function http_Server_Run(;
    host::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv6(0),  # "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
    port::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String} = Core.UInt8(5000),  # 0 ~ 65535，監聽埠號（端口）;
    do_Function = (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Request";
    key::Core.String = ":",  # "username:password",  # 自定義的訪問網站簡單驗證用戶名和密碼;
    session::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => http_Server_Run.key),  # 保存網站的 Session 數據;
    number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Base.Sys.CPU_THREADS,  # Core.UInt8(1)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
    time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
    readtimeout::Core.Int = Core.Int(0),  # 客戶端請求數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
    verbose::Core.Bool = Core.Bool(false),  # 將連接資訊記錄到輸出到顯示器 Base.stdout 標準輸出流，log connection information to stdout;
    isConcurrencyHierarchy::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
    # worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
    # total_worker_called_number::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
    http_Server = http_Server
) ::Core.Array{Core.Any, 1}

    # # print("當前協程 task: ", Base.current_task(), "\n");
    # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
    # print("當前綫程 thread 的 ID: ", Base.Threads.threadid(), "\n");
    # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
    # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
    # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
    # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
    # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
    # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
    # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
    # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
    # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
    # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
    # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
    # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
    # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

    # println(Base.Sys.CPU_THREADS)  # 4 可用 CPU 數;
    # println(Base.Filesystem.ispath(Base.Filesystem.pwd()))  # true 判斷目錄是否存在;
    # println(Base.Sys.BINDIR)  # C:\Program Files\Julia 1.5.1\bin;
    # println(Base.PROGRAM_FILE)  # c:\Users\china\Documents\Node.js\Criss\jl\tempCodeRunnerFile.jl;
    # println(Base.Filesystem.basename(Base.Filesystem.pwd()))  # Criss;
    # # "File_Directory_and_Path";
    # println(Base.Filesystem.homedir())  # C:\Users\china;
    # println(Base.Filesystem.pwd())  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath("."))  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js\Criss;
    # # 获取路径的目录;
    # println(Base.Filesystem.dirname(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js;
    # # "/Users/juliauser/Functions_Scripts_Codes_Pipelines/Julia_Codes";
    # # 路径的末端分割;
    # println(Base.Filesystem.splitdir(Base.Filesystem.pwd()));
    # # ("c:\\Users\\china\\Documents\\Node.js", "Criss");
    # # 路径的合成;
    # println(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "temp", "intermediary_write_NodeJS.txt"));  # c:\Users\china\Documents\Node.js\temp\intermediary_write_NodeJS.txt;
    # # Base.Filesystem.cd()  # 更換工作目錄;
    # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl"))
    # # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl").mode) # 返回值為 Core.UInt64 類型數值，例如 Core.UInt64(33206);

    # 自定義一個在進程退出前一刻調用的函數 f()，使用 Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并注冊為在對象終結的前一刻運行;
    function func_Exit()

        # if isMonitorThreadsOrProcesses === "Multi-Processes" || isMonitorThreadsOrProcesses === "Multi-Threading"

        #     RemoteChannel_Data_Dict = Base.Dict{Core.String, Core.Any}(
        #         # "read_file_do_Function" => read_file_do_Function,  # input_queues_array[1]["read_file_do_Function"];
        #         "monitor_file" => monitor_file,
        #         "monitor_dir" => monitor_dir,
        #         # "do_Function" => do_Function,  # input_queues_array[1]["do_Function"]，do_data ;
        #         "output_dir" => output_dir,
        #         "output_file" => output_file,
        #         "temp_cache_IO_data_dir" => temp_cache_IO_data_dir,
        #         "to_executable" => to_executable,
        #         "to_script" => to_script,
        #         "input_queues_array" => input_queues_array,
        #         "output_queues_array" => output_queues_array,
        #         "processID" => Base.string(Distributed.myid()),  # 子進程 ID;
        #         "threadID" => Base.string(Base.Threads.threadid()),  # 子綫程（執行緒） ID;
        #         "taskID" => Base.string(Base.objectid(Base.current_task())),  # 子協程（任務） ID;
        #         "time" => Base.string(Dates.now()),  # 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
        #         "label" => "exit",
        #         "message" => "exit worker process."
        #     );

        #     if Base.isopen(rc2to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_file() > worker process-2 be exit.";
        #         Base.put!(rc2to, RemoteChannel_Data_Dict);
        #         Base.close(rc2to);
        #     end

        #     if Base.isopen(rc3to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_input_queues() > worker process-3 be exit.";
        #         Base.put!(rc3to, RemoteChannel_Data_Dict);
        #         Base.close(rc3to);
        #     end

        #     if Base.isopen(rc4to)
        #         RemoteChannel_Data_Dict["message"] = "Function < func_Monitor_output_queues() > worker process-4 be exit.";
        #         Base.put!(rc4to, RemoteChannel_Data_Dict);
        #         Base.close(rc4to);
        #     end

        #     RemoteChannel_Data_Dict = Core.nothing;

        #     if Base.isready(rc2from)
        #         # from2rcDict = Base.take!(rc2from);
        #         for from2rcDict in rc2from
        #             # input_queues_array = from2rcDict["input_queues_array"];
        #             # output_queues_array = from2rcDict["output_queues_array"];
        #             if from2rcDict["label"] === "exit"
        #                 println(from2rcDict["message"]);
        #             end
        #         end
        #         # from2rcDict = Core.nothing;
        #     end

        #     if Base.isready(rc3from)
        #         # from3rcDict = Base.take!(rc3from);
        #         for from3rcDict in rc3from
        #             # input_queues_array = from3rcDict["input_queues_array"];
        #             # output_queues_array = from3rcDict["output_queues_array"];
        #             if from3rcDict["label"] === "exit"
        #                 println(from3rcDict["message"]);
        #             end
        #         end
        #         # from3rcDict = Core.nothing;
        #     end

        #     if Base.isready(rc4from)
        #         # from4rcDict = Base.take!(rc4from);
        #         for from4rcDict in rc4from
        #             # input_queues_array = from4rcDict["input_queues_array"];
        #             # output_queues_array = from4rcDict["output_queues_array"];
        #             if from4rcDict["label"] === "exit"
        #                 println(from4rcDict["message"]);
        #             end
        #         end
        #         # from4rcDict = Core.nothing;
        #     end
        # end
    end
    Base.atexit(func_Exit);  # 注冊要在進程退出前一刻調用的零參數函數 f()，Base.atexit() 鈎子以後進先出（LIFO）的順序調用，并在對象終結的前一刻運行;

    # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # Base.Dict{Core.String, Core.Task}()，保存每個創建的子進程的字典;
    # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
    total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
    resultArray = Core.Array{Core.Any, 1}();  # ::Core.Array{Core.Any, 1} = ["", "", ""];

    # 監聽 'SIGINT' 信號，當 Julia 進程接收到 'SIGINT' 信號時，會觸發該事件;
    # 'SIGHUP' 信號在 Windows 平臺上當控制臺使用鍵盤輸入 [ Ctrl ] + [ c ] 窗口被關閉時會被觸發，在其它平臺上在相似的條件下也會被觸發;
    # 修改 Julia 解釋器 jl_exit_on_sigint 模組的變量 Cint 的值為 0（預設值為 1），使在執行代碼脚本文檔的時候，接收到鍵盤 Ctrl + c 信號，抛出 Core.UndefVarError 錯誤;
    # 預設的只有在控制臺交互的時候，解釋器 jl_exit_on_sigint 模組的變量 Cint 的值預設值為 0，在接收到鍵盤 Ctrl + c 信號時，會抛出 Core.UndefVarError 錯誤；
    # 但是在執行代碼脚本文檔的時候，解釋器 jl_exit_on_sigint 模組的變量 Cint 的值預設值為 1，，在接收到鍵盤 Ctrl + c 信號時，并不會抛出 Core.UndefVarError 錯誤；
    ccall(:jl_exit_on_sigint, Cvoid, (Cint,), 0);  # 修改 Julia 解釋器 jl_exit_on_sigint 模組的變量 Cint 的值為 0（預設值為 1），使在執行代碼脚本文檔的時候，接收到鍵盤 Ctrl + c 信號，抛出 Core.UndefVarError 錯誤;
    try
        println("進程: process-" * Base.string(Distributed.myid()) * " , 執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在監聽主機「 " * Base.string(host) * " 」埠號「 " * Base.string(port) * " 」 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        if Core.isa(host, Sockets.IPv6)
            println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on Host -> http://[" * Base.string(host) * "]:" * Base.string(port) * "/ ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # elseif Base.string(host) === "::0" || Base.string(host) === "::1" || Base.string(host) === "::" || Base.string(host) === "0" || Base.string(host) === "1" || CheckIP(Base.string(host)) === "IPv6"
        #     println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on Host -> http://[" * Base.string(host) * "]:" * Base.string(port) * "/ ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        elseif Core.isa(host, Sockets.IPv4)
            println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on Host -> http://" * Base.string(host) * ":" * Base.string(port) * "/ ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # elseif Base.string(host) === "0.0.0.0" || Base.string(host) === "127.0.0.1" || CheckIP(Base.string(host)) === "IPv4"
        #     println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on Host -> http://" * Base.string(host) * ":" * Base.string(port) * "/ ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        # elseif Base.string(host) === "localhost"
        #     println("process-" * Base.string(Distributed.myid()) * " thread-" * Base.string(Base.Threads.threadid()) * " task-" * Base.string(Base.objectid(Base.current_task())) * " listening on Host -> http://" * Base.string(host) * ":" * Base.string(port) * "/ ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        else
            println("Error: host IP [ " * Base.string(host) * " ] unrecognized.");
            # return false
        end
        if Core.isa(key, Core.String) && key !== ""
            Key_username::Core.String = "";  # "username";
            Key_password::Core.String = "";  # "password";
            if Base.occursin(":", key)
                Key_username = Base.convert(Core.String, Base.split(key, ':')[1]);  # "username";
                Key_password = Base.convert(Core.String, Base.split(key, ':')[2]);  # "password";
            else
                Key_username = Base.string(key);  # "username";
            end
            if Key_username !== "" && Key_password !== ""
                println("Client key = [ " * Key_username * " ]" * " : " * "[ " * Key_password * " ].");
                println("Client connection password Request Head Authorization = [ \"" * Base.string(key) * "\" ].");
            elseif Key_username !== "" && Key_password === ""
                println("Client key = " * Key_username);
            elseif Key_username === "" && Key_password !== ""
                println("Client key = :" * Key_password);
            end
        end
        println("Import data interface JSON String: {\"Client_say\":\"這裏是需要傳入的數據字符串 this is import string data\"}.");
        println("Export data interface JSON String: {\"Server_say\":\"這裏是處理後傳出的數據字符串 this is export string data\"}.");
        println("Keyboard Enter [ Ctrl ] + [ c ] to close.");
        println("鍵盤輸入 [ Ctrl ] + [ c ] 中止運行.");
        print("\n");

        # resultArray::Core.Array{Core.Any, 1} = ["", "", total_worker_called_number];
        result = http_Server(
            host,  # "0.0.0.0" or "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
            port;  # 0 ~ 65535，監聽埠號（端口）;
            do_Function = do_Function,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Request";
            key = key,  # ::Core.String = "username:password",  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
            session = session,  # ::Base.Dict{Core.String, Core.Any}("request_Key->username:password" => Key),  # 保存網站的 Session 數據;
            number_Worker_threads = number_Worker_threads,  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Base.Sys.CPU_THREADS,  # Core.UInt8(0)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
            time_sleep = time_sleep,  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
            readtimeout = readtimeout,  # 客戶端請求數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
            isConcurrencyHierarchy = isConcurrencyHierarchy,  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
            # worker_queues_Dict = worker_queues_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
            total_worker_called_number = total_worker_called_number,  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
            verbose = verbose  # 將連接資訊記錄到輸出到顯示器 Base.stdout 標準輸出流，log connection information to stdout;
        );

        if Base.typeof(result) <: Core.Array
            # && Base.length(result) >= 3

            # resultArray::Core.Array{Core.Any, 1} = ["", "", total_worker_called_number];
            resultArray = result;
            # resultArray[1] = result[1];
            # resultArray[2] = result[2];
            # resultArray[3] = result[3];
            # println(typeof(resultArray));
            # println(resultArray[1]);
            # println(resultArray[2]);
            # println(resultArray[3]);
        elseif Base.@isdefined(result)
            resultArray = ["error", result, total_worker_called_number];
        else
            resultArray = ["error", "", total_worker_called_number];
        end

    catch myException
        # println(Base.typeof(myException));
        # println(myException);
        # println(myException.msg);
        # 使用 Core.isa(myException, Core.InterruptException) 函數判斷 myException 的類型是否爲 Core.InterruptException;
        if Core.isa(myException, Core.InterruptException)

            print("\n");
            # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
            # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
            println("[ Ctrl ] + [ c ] received, will be stop the TCP Server.");

            # 打印進程被調用數目;
            if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

                # if isConcurrencyHierarchy === "Multi-Processes"

                #     # Base.haskey(collection, key) -> Bool
                #     # workNum = "worker";
                #     for k in Base.keys(total_worker_called_number)
                #         println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                #         # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                #     end
                #     # println(workNum);

                # elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

                #     # Base.haskey(collection, key) -> Bool
                #     # workNum = "worker";
                #     for k in Base.keys(total_worker_called_number)
                #         println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
                #         # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
                #     end
                #     # println(workNum);

                # end

                total_worker_called_number = Core.nothing;
            end

            # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
            # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

            #     # Base.haskey(collection, key) -> Bool
            #     # for k in Base.keys(worker_queues_Dict)
            #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
            #     # end

            #     worker_queues_Dict = Core.nothing;
            # end

            println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
            println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

            # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
            # Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;
            # Base.exit(0);  # 立即中止進程;
            return resultArray;
        else
            println(myException);
        end
    end

    # HTTP.forceclose(server);  # 立即中止服務器和所有鏈接無善後處置，will immediately force close the server and all active connections;
    # Base.close(server);  # 依次中止服務器對象並做善後處置，Gracefully close server manually;
    # Base.exit(0);  # 立即中止進程;
    # return resultArray;
end


# # 使用 Julia 語言的第三方擴展包「HTTP」製作的，媒介服務器函數服務端（後端） HTTP.listen!() 使用説明;
# # using HTTP;  # 導入第三方擴展包「HTTP」，用於創建 HTTP server 服務器，需要在控制臺先安裝第三方擴展包「HTTP」：julia> using Pkg; Pkg.add("HTTP") 成功之後才能使用;
# # using JSON;  # 導入第三方擴展包「JSON」，用於轉換JSON字符串為字典 Base.Dict 對象，需要在控制臺先安裝第三方擴展包「JSON」：julia> using Pkg; Pkg.add("JSON") 成功之後才能使用;
# # 控制臺命令行使用:
# # C:\>C:\Criss\Julia\Julia-1.9.3\bin\julia.exe -p 4 --project=C:/Criss/jl/ C:\Criss\jl\src\Router.jl
# # 啓動運行;
# # 參數 -p 4 表示設定允許 4 個進程并發;
# # 參數 --project=C:/Criss/jl/ 表示隔離全局環境，只是用項目私人環境 C:/Criss/jl/ 啓動 Julia 解釋器;
# # 媒介服務器函數服務端（後端） http_Server() 使用説明;
# webPath = Base.string(Base.Filesystem.joinpath(Base.string(Base.Filesystem.abspath(".")), "html"));  # 服務器運行的本地硬盤根目錄，可以使用函數：上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__;
# # webPath = Base.string(Base.Filesystem.abspath("."));  # 服務器運行的本地硬盤根目錄，可以使用函數：上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__;
# host = Sockets.IPv6(0);  # "::1";  # "127.0.0.1",  # "0.0.0.0" or "localhost"; 監聽主機域名 Host domain name;
# port = Core.UInt64(10001);  # ::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String} = Core.UInt8(8000),  # 0 ~ 65535， 監聽埠號（端口）;
# key = "username:password";  # ::Core.String = "username:password",  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
# session = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => key);  # 保存網站的 Session 數據;
# do_Function = do_Request;  # (argument) -> begin argument; end; 匿名函數對象，用於接收執行對根目錄(/)的 POST 請求處理功能的函數 "do_POST_root_directory";
# number_Worker_threads = Core.UInt8(Base.Sys.CPU_THREADS);  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Base.Sys.CPU_THREADS,  # Core.UInt8(0)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
# time_sleep = Core.Float16(0);  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
# readtimeout = Core.Int(0);  # 客戶端請求數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
# verbose = Core.Bool(false);  # 將連接資訊記錄到輸出到顯示器 Base.stdout 標準輸出流，log connection information to stdout;
# isConcurrencyHierarchy = "Tasks";  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
# # print("isConcurrencyHierarchy: ", isConcurrencyHierarchy, "\n");
# # 當 isConcurrencyHierarchy = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
# # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
# # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
# # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
# # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;
# http_Server = http_Server;
# # worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
# # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;

# # a = Array{Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}(Core.nothing, 3);
# a = http_Server_Run(
#     host = host,  # ::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4} = Sockets.IPv6(0),  # "::1";  # "127.0.0.1",  # "0.0.0.0" or "localhost"; 監聽主機域名 Host domain name;
#     port = port,  # ::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String} = 8000, # 0 ~ 65535， 監聽埠號（端口）;
#     do_Function = do_Function,  # do_Request,  # (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Request_root_directory";
#     key = key,  # ::Core.String = "username:password",  # "username:password" 自定義的訪問網站簡單驗證用戶名和密碼;
#     session = session,  # ::Base.Dict{Core.String, Core.Any}("request_Key->username:password" => Key),  # 保存網站的 Session 數據;
#     number_Worker_threads = number_Worker_threads,  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Base.Sys.CPU_THREADS,  # Core.UInt8(0)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
#     time_sleep = time_sleep,  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
#     readtimeout = readtimeout,  # 客戶端請求數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
#     verbose = verbose,  # 將連接資訊記錄到輸出到顯示器 Base.stdout 標準輸出流，log connection information to stdout;
#     isConcurrencyHierarchy = isConcurrencyHierarchy,  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
#     # worker_queues_Dict = worker_queues_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
#     # total_worker_called_number = total_worker_called_number,  # Base.Dict{Core.String, Core.UInt64}();  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
#     http_Server = http_Server
# );
# println(typeof(a))
# println(a[1])
# println(a[2])
# println(a[3])




# using HTTP;  # 導入第三方擴展包「HTTP」，用於創建 HTTP server 服務器，需要在控制臺先安裝第三方擴展包「HTTP」：julia> using Pkg; Pkg.add("HTTP") 成功之後才能使用;
# Cookie Persistence;
mycookiejar::HTTP.CookieJar = HTTP.CookieJar();
# HTTP.Cookies.setcookies!(mycookiejar, http_response.message.url, http_response.message.headers);  # HTTP.Cookies.setcookies!(jar::CookieJar, url::URI, headers::Headers)
# HTTP.Cookies.getcookies!(mycookiejar, http_response.message.url);  # HTTP.Cookies.getcookies!(jar::CookieJar, url::URI)


# HTTP_Server_「第三方擴展包 HTTP.jl 的 HTTP.request() 函數」;
# https://github.com/JuliaWeb/HTTP.jl
# 如果想臨時更換pkg工具下載鏡像源，在julia解釋器環境命令行輸入命令：
# julia> ENV["JULIA_PKG_SERVER"]="https://mirrors.bfsu.edu.cn/julia/static"
# 或者：
# Windows Powershell: $env:JULIA_PKG_SERVER = 'https://pkg.julialang.org'
# Linux/macOS Bash: export JULIA_PKG_SERVER="https://pkg.julialang.org"
# using HTTP;  # 導入第三方擴展包「HTTP」，用於創建 HTTP server 服務器，需要在控制臺先安裝第三方擴展包「HTTP」：julia> using Pkg; Pkg.add("HTTP") 成功之後才能使用;
# using JSON;  # 導入第三方擴展包「JSON」，用於轉換JSON字符串為字典 Base.Dict 對象，需要在控制臺先安裝第三方擴展包「JSON」：julia> using Pkg; Pkg.add("JSON") 成功之後才能使用;
function http_Client(
    host::Core.Union{Core.String, Sockets.IPv6, Sockets.IPv4},  # "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
    port::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String};  # 0 ~ 65535，監聽埠號（端口）;
    IPVersion::Core.String = "IPv6",  # "IPv6"、"IPv4";
    postData::Core.Union{Core.String, Base.Dict} = "",  # Base.Dict{Core.String, Core.Any}("Client_say" => "Julia-1.6.2 Sockets.connect."),  # postData::Core.Union{Core.String, Base.Dict{Core.Any, Core.Any}}，"{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"time\":\"" * Base.string(now_date) * "\"}";
    proxy::Core.Union{Core.String, Core.Nothing, Core.Bool, Core.Int64} = Core.nothing,  # 當需要通過代理服務器僞裝發送請求時，代理服務器的網址 URL 值字符串，pass request through a proxy given as a url; alternatively, the , , , , and environment variables are also detected/used; if set, they will be used automatically when making requests.http_proxyHTTP_PROXYhttps_proxyHTTPS_PROXYno_proxy;
    requestPath::Core.String = "/",
    requestProtocol::Core.String = "HTTP",  # Base.Unicode.lowercase(requestProtocol);  # 轉小寫字母;
    query::Core.Union{Base.Dict{Core.String, Core.String}, Core.String, Core.Nothing, Core.Bool, Core.Int64} = Core.nothing,  # Base.Dict{Core.String, Core.String}(),  # Base.Dict{Core.String, Core.String}("ID" => "23"),  # 請求查詢 key => value 字典，a or of key => values to be included in the urlPairDict;
    URL::Core.String = "",  # Base.string(http_Client.requestProtocol) * "://" * Base.convert(Core.String, Base.strip((Base.split(Base.string(http_Client.Authorization), ' ')[2]))) * "@" * Base.string(http_Client.host) * ":" * Base.string(http_Client.port) * Base.string(http_Client.requestPath),  # 請求網址 URL："http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1;
    requestMethod::Core.String = "GET",  # "POST",  # "GET"; # 請求方法;
    # time_out::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
    readtimeout::Core.Int = Core.Int(0),  # 服務器響應數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
    connect_timeout::Core.Int = Core.Int(30),  # 服務器鏈接超時，單位：（秒），close the connection after this many seconds if it is still attempting to connect. Use to disable.connect_timeout = 0;
    Authorization::Core.String = ":",  # "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
    Basicbasicauth::Core.Bool = true,  # 設置從請求網址 URL 中解析截取請求的賬號和密碼，Basic authentication is detected automatically from the provided url's (in the form userinfoscheme://user:password@host) and adds the 「Authorization:」 header; this can be disabled by passing Basicbasicauth = false;
    Cookie::Core.String = "",  # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
    Referrer::Core.String = http_Client.URL,  # 請求的來源網頁 URL "http://username:password@127.0.0.1:8081/index?a=1&b=2&c=3#a1";
    requestFrom::Core.String = "user@email.com",
    # do_Function = (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Response";
    # session::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => http_Server.key),  # 保存網站的 Session 數據;
    # number_Worker_threads::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.UInt8(0),  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
    # time_sleep::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
    # isConcurrencyHierarchy::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
    # worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
    # total_worker_called_number::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}(),  # 記錄每個綫程纍加的被調用運算的總次數;
    response_stream::Core.Union{Base.IOStream, Base.IOBuffer, Core.Array{Core.UInt8, 1}, Base.Vector{UInt8}, Core.Nothing, Core.Bool, Core.Int64} = Core.nothing,  # Base.IOBuffer(),  # 設置接收到的響應值類型爲二進制字節流 IO 對象，a writeable stream or any -like type for which is defined. The response body will be written to this stream instead of returned as a .IOIOTwrite(T, AbstractVector{UInt8})Base.Vector{UInt8};
    cookiejar::HTTP.CookieJar = HTTP.CookieJar()  # Cookie Persistence; # HTTP.Cookies.setcookies!(mycookiejar, http_response.message.url, http_response.message.headers);  # HTTP.Cookies.setcookies!(jar::CookieJar, url::URI, headers::Headers);  # HTTP.Cookies.getcookies!(mycookiejar, http_response.message.url);  # HTTP.Cookies.getcookies!(jar::CookieJar, url::URI);
)::Core.Array{Core.Any, 1}
    # ::Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String}, 1}

    # # print("當前協程 task: ", Base.current_task(), "\n");
    # print("當前協程 task 的 ID: ", Base.objectid(Base.current_task()), "\n");
    # print("當前綫程 thread 的 ID: ", Base.Threads.threadid(), "\n");
    # print("Julia 進程可用的綫程數目上綫: ", Base.Threads.nthreads(), "\n");
    # print("當前進程的 PID: ", Distributed.myid(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有進程的 PID: ", Distributed.procs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("所有 Worker 進程的 PID: ", Distributed.workers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("進程數目: ", Distributed.nprocs(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("Worker 進程數目: ", Distributed.nworkers(), "\n");  # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
    # print("當前進程名稱: ", Base.Sys.get_process_title(), "\n");
    # print("運行當前進程的操作系統架構: ", Base.Sys.ARCH, "\n");
    # print("運行當前進程的操作系統平臺: ", Base.Sys.KERNEL, "\n");
    # print("運行當前進程的 Julia 解釋器版本號: Julia-", Base.VERSION, "\n");
    # print("當前正在運行的 Julia 解釋器可執行檔的絕對路徑: ", Base.Sys.BINDIR, "\n");
    # print("當前正在執行的 Julia 脚本文檔路徑: ", Base.PROGRAM_FILE, "\n");
    # print("當前系統可用的中央處理器(CPU)數目: ", Base.Sys.CPU_THREADS, "\n");
    # print("當前正在運行的 Julia 解釋器編譯生成時的信息: ", Base.Sys.MACHINE, "\n");
    # print("當前正在運行的 Julia 解釋器運行環境的機器字節長度: ", Base.Sys.WORD_SIZE, "\n");  # 現在多爲 64 位;
    # println(Base.ENV);  # 用字典形式存儲的操作系統環境變量信息;
    # println(Base.DL_LOAD_PATH);  # 字符串數組，記錄著動態庫的搜索路徑;
    # println(Base.Libdl.dlext);  # 字符串類型，記錄著當前操作系統平臺動態庫文件的擴展名，例如 dll、so 或 dylib 等;

    # println(Base.Sys.CPU_THREADS)  # 4 可用 CPU 數;
    # println(Base.Filesystem.ispath(Base.Filesystem.pwd()))  # true 判斷目錄是否存在;
    # println(Base.Sys.BINDIR)  # C:\Program Files\Julia 1.5.1\bin;
    # println(Base.PROGRAM_FILE)  # c:\Users\china\Documents\Node.js\Criss\jl\tempCodeRunnerFile.jl;
    # println(Base.Filesystem.basename(Base.Filesystem.pwd()))  # Criss;
    # # "File_Directory_and_Path";
    # println(Base.Filesystem.homedir())  # C:\Users\china;
    # println(Base.Filesystem.pwd())  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath("."))  # c:\Users\china\Documents\Node.js\Criss 當前工作目錄;
    # println(Base.Filesystem.abspath(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js\Criss;
    # # 获取路径的目录;
    # println(Base.Filesystem.dirname(Base.Filesystem.pwd()))  # c:\Users\china\Documents\Node.js;
    # # "/Users/juliauser/Functions_Scripts_Codes_Pipelines/Julia_Codes";
    # # 路径的末端分割;
    # println(Base.Filesystem.splitdir(Base.Filesystem.pwd()));
    # # ("c:\\Users\\china\\Documents\\Node.js", "Criss");
    # # 路径的合成;
    # println(Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "temp", "intermediary_write_NodeJS.txt"));  # c:\Users\china\Documents\Node.js\temp\intermediary_write_NodeJS.txt;
    # # Base.Filesystem.cd()  # 更換工作目錄;
    # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl"))
    # # println(Base.stat("C:\\Users\\china\\Documents\\Node.js\\Criss\\jl").mode) # 返回值為 Core.UInt64 類型數值，例如 Core.UInt64(33206);


    # 判斷傳入的參數用於指定監聽主機的 IP 地址或域名 host 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(host) 判斷 host 變量是否已經被定義過;
    if !Base.@isdefined(host) || host === "" || host === Core.nothing
        # local host = "127.0.0.1",  # "0.0.0.0" or "localhost";
        # local host = Core.nothing;  # 置空;
        println("用於指定監聽主機的 IP 地址或域名「host ∈ ", Base.typeof(host), "」不能被識別.");
        return ["error", host, "argument [ host = " * Base.string(host) * " ] typeof error, no defined."];  # "用於指定監聽主機的 IP 地址或域名「host = " * Base.string(Base.typeof(host)) * "」不能被識別.";
    elseif !Core.isa(host, Core.String) && !Core.isa(host, Sockets.IPv6) && !Core.isa(host, Sockets.IPv4)
        # 使用 Core.isa(host, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(host) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(host) === Core.String 方法判別 host 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於指定監聽主機的 IP 地址或域名「host ∈ ", Base.typeof(host), "」不合法，只接受輸入主機 IP 地址或域名字符串.");
        return ["error", host, "argument [ host = " * Base.string(host) * " ] typeof error, not String."];  # ["error", host, "用於指定監聽主機的 IP 地址或域名「host = " * Base.string(Base.typeof(host)) * "」不合法，只接受輸入主機 IP 地址或域名字符串."];
    end

    # 判斷傳入的參數用於指定監聽主機的 IP 地址或域名 host 版本標志爲 IPv6 還是 IPv4 版，使用函數 Base.@isdefined(IPVersion) 判斷 IPVersion 變量是否已經被定義過;
    if !Base.@isdefined(IPVersion) || IPVersion === "" || IPVersion === Core.nothing
        # local host = "127.0.0.1",  # "0.0.0.0" or "localhost";
        # local host = Core.nothing;  # 置空;
        IPVersion = "IPv6";
        # println("用於指定監聽主機的 IP 地址版本「IP Version ∈ ", Base.typeof(IPVersion), "」不能被識別.");
        # return ["error", IPVersion, "argument [ IPVersion = " * Base.string(IPVersion) * " ] typeof error, no defined."];  # "用於指定監聽主機的 IP 地址或域名「IPVersion = " * Base.string(Base.typeof(IPVersion)) * "」不能被識別.";
    elseif !Core.isa(IPVersion, Core.String) || !(IPVersion === "IPv6" || IPVersion === "IPv4")
        # 使用 Core.isa(IPVersion, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(IPVersion) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(IPVersion) === Core.String 方法判別 IPVersion 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於指定監聽主機的 IP 地址版本「IP Version ∈ ", Base.typeof(IPVersion), "」不合法，只接受輸入主機 IP 地址版本類型[ \"IPv6\", \"IPv4\" ]字符串.");
        return ["error", IPVersion, "argument [ IPVersion = " * Base.string(IPVersion) * " ] typeof error, not String or IPv6 or IPv4."];  # ["error", IPVersion, "用於指定監聽主機的 IP 地址或域名「IPVersion = " * Base.string(Base.typeof(IPVersion)) * "」不合法，只接受輸入主機 IP 地址或域名字符串."];
    end

    # 判斷傳入的參數用於指定監聽主機埠號（端口） port 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(port) 判斷 port 變量是否已經被定義過;
    if !Base.@isdefined(port) || port === "" || port === Core.nothing
        # local port = Core.UInt8(5000);  # Core.UInt8 類型，用於指定監聽主機埠號（端口），自定義函數檢查輸入合規性 CheckString(port, 'arabic_numerals');
        port = Core.UInt8(8081);  # Core.UInt8 類型，用於指定監聽主機埠號（端口），自定義函數檢查輸入合規性 CheckString(port, 'arabic_numerals');
        # local port = Core.nothing;  # 置空;
        # println("傳入的參數用於指定監聽主機埠號（端口）「port ∈ ", Base.typeof(port), "」不能被識別.");
        # return "argument [ port = " * Base.string(port) * " ] typeof error, no defined."  # "用於指定監聽主機埠號（端口）「port = " * Base.string(Base.typeof(port)) * "」不能被識別.";
    elseif !(Base.typeof(port) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(port, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(port) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(port) <: Core.UInt64 方法判別 port 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於指定監聽主機埠號（端口）「port ∈ ", Base.typeof(port), "」不是一個數值類型的變量.");
        return "argument [ port = " * Base.string(port) * " ] typeof error, not Float and not Int."  # "用於指定監聽主機埠號（端口）「port = " * Base.string(Base.typeof(port)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # 判斷傳入的參數用於向服務器發送的請求數據字典或字符串變量 postData 是否已定義且為字典類型 Base.Dict 或字符串 Core.String 類型;
    if !Base.@isdefined(postData) || postData === Core.nothing
        # postData = Base.Dict{Core.String, Core.Any}("Client_say" => "Julia-1.6.2 Sockets.connect.");  # 用於記錄服務器 postData 數據的字典變量;        
        println("用於向服務器發送的請求數據 postData 字典或字符串變量「postData ∈ ", Base.typeof(postData), "」不能被識別.");
        return ["error", postData, "argument [ postData ∈ " * Base.string(postData) * " ] typeof error, no defined."];  # "用於向服務器發送的請求數據 postData 字典或字符串變量「postData ∈ " * Base.string(Base.typeof(postData)) * "」不能被識別.";
    elseif !(Base.typeof(postData) <: Core.Union{Core.String, Base.Dict})
        # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求數據 postData 字典或字符串變量「postData ∈ ", Base.typeof(postData), "」不合法，只接受輸入字典(Base.Dict)或者字符串(Core.String)類型變量.");
        return ["error", postData, "argument [ postData ∈ " * Base.string(Base.typeof(postData)) * " ] typeof error, not Dict or String."];  # ["error", postData, "用於向服務器發送的請求數據 postData 字典或字符串變量「postData ∈ " * Base.string(Base.typeof(postData)) * "」不合法，只接受輸入字典(Base.Dict)或者字符串(Core.String)類型變量."];
    end

    # 判斷傳入的參數用於記錄服務器訪問賬號密碼的變量 key 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(key) 判斷 key 變量是否已經被定義過;
    if !Base.@isdefined(Authorization) || Authorization === Core.nothing
        # local Authorization = "username:password";
        # local Authorization = Core.nothing;  # 置空;
        println("用於記錄服務器訪問賬號密碼的變量「Authorization ∈ ", Base.typeof(Authorization), "」不能被識別.");
        return ["error", Authorization, "argument [ Authorization = " * Base.string(Authorization) * " ] typeof error, no defined."];  # "用於記錄服務器訪問賬號密碼的變量「Authorization = " * Base.string(Base.typeof(Authorization)) * "」不能被識別.";
    elseif !Core.isa(Authorization, Core.String)
        # 使用 Core.isa(Authorization, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(Authorization) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(Authorization) === Core.String 方法判別 Authorization 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於記錄服務器訪問賬號密碼的變量「Authorization ∈ ", Base.typeof(Authorization), "」不合法，只接受輸入「username:password」形式的字符串.");
        return ["error", Authorization, "argument [ Authorization = " * Base.string(Authorization) * " ] typeof error, not String."];  # ["error", Authorization, "用於記錄服務器訪問賬號密碼的變量「Authorization = " * Base.string(Base.typeof(Authorization)) * "」不合法，只接受輸入「username:password」形式的字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求頭 Cookie 參數 Cookie 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(Cookie) 判斷 Cookie 變量是否已經被定義過;
    if !Base.@isdefined(Cookie) || Cookie === Core.nothing
        # local Cookie = "Session_ID=request_Key->username:password";  # "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
        # local Cookie = Core.nothing;  # 置空;
        println("用於向服務器發送的請求頭 Cookie 參數「Cookie ∈ ", Base.typeof(Cookie), "」不能被識別.");
        return ["error", Cookie, "argument [ Cookie = " * Base.string(Cookie) * " ] typeof error, no defined."];  # "用於向服務器發送的請求頭 Cookie 參數「Cookie = " * Base.string(Base.typeof(Cookie)) * "」不能被識別.";
    elseif !Core.isa(Cookie, Core.String)
        # 使用 Core.isa(Cookie, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(Cookie) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(Cookie) === Core.String 方法判別 Cookie 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求頭 Cookie 參數「Cookie ∈ ", Base.typeof(Cookie), "」不合法，只接受輸入字符串.");
        return ["error", Cookie, "argument [ Cookie = " * Base.string(Cookie) * " ] typeof error, not String."];  # ["error", Cookie, "用於向服務器發送的請求頭 Cookie 參數「Cookie = " * Base.string(Base.typeof(Cookie)) * "」不合法，只接受輸入字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求頭 URL 參數 URL 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(URL) 判斷 URL 變量是否已經被定義過;
    # "http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1;
    if !Base.@isdefined(URL) || URL === Core.nothing
        # local URL = "";
        # local URL = Core.nothing;  # 置空;
        println("用於向服務器發送的請求頭 URL 參數「URL ∈ ", Base.typeof(URL), "」不能被識別.");
        return ["error", URL, "argument [ URL = " * Base.string(URL) * " ] typeof error, no defined."];  # "用於向服務器發送的請求頭 URL 參數「URL = " * Base.string(Base.typeof(URL)) * "」不能被識別.";
    elseif !Core.isa(URL, Core.String)
        # 使用 Core.isa(URL, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(URL) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(URL) === Core.String 方法判別 URL 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求頭 URL 參數「URL ∈ ", Base.typeof(URL), "」不合法，只接受輸入字符串.");
        return ["error", URL, "argument [ URL = " * Base.string(URL) * " ] typeof error, not String."];  # ["error", URL, "用於向服務器發送的請求頭 URL 參數「URL = " * Base.string(Base.typeof(URL)) * "」不合法，只接受輸入字符串."];
    end

    # # 判斷傳入的參數用於標記請求的來源網頁 URL 參數 Referrer 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(Referrer) 判斷 Referrer 變量是否已經被定義過;
    # if !Base.@isdefined(Referrer) || Referrer === Core.nothing
    #     # local Referrer = "";
    #     # local Referrer = Core.nothing;  # 置空;
    #     println("用於標記請求的來源網頁 URL 參數「Referrer ∈ ", Base.typeof(Referrer), "」不能被識別.");
    #     return ["error", Referrer, "argument [ Referrer = " * Base.string(Referrer) * " ] typeof error, no defined."];  # "用於標記請求的來源網頁 URL 參數「Referrer = " * Base.string(Base.typeof(Referrer)) * "」不能被識別.";
    # elseif !Core.isa(Referrer, Core.String)
    #     # 使用 Core.isa(Referrer, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(Referrer) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(Referrer) === Core.String 方法判別 Referrer 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於標記請求的來源網頁 URL 參數「Referrer ∈ ", Base.typeof(Referrer), "」不合法，只接受輸入字符串.");
    #     return ["error", Referrer, "argument [ Referrer = " * Base.string(Referrer) * " ] typeof error, not String."];  # ["error", Referrer, "用於標記請求的來源網頁 URL 參數「Referrer = " * Base.string(Base.typeof(Referrer)) * "」不合法，只接受輸入字符串."];
    # end

    # # 判斷傳入的參數當需要通過代理服務器僞裝發送請求時，代理服務器的網址 URL 值字符串參數 proxy 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(proxy) 判斷 proxy 變量是否已經被定義過;
    # if !Base.@isdefined(proxy) || proxy === Core.nothing
    #     # local proxy = "";
    #     # local proxy = Core.nothing;  # 置空;
    #     println("用於當需要通過代理服務器僞裝發送請求時，代理服務器的網址 URL 值字符串參數「proxy ∈ ", Base.typeof(proxy), "」不能被識別.");
    #     return ["error", proxy, "argument [ proxy = " * Base.string(proxy) * " ] typeof error, no defined."];  # "用於當需要通過代理服務器僞裝發送請求時，代理服務器的網址 URL 值字符串參數「proxy = " * Base.string(Base.typeof(proxy)) * "」不能被識別.";
    # elseif !Core.isa(proxy, Core.String)
    #     # 使用 Core.isa(proxy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(proxy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(proxy) === Core.String 方法判別 proxy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於當需要通過代理服務器僞裝發送請求時，代理服務器的網址 URL 值字符串參數「proxy ∈ ", Base.typeof(proxy), "」不合法，只接受輸入字符串.");
    #     return ["error", proxy, "argument [ proxy = " * Base.string(proxy) * " ] typeof error, not String."];  # ["error", proxy, "用於當需要通過代理服務器僞裝發送請求時，代理服務器的網址 URL 值字符串參數「proxy = " * Base.string(Base.typeof(proxy)) * "」不合法，只接受輸入字符串."];
    # elseif proxy === ""
    #     proxy = Core.nothing;
    # end

    # 判斷傳入的參數用於向服務器發送的請求路徑參數 requestPath 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(requestPath) 判斷 requestPath 變量是否已經被定義過;
    if !Base.@isdefined(requestPath) || requestPath === Core.nothing
        # local requestPath = "/";
        # local requestPath = Core.nothing;  # 置空;
        println("用於向服務器發送的請求路徑參數「requestPath ∈ ", Base.typeof(requestPath), "」不能被識別.");
        return ["error", requestPath, "argument [ requestPath = " * Base.string(requestPath) * " ] typeof error, no defined."];  # "用於向服務器發送的請求路徑參數「requestPath = " * Base.string(Base.typeof(requestPath)) * "」不能被識別.";
    elseif !Core.isa(requestPath, Core.String)
        # 使用 Core.isa(requestPath, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(requestPath) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(requestPath) === Core.String 方法判別 requestPath 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求路徑參數「requestPath ∈ ", Base.typeof(requestPath), "」不合法，只接受輸入字符串.");
        return ["error", requestPath, "argument [ requestPath = " * Base.string(requestPath) * " ] typeof error, not String."];  # ["error", requestPath, "用於向服務器發送的請求路徑參數「requestPath = " * Base.string(Base.typeof(requestPath)) * "」不合法，只接受輸入字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求方法參數 requestMethod 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(requestMethod) 判斷 requestMethod 變量是否已經被定義過;
    if !Base.@isdefined(requestMethod) || requestMethod === Core.nothing
        # local requestMethod = "GET",  # "POST";
        # local requestMethod = Core.nothing;  # 置空;
        println("用於向服務器發送的請求方法參數「requestMethod ∈ ", Base.typeof(requestMethod), "」不能被識別.");
        return ["error", requestMethod, "argument [ requestMethod = " * Base.string(requestMethod) * " ] typeof error, no defined."];  # "用於向服務器發送的請求方法參數「requestMethod = " * Base.string(Base.typeof(requestMethod)) * "」不能被識別.";
    elseif !Core.isa(requestMethod, Core.String)
        # 使用 Core.isa(requestMethod, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(requestMethod) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(requestMethod) === Core.String 方法判別 requestMethod 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求方法參數「requestMethod ∈ ", Base.typeof(requestMethod), "」不合法，只接受輸入字符串.");
        return ["error", requestMethod, "argument [ requestMethod = " * Base.string(requestMethod) * " ] typeof error, not String."];  # ["error", requestMethod, "用於向服務器發送的請求方法參數「requestMethod = " * Base.string(Base.typeof(requestMethod)) * "」不合法，只接受輸入字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求協議參數 requestProtocol 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(requestProtocol) 判斷 requestProtocol 變量是否已經被定義過;
    if !Base.@isdefined(requestProtocol) || requestProtocol === Core.nothing
        # local requestProtocol = "HTTP";
        # local requestProtocol = Core.nothing;  # 置空;
        println("用於向服務器發送的請求協議參數「requestProtocol ∈ ", Base.typeof(requestProtocol), "」不能被識別.");
        return ["error", requestProtocol, "argument [ requestProtocol = " * Base.string(requestProtocol) * " ] typeof error, no defined."];  # "用於向服務器發送的請求協議參數「requestProtocol = " * Base.string(Base.typeof(requestProtocol)) * "」不能被識別.";
    elseif !Core.isa(requestProtocol, Core.String)
        # 使用 Core.isa(requestProtocol, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(requestProtocol) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(requestProtocol) === Core.String 方法判別 requestProtocol 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        # Base.Unicode.lowercase(requestProtocol);  # 轉小寫字母;
        println("用於向服務器發送的請求協議參數「requestProtocol ∈ ", Base.typeof(requestProtocol), "」不合法，只接受輸入字符串.");
        return ["error", requestProtocol, "argument [ requestProtocol = " * Base.string(requestProtocol) * " ] typeof error, not String."];  # ["error", requestProtocol, "用於向服務器發送的請求協議參數「requestProtocol = " * Base.string(Base.typeof(requestProtocol)) * "」不合法，只接受輸入字符串."];
    end

    # 判斷傳入的參數用於向服務器發送的請求者聯係方式 From 參數 requestFrom 是否已定義且為字符串類型 String，使用函數 Base.@isdefined(requestFrom) 判斷 requestFrom 變量是否已經被定義過;
    if !Base.@isdefined(requestFrom) || requestFrom === Core.nothing
        # local requestFrom = "user@email.com";
        # local requestFrom = Core.nothing;  # 置空;
        println("用於向服務器發送的請求者聯係方式 From 參數「requestFrom ∈ ", Base.typeof(requestFrom), "」不能被識別.");
        return ["error", requestFrom, "argument [ requestFrom = " * Base.string(requestFrom) * " ] typeof error, no defined."];  # "用於向服務器發送的請求者聯係方式 From 參數「requestFrom = " * Base.string(Base.typeof(requestFrom)) * "」不能被識別.";
    elseif !Core.isa(requestFrom, Core.String)
        # 使用 Core.isa(requestFrom, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(requestFrom) <: AbstraclString 方法判斷「集合」是否包含於「集合」之���的關係，使用 Base.typeof(requestFrom) === Core.String 方法判別 requestFrom 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("用於向服務器發送的請求者聯係方式 From 參數「requestFrom ∈ ", Base.typeof(requestFrom), "」不合法，只接受輸入字符串.");
        return ["error", requestFrom, "argument [ requestFrom = " * Base.string(requestFrom) * " ] typeof error, not String."];  # ["error", requestFrom, "用於向服務器發送的請求者聯係方式 From 參數「requestFrom = " * Base.string(Base.typeof(requestFrom)) * "」不合法，只接受輸入字符串."];
    end

    # # 判斷傳入的參數用於記錄服務器 Session 數據的字典變量 session 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(session) 判斷 session 變量是否已經被定義過;
    # if !Base.@isdefined(session) || session === "" || session === Core.nothing
    #     # session = Base.Dict{Core.String, Core.String}("request_Key->username:password" => Authorization);  # 用於記錄服務器 Session 數據的字典變量;        
    #     println("用於記錄服務器 Session 數據的字典變量「session ∈ ", Base.typeof(session), "」不能被識別.");
    #     return ["error", session, "argument [ session ∈ " * Base.string(session) * " ] typeof error, no defined."];  # "用於保存服務器 Session 數據的字典變量「session ∈ " * Base.string(Base.typeof(session)) * "」不能被識別.";
    # elseif !(Base.typeof(session) <: Base.Dict)
    #     # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於記錄服務器 Session 數據的字典變量「session ∈ ", Base.typeof(session), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
    #     return ["error", session, "argument [ session ∈ " * Base.string(Base.typeof(session)) * " ] typeof error, not Dict."];  # ["error", session, "用於記錄服務器 Session 數據的字典變量「session ∈ " * Base.string(Base.typeof(session)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    # end

    # # 判斷傳入的參數用於具體執行處理客戶端請求數據的函數 do_Function 是否已定義且為函數，使用函數 Base.@isdefined(do_Function) 判斷 do_Function 變量是否已經被定義過;
    # if !Base.@isdefined(do_Function) || do_Function === "" || do_Function === Core.nothing
    #     # local do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # local do_Function = Core.nothing;  # 置空;
    #     println("用於具體執行處理客戶端請求數據的函數「do_Function ∈ ", Base.typeof(do_Function), "」不能被識別.");
    #     return "argument [ do_Function = " * Base.string(do_Function) * " ] typeof error, no defined."  # "用於具體執行處理客戶端請求數據的函數「do_Function = " * Base.string(Base.typeof(do_Function)) * "」不能被識別.";
    # elseif !(Base.typeof(do_Function) <: Core.Function)
    #     # 使用 Core.isa(do_Function, Function) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(do_Function) <: Function 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(do_Function) <: Function 方法判別 do_Function 變量的類型是否包含於函數Function類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於具體執行處理客戶端請求數據的函數「do_Function ∈ ", Base.typeof(do_Function), "」不是一個函數類型的變量.");
    #     return "argument [ do_Function = " * Base.string(do_Function) * " ] typeof error, not Function."  # "用於具體執行處理客戶端請求數據的函數「do_Function = " * Base.string(Base.typeof(do_Function)) * "」不是一個函數類型的變量.";

    #     # try
    #     #     if length(methods(do_Function)) > 0
    #     #         global do_Function = do_data;
    #     #     else
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     end
    #     # catch err
    #     #     # println(err);
    #     #     # println(Base.typeof(err));
    #     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
    #     #     if Core.isa(err, Core.UndefVarError)
    #     #         println(err.var, " not defined.");
    #     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     else
    #     #         println(err);
    #     #     end
    #     # finally
    #     #     # global do_Function = Core.nothing;  # 置空;
    #     #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # end
    # end

    # # 判斷傳入的自定義多綫程并發數目參數 number_Worker_threads 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(number_Worker_threads) 判斷 number_Worker_threads 變量是否已經被定義過;
    # if !Base.@isdefined(number_Worker_threads) || number_Worker_threads === "" || number_Worker_threads === Core.nothing
    #     # local number_Worker_threads = Core.UInt8(0);  # Core.UInt8 類型，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
    #     # number_Worker_threads = Core.UInt8(0);  # Core.UInt8 類型，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
    #     # local number_Worker_threads = Core.nothing;  # 置空;
    #     println("傳入的參數，指定的變量「number_Worker_threads ∈ ", Base.typeof(number_Worker_threads), "」不能被識別.");
    #     return "argument [ number_Worker_threads = " * Base.string(number_Worker_threads) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「number_Worker_threads = " * Base.string(Base.typeof(number_Worker_threads)) * "」不能被識別.";
    # elseif !(Base.typeof(number_Worker_threads) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
    #     # 使用 Core.isa(number_Worker_threads, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(number_Worker_threads) <: Core.UInt64 方法判別 number_Worker_threads 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("傳入的參數，指定的變量「number_Worker_threads ∈ ", Base.typeof(number_Worker_threads), "」不是一個數值類型的變量.");
    #     return "argument [ number_Worker_threads = " * Base.string(number_Worker_threads) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「number_Worker_threads = " * Base.string(Base.typeof(number_Worker_threads)) * "」不是一個數值類型的變量.";

    #     # try
    #     #     if length(methods(do_data)) > 0
    #     #         global do_Function = do_data;
    #     #     else
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     end
    #     # catch err
    #     #     # println(err);
    #     #     # println(Base.typeof(err));
    #     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
    #     #     if Core.isa(err, Core.UndefVarError)
    #     #         println(err.var, " not defined.");
    #     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     else
    #     #         println(err);
    #     #     end
    #     # finally
    #     #     # global do_Function = Core.nothing;  # 置空;
    #     #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # end
    # end

    # 判斷傳入的自定義服務器響應數據讀取超時，單位：（秒）參數 readtimeout 是否已定義且為整數類型 Core.Int，使用函數 Base.@isdefined(readtimeout) 判斷 readtimeout 變量是否已經被定義過;
    if !Base.@isdefined(readtimeout) || readtimeout === "" || readtimeout === Core.nothing
        # local readtimeout = Core.Int(0);  # Core.Int 類型，服務器響應數據讀取超時，單位：（秒），自定義函數檢查輸入合規性 CheckString(readtimeout, 'arabic_numerals');
        # readtimeout = Core.Int(0);  # Core.Int 類型，服務器響應數據讀取超時，單位：（秒），自定義函數檢查輸入合規性 CheckString(readtimeout, 'arabic_numerals');
        # local readtimeout = Core.nothing;  # 置空;
        println("傳入的參數，指定的變量「readtimeout ∈ ", Base.typeof(readtimeout), "」不能被識別.");
        return "argument [ readtimeout = " * Base.string(readtimeout) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「readtimeout = " * Base.string(Base.typeof(readtimeout)) * "」不能被識別.";
    elseif !(Base.typeof(readtimeout) <: Core.Int)
    # elseif !(Base.typeof(readtimeout) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(readtimeout, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(readtimeout) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(readtimeout) <: Core.UInt64 方法判別 readtimeout 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「readtimeout ∈ ", Base.typeof(readtimeout), "」不是一個數值類型的變量.");
        return "argument [ readtimeout = " * Base.string(readtimeout) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「readtimeout = " * Base.string(Base.typeof(readtimeout)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # # Cookie Persistence;
    # mycookiejar::HTTP.CookieJar = HTTP.CookieJar();
    # # HTTP.Cookies.setcookies!(mycookiejar, http_response.message.url, http_response.message.headers);  # HTTP.Cookies.setcookies!(jar::CookieJar, url::URI, headers::Headers)
    # # HTTP.Cookies.getcookies!(mycookiejar, http_response.message.url);  # HTTP.Cookies.getcookies!(jar::CookieJar, url::URI)

    # 判斷傳入的自定義服務器鏈接超時，單位：（秒）參數 connect_timeout 是否已定義且為整數類型 Core.Int，使用函數 Base.@isdefined(connect_timeout) 判斷 connect_timeout 變量是否已經被定義過;
    if !Base.@isdefined(connect_timeout) || connect_timeout === "" || connect_timeout === Core.nothing
        # local connect_timeout = Core.Int(0);  # Core.Int 類型，服務器鏈接超時，單位：（秒），自定義函數檢查輸入合規性 CheckString(connect_timeout, 'arabic_numerals');
        # connect_timeout = Core.Int(0);  # Core.Int 類型，服務器鏈接超時，單位：（秒），自定義函數檢查輸入合規性 CheckString(connect_timeout, 'arabic_numerals');
        # local connect_timeout = Core.nothing;  # 置空;
        println("傳入的參數，指定的變量「connect_timeout ∈ ", Base.typeof(connect_timeout), "」不能被識別.");
        return "argument [ connect_timeout = " * Base.string(connect_timeout) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「connect_timeout = " * Base.string(Base.typeof(connect_timeout)) * "」不能被識別.";
    elseif !(Base.typeof(connect_timeout) <: Core.Int)
    # elseif !(Base.typeof(connect_timeout) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
        # 使用 Core.isa(connect_timeout, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(connect_timeout) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(connect_timeout) <: Core.UInt64 方法判別 connect_timeout 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
        # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
        # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
        println("傳入的參數，指定的變量「connect_timeout ∈ ", Base.typeof(connect_timeout), "」不是一個數值類型的變量.");
        return "argument [ connect_timeout = " * Base.string(connect_timeout) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「connect_timeout = " * Base.string(Base.typeof(connect_timeout)) * "」不是一個數值類型的變量.";

        # try
        #     if length(methods(do_data)) > 0
        #         global do_Function = do_data;
        #     else
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     end
        # catch err
        #     # println(err);
        #     # println(Base.typeof(err));
        #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
        #     if Core.isa(err, Core.UndefVarError)
        #         println(err.var, " not defined.");
        #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
        #         # global do_Function = Core.nothing;  # 置空;
        #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        #     else
        #         println(err);
        #     end
        # finally
        #     # global do_Function = Core.nothing;  # 置空;
        #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
        # end
    end

    # # 判斷傳入的自定義系統暫停時長參數 time_sleep 是否已定義且為數值類型 Union{Float64, Float32, Float16, Int, Int128, Int64, Int32, Int16, Int8, UInt, UInt128, Core.UInt64, UInt32, UInt16, UInt8}，使用函數 Base.@isdefined(time_sleep) 判斷 time_sleep 變量是否已經被定義過;
    # if !Base.@isdefined(time_sleep) || time_sleep === "" || time_sleep === Core.nothing
    #     # local time_sleep = Core.Float64(0.02);  # Core.Float64 類型變量，20 毫秒，系統暫停等待時長;
    #     time_sleep = Core.Float64(0);  # Float64 類型變量，0.02 === 20 毫秒，系統暫停等待時長;
    #     # local time_sleep = Core.nothing;  # 置空;
    #     # println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不能被識別.");
    #     # return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, no defined."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不能被識別.";
    # elseif !(Base.typeof(time_sleep) <: Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8})
    #     # 使用 Core.isa(time_sleep, Core.UInt64) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(time_sleep) <: Core.UInt64 方法判別 time_sleep 變量的類型是否包含於 Core.UInt64 類型，符號 <: 表示集合之間的包含於的意思，比如 Int64 <: Real === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("傳入的參數，指定的變量「time_sleep ∈ ", Base.typeof(time_sleep), "」不是一個數值類型的變量.");
    #     return "argument [ time_sleep = " * Base.string(time_sleep) * " ] typeof error, not Float and not Int."  # "傳入的參數，指定的變量「time_sleep = " * Base.string(Base.typeof(time_sleep)) * "」不是一個數值類型的變量.";

    #     # try
    #     #     if length(methods(do_data)) > 0
    #     #         global do_Function = do_data;
    #     #     else
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     end
    #     # catch err
    #     #     # println(err);
    #     #     # println(Base.typeof(err));
    #     #     # 使用 Core.isa(err, Core.UndefVarError) 函數判斷err的類型是否爲Core.UndefVarError;
    #     #     if Core.isa(err, Core.UndefVarError)
    #     #         println(err.var, " not defined.");
    #     #         println("傳入的參數，指定的函數「" * Base.string(err.var) * "」未定義.");
    #     #         # global do_Function = Core.nothing;  # 置空;
    #     #         global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     #     else
    #     #         println(err);
    #     #     end
    #     # finally
    #     #     # global do_Function = Core.nothing;  # 置空;
    #     #     # global do_Function = (argument) -> begin argument; end;  # 匿名函數，直接返回傳入參數做返回值;
    #     # end
    # end

    # # 判斷傳入的參數用於指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量 isConcurrencyHierarchy 是否已定義且為字符串類型 Core.String，使用函數 Base.@isdefined(isConcurrencyHierarchy) 判斷 isConcurrencyHierarchy 變量是否已經被定義過;
    # if !Base.@isdefined(isConcurrencyHierarchy) || isConcurrencyHierarchy === "" || isConcurrencyHierarchy === Core.nothing
    #     # local isConcurrencyHierarchy = "Tasks" || "Multi-Threading" || "Multi-Processes";
    #     # local isConcurrencyHierarchy = Core.nothing;  # 置空;
    #     println("指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy ∈ ", Base.typeof(isConcurrencyHierarchy), "」不能被識別.");
    #     return ["error", isConcurrencyHierarchy, "argument [ isConcurrencyHierarchy = " * Base.string(isConcurrencyHierarchy) * " ] typeof error, no defined."];  # "指定監聽并發的層次（多綫程、多進程）的變量「isConcurrencyHierarchy = " * Base.string(Base.typeof(isConcurrencyHierarchy)) * "」不能被識別.";
    # elseif !Core.isa(isConcurrencyHierarchy, Core.String) || (isConcurrencyHierarchy !== "Tasks" && isConcurrencyHierarchy !== "Multi-Threading" && isConcurrencyHierarchy !== "Multi-Processes")
    #     # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy ", Base.typeof(isConcurrencyHierarchy), "」不合法，只接受輸入：\"Tasks\" || \"Multi-Threading\" 兩個值.");
    #     return ["error", isConcurrencyHierarchy, "argument [ isConcurrencyHierarchy = " * Base.string(isConcurrencyHierarchy) * " ] typeof error, not String."];  # ["error", isConcurrencyHierarchy, "指定具體運算執行功能的函數并發的層次（多協程、多綫程）的變量「isConcurrencyHierarchy = " * Base.string(Base.typeof(isConcurrencyHierarchy)) * "」不合法，只接受輸入：\"Tasks\" || \"Multi-Threading\" 兩個值."];
    # end

    # # 判斷傳入的參數用於保存每個綫程的字典變量 worker_queues_Dict 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(worker_queues_Dict) 判斷 worker_queues_Dict 變量是否已經被定義過;
    # if !Base.@isdefined(worker_queues_Dict) || worker_queues_Dict === "" || worker_queues_Dict === Core.nothing
    #     # worker_queues_Dict = Base.Dict{Core.String, Core.Any}();  # 保存每個工作子綫程;
    #     worker_queues_Dict = Base.Dict{Core.String, Core.UInt64}();  # 保存每個工作子綫程;
    #     # println("用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ ", Base.typeof(worker_queues_Dict), "」不能被識別.");
    #     # return ["error", worker_queues_Dict, "argument [ worker_queues_Dict ∈ " * Base.string(worker_queues_Dict) * " ] typeof error, no defined."];  # "用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * "」不能被識別.";
    # elseif !(Base.typeof(worker_queues_Dict) <: Base.Dict)
    #     # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ ", Base.typeof(worker_queues_Dict), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
    #     return ["error", worker_queues_Dict, "argument [ worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * " ] typeof error, not Dict."];  # ["error", worker_queues_Dict, "用於保存每個工作子綫程的字典變量「worker_queues_Dict ∈ " * Base.string(Base.typeof(worker_queues_Dict)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    # end

    # # 判斷傳入的參數用於記錄每個綫程纍加的被調用運算的總次數的字典變量 total_worker_called_number 是否已定義且為字典類型 Base.Dict，使用函數 Base.@isdefined(total_worker_called_number) 判斷 total_worker_called_number 變量是否已經被定義過;
    # if !Base.@isdefined(total_worker_called_number) || total_worker_called_number === "" || total_worker_called_number === Core.nothing
    #     # total_worker_called_number = Base.Dict{Core.String, Core.Any}();  # 記錄每個綫程纍加的被調用運算的總次數;
    #     # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # 記錄每個綫程纍加的被調用運算的總次數;
    #     println("用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ ", Base.typeof(total_worker_called_number), "」不能被識別.");
    #     return ["error", total_worker_called_number, "argument [ total_worker_called_number ∈ " * Base.string(total_worker_called_number) * " ] typeof error, no defined."];  # "用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * "」不能被識別.";
    # elseif !(Base.typeof(total_worker_called_number) <: Base.Dict)
    #     # 使用 Core.isa(isConcurrencyHierarchy, Core.String) 函數判斷「元素(變量實例)」是否屬於「集合(變量類型集)」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) <: AbstraclString 方法判斷「集合」是否包含於「集合」之間的關係，使用 Base.typeof(isConcurrencyHierarchy) === Core.String 方法判別 isConcurrencyHierarchy 變量的類型是否為字符串 String 類型，符號 <: 表示集合之間的包含於的意思，比如 Core.String <: AbstraclString === true，函數 Base.typeof(a) 返回的是變量 a 的直接類型值;
    #     # 函數實例（變量）的直接變量類型(集合)名為 Base.typeof(Fun_Name)，所有函數的直接類型集又都包含於總的函數 Function 類型集:
    #     # 即：sum ∈ Base.typeof(sum) ⊆ Function 和 "abc" ∈ Core.String ⊆ AbstraclString 和 2 ∈ Int64 ⊆ Real 等;
    #     println("用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ ", Base.typeof(total_worker_called_number), "」不合法，只接受輸入字典(Base.Dict)類型變量.");
    #     return ["error", total_worker_called_number, "argument [ total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * " ] typeof error, not Dict."];  # ["error", total_worker_called_number, "用於記錄每個綫程纍加的被調用運算的總次數的字典變量「total_worker_called_number ∈ " * Base.string(Base.typeof(total_worker_called_number)) * "」不合法，只接受輸入字典(Base.Dict)類型變量."];
    # end


    # 配置客戶端向服務器端發送的請求 Cookie 值;
    # Set-Cookie: name=value[; expires=date][; domain=domain][; path=path][; secure];
    # 其中，參數secure選項只是一個標記沒有其它的值，表示一個secure cookie只有當請求是通過SSL和HTTPS創建時，才會發送到伺服器端;
    # 參數domain選項表示cookie作用域，不支持IP數值，只能使用功能變數名稱，指示cookie將要發送到哪個域或那些域中，預設情況下domain會被設置為創建該cookie的頁面所在的功能變數名稱，domain選項被用來擴展cookie值所要發送域的數量;
    # 參數Path選項（The path option），與domain選項相同的是，path指明了在發Cookie消息頭之前，必須在請求資源中存在一個URL路徑，這個比較是通過將path屬性值與請求的URL從頭開始逐字串比較完成的，如果字元匹配，則發送Cookie消息頭;
    # 參數value部分，通常是一個 name=value 格式的字串，通常性的使用方式是以 name=value 的格式來指定cookie的值;
    # 通常cookie的壽命僅限於單一的會話中，流覽器的關閉意味這一次會話的結束，所以會話cookie只存在於流覽器保持打開的狀態之下，參數expires選項用於設定這個cookie壽命（有效時長），一個expires選項會被附加到登錄的cookie中指定一個截止日期，如果expires選項設置了一個過去的時間點，那麼這個cookie會被立即刪除;
    now_date = Dates.now();  # Base.string(Dates.now()) 返回當前日期時間字符串 2021-06-28T12:12:50.544，需要先加載原生 Dates 包 using Dates;
    # println(Base.string(Dates.now()))
    # after_1_Days = Dates.DateTime(Dates.year(now_date), Dates.month(now_date), Dates.day(now_date) + Dates.day(1), Dates.hour(now_date), Dates.minute(now_date), Dates.second(now_date), Dates.millisecond(now_date));  # 計算 1 日之後的日期，需要先加載原生 Dates 包 using Dates;
    # println(Base.string(after_1_Days));

    # 配置客戶端向服務器端發送請求的 Cookie 參數值字符串;
    cookie_key_value::Core.String = Cookie;  # "session_id=request_Key->username:password" -> "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
    cookie_key::Core.String = "";
    cookie_value::Core.String = "";
    if Base.occursin("=", Cookie)

        requestCookieArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
        # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
        # 函數 Base.split(Cookie, '=') 表示用等號字符'='分割字符串為數組;
        for x in Base.split(Cookie, '=')
            temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
            temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
            Base.push!(requestCookieArray, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
        end

        if Base.length(requestCookieArray) > 1

            requestCookieValue = "";
            # requestCookieArray = Base.join(Base.deleteat!(Base.deepcopy(requestCookieArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
            for j = 2:Base.length(requestCookieArray)
                if j === 2
                    requestCookieValue = requestCookieValue * requestCookieArray[j];  # 使用星號*拼接字符串;
                else
                    requestCookieValue = requestCookieValue * "=" * requestCookieArray[j];
                end
            end

            # try
            #     eval(:(
            #         begin
            #             Sys.eval("global " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
            #             # Sys.eval("local " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
            #             # println($ARGSIArray[1]);
            #         end
            #     ));
            # catch err
            #     println(err);
            # end

            # println(Core.String(Base64.base64decode(requestCookieValue)));
            cookie_key = Base.string(requestCookieArray[1]);  # "session_id";
            # println("Request Cookie Key: ", cookie_key);
            cookie_value = Base.string(requestCookieValue);  # "request_Key->username:password";
            # cookie_value = Base64.base64encode(requestCookieValue; context=nothing);  # "request_Key->username:password" -> "cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk"，將漢字做Base64轉碼Base64.base64encode()，需要事先加載原生的 Base64 模組：using Base64 模組;
            # println("Request Cookie Value: ", cookie_value);
            # cookie_key_value = Base.string(requestCookieArray[1]) * "=" * Base.string(requestCookieValue);  # "session_id=request_Key->username:password";
            # cookie_key_value = Base.string(requestCookieArray[1]) * "=" * Base64.base64encode(requestCookieValue; context=nothing);  # "session_id=request_Key->username:password" -> "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk"; 將漢字做Base64轉碼Base64.base64encode()，需要事先加載原生的 Base64 模組：using Base64 模組;
            # println("Request Cookie Key=Value: ", cookie_key_value);
        end
    else
        cookie_value = Cookie;  # "request_Key->username:password" -> "cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
        # cookie_key_value = Cookie;  # "request_Key->username:password" -> "cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
    end
    # println(Base.convert(Core.String, Base.strip(Base.split(Cookie, '=')[2])));  # "request_Key->username:password"，將漢字做 Base64 轉碼 Base64.base64encode("str"; context=nothing)，Base64 解碼 Base64.base64decode(base64)，需要事先加載原生的 Base64 模組：using Base64 模組;
    # println(Base.convert(Core.String, Base.strip(Base.split(Cookie, '=')[1])) * "=" * Core.String(Base64.base64decode(Base.convert(Core.String, Base.strip(Base.split(Cookie, '=')[2])))));  # "request_Key->username:password"，將漢字做 Base64 轉碼 Base64.base64encode("str"; context=nothing)，Base64 解碼 Base64.base64decode(base64)，需要事先加載原生的 Base64 模組：using Base64 模組;
    # cookie_string::Core.String = cookie_key_value * "; expires=" * Base.string(after_1_Days) * "; path=/;";  # 拼接 cookie 字符串值;  # "session_id=request_Key->username:password" -> "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";  # "session_id=request_Key->username:password; expires=2019-06-28T12:12:50.544; path=/;" -> "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk; expires=2019-06-28T12:12:50.544; path=/;";
    # println("Request Cookie String: ", cookie_string);  # "session_id=request_Key->username:password" -> "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";  # "session_id=request_Key->username:password; expires=2019-06-28T12:12:50.544; path=/;" -> "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk; expires=2019-06-28T12:12:50.544; path=/;";
    # println("Request Cookie Key: ", cookie_key_value);  # "session_id";
    # println("Request Cookie Value: ", cookie_key);  # "request_Key->username:password" -> "cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
    # println("Request Cookie Key=Value: ", cookie_key_value);  # "session_id=request_Key->username:password" -> "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";

    # 配置客戶端向服務器端發送請求的權限賬號密碼 Authorization 參數值;
    # authorization_value::Core.String = "Basic" * " " * Base64.base64encode(Authorization; context=nothing);  # 編碼 "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=" ，需要事先加載原生的 Base64 模組：using Base64 模組;
    # authorization_value::Core.String = Authorization;
    # println(Base.convert(Core.String, Base.strip(Base.split(authorization_value, ' ')[2])));
    # println(Core.String(Base64.base64decode(Base.convert(Core.String, Base.strip(Base.split(authorization_value, ' ')[2])))));  # 讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;

    # 配置客戶端向服務器端發送的請求數據;
    request_data_String::Core.String = "";
    if Base.isa(postData, Core.String)
        request_data_String = postData;  # postData::Core.Union{Core.String, Base.Dict} = "",  # postData::Core.Union{Core.String, Base.Dict{Core.Any, Core.Any}};
        # request_data_String = "{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"Client_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
    elseif Base.isa(postData, Base.Dict)
        # && Base.haskey(postData, "label")
        tempArr = Core.Array{Core.String, 1}();
        for k in Base.keys(postData)
            temp = "\"" * Base.convert(Core.String, Base.strip(Base.string(k))) * "\"" * ":" * "\"" * Base.convert(Core.String, Base.strip(Base.string(postData[k]))) * "\"";  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量，Base.strip(str) 去除字符串首尾兩端的空格;
            # println(temp);
            Base.push!(tempArr, temp);  # 使用 push! 函數在數組末尾追加推入新元素;
        end
        request_data_String = Base.join(tempArr, ",");
        request_data_String = "{" * request_data_String * "}";
        # request_data_String = "{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"Client_Authorization\":\"" * Base.string(key) * "\",\"time\":\"" * Base.string(now_date) * "\"}";  # 使用星號*拼接字符串;
        # request_data_String = JSONstring(postData);  # 使用自定義的 JSONstring() 函數，將 Julia 的字典對象轉換爲 JSON 字符串;
        # # request_data_String = JSON.json(postData);  # 使用第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
        # # Julia_Dict = JSON.parse(JSON_Str);  # 第三方擴展包「JSON」中的函數，將 JSON 字符串轉換爲 Julia 的字典對象;
        # # JSON_Str = JSON.json(Julia_Dict);  # 第三方擴展包「JSON」中的函數，將 Julia 的字典對象轉換爲 JSON 字符串;
    end
    request_data_String_len = Base.sizeof(request_data_String);

    UserAgent::Core.String = "Julia-" * Base.string(Base.VERSION) * " HTTP.request()";  # "Julia-1.9.3 HTTP.request()"，"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36";

    # Line_1::Core.String = "";
    # if requestProtocol === "HTTP"
    #     Line_1 = Base.string(requestMethod) * " " * Base.string(requestPath) * " " * Base.string(requestProtocol) * "/1.1";  # "GET / HTTP/1.1";
    # else
    #     Line_1 = Base.string(requestMethod) * " " * Base.string(requestPath) * " " * Base.string(requestProtocol);  # "GET / HTTP/1.1";
    # end

    # # 客戶端向服務器端發送的請求字符串;;
    # request_String = Base.string(
    #     Line_1 * "\r\n",  # "GET / HTTP/1.1",
    #     "Host: " * Base.string(host) * ":" * Base.string(port) * "\r\n",  # "Host: 127.0.0.1:8000",
    #     "Connection: keep-alive" * "\r\n",  # "close", # 'keep-alive' 維持客戶端和服務端的鏈接關係，當一個網頁打開完成後，客戶端和服務器之間用於傳輸 HTTP 數據的 TCP 鏈接不會關閉，如果客戶端再次訪問這個服務器上的網頁，會繼續使用這一條已經建立的鏈接;
    #     "Cookie: " * cookie_key_value * "\r\n",  # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
    #     "Authorization: " * authorization_value * "\r\n",  # "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
    #     "Accept-Charset: utf-8" * "\r\n",
    #     # "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9" * "\r\n",
    #     "Accept-Language: zh-TW,zh;q=0.9" * "\r\n",  # "zh-Hant-TW; q=0.8, zh-Hant; q=0.7, zh-Hans-CN; q=0.7, zh-Hans; q=0.5, en-US, en; q=0.3";
    #     "Content-Type:" * "text/html, text/plain; charset=utf-8" * "\r\n",  # 響應數據類型 "application/x-www-form-urlencoded; charset=utf-8";
    #     # "Cache-Control: no-cache" * "\r\n",
    #     # "Upgrade: " * "HTTP/1.0, HTTP/1.1, HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11" * "\r\n",
    #     # "Accept: " * "*/*" * "\r\n",
    #     # "Accept-Encoding: gzip, deflate, br" * "\r\n",
    #     "Content-Length: " * Base.string(request_data_String_len) * "\r\n",
    #     # "sec-ch-ua: \"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"",
    #     # "sec-ch-ua-mobile: 0",
    #     # "Upgrade-Insecure-Requests: 1",
    #     # "Purpose: prefetch",
    #     # "Sec-Fetch-Site: none",
    #     # "Sec-Fetch-Mode: navigate",
    #     # "Sec-Fetch-User: 1",
    #     # "Sec-Fetch-Dest: document",
    #     "Date: " * Base.string(now_date) * "\r\n",  # "2021/8/22 02:02:33"，服務端向客戶端返回響應的時間;
    #     "User-Agent: " * UserAgent * "\r\n",  # "Julia-1.9.3 HTTP.request()"，"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36";
    #     "From: " * requestFrom * "\r\n\r\n",  # "user@email.com",
    #     request_data_String
    # );

    request_URL::Core.String = "";  # "http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1;
    if URL !== ""
        request_URL = URL;
    else
        # Base.Unicode.lowercase(requestProtocol);  # 轉小寫字母;
        if Authorization !== ":" && Authorization !== "" && host !== "" && port !== "" && Core.Int64(port) !== Core.Int64(0) && requestPath !== ""
            if IPVersion === "IPv6"
                request_URL = Base.string(Base.Unicode.lowercase(requestProtocol)) * "://" * Authorization * "@[" * Base.string(host) * "]:" * Base.string(port) * requestPath;
            elseif IPVersion === "IPv4"
                request_URL = Base.string(Base.Unicode.lowercase(requestProtocol)) * "://" * Authorization * "@" * Base.string(host) * ":" * Base.string(port) * requestPath;
            else
            end
        elseif host !== "" && port !== "" && Core.Int64(port) !== Core.Int64(0) && requestPath !== ""
            if IPVersion === "IPv6"
                request_URL = Base.string(Base.Unicode.lowercase(requestProtocol)) * "//[" * Base.string(host) * "]:" * Base.string(port) * requestPath;
            elseif IPVersion === "IPv4"
                request_URL = Base.string(Base.Unicode.lowercase(requestProtocol)) * "://" * Base.string(host) * ":" * Base.string(port) * requestPath;
            else
            end
        end
    end
    # println(request_URL);

    # http://www.httpbin.org 網站測試 HTTP 請求和響應的各種信息，比如 cookie、ip、headers 和登陸驗證等，且支持 GET、POST 等多種請求方法;
    # Client Examples;
    # HTTP.request sends a HTTP Request Message and returns a Response Message.
    # HTTP.request 請求發送 HTTP 請求消息並返回響應消息：
    http_response = HTTP.request(
        requestMethod,  # 請求類型："GET"、"POST";
        request_URL,  # 請求網址 URL："http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index?a=1&b=2&c=3#a1"; http://username:password@127.0.0.1:8081/index?a=1&b=2&c=3#a1;
        Base.Dict{Core.String, Core.String}(
            # "Authorization" => authorization_value,  # "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
            "Cookie" => cookie_key_value,  # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
            "Referrer" => Referrer,
            "Connection" => "keep-alive",  # "close", # 'keep-alive' 維持客戶端和服務端的鏈接關係，當一個網頁打開完成後，客戶端和服務器之間用於傳輸 HTTP 數據的 TCP 鏈接不會關閉，如果客戶端再次訪問這個服務器上的網頁，會繼續使用這一條已經建立的鏈接;
            "Accept-Charset" => "utf-8",
            # "Accept" => "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
            "Accept-Language" => "zh-TW,zh;q=0.9",  # "zh-Hant-TW; q=0.8, zh-Hant; q=0.7, zh-Hans-CN; q=0.7, zh-Hans; q=0.5, en-US, en; q=0.3";
            "Content-Type" => "text/plain, text/html; charset=utf-8",  # 響應數據類型 "application/x-www-form-urlencoded; charset=utf-8";
            # "Cache-Control" => "no-cache",
            # "Upgrade" => "HTTP/1.0, HTTP/1.1, HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11",
            # "Accept" => "*/*",
            # "Accept-Encoding" => "gzip, deflate, br",
            "Content-Length" => Base.string(request_data_String_len),
            # "sec-ch-ua" => "\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"",
            # "sec-ch-ua-mobile" => "0",
            # "Upgrade-Insecure-Requests" => "1",
            # "Purpose" => "prefetch",
            # "Sec-Fetch-Site" => "none",
            # "Sec-Fetch-Mode" => "navigate",
            # "Sec-Fetch-User" => "1",
            # "Sec-Fetch-Dest" => "document",
            "Date" => Base.string(now_date),  # "2021/8/22 02:02:33"，服務端向客戶端返回響應的時間;
            "User-Agent" => UserAgent,  # "Julia-1.9.3 HTTP.request()"，"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36";
            "From" => requestFrom,  # "user@email.com",
        ),  # 發送的請求頭 []，[string(k) => string(v) for (k,v) in headers]Base.Vector{Pair}Dict()Base.Vector{Tuple}Base.Vector{Pair}copyheaders=false;
        request_data_String;  #  請求類型爲 POST 時發送的請求體（body），JSONstring(Base.Dict{Core.String, Core.String}("user"=>"RAO...tjN", "token"=>"NzU...Wnp", "message"=>"Hello!")), Base.IOBuffer(), io = open("./post_data.jpg", "r"); Base.close(io)，AbstractString、AbstractVector{UInt8}，AbstractDict、AbstractString、AbstractVector{UInt8} IO; JSON.json(Base.Dict{Core.String, Core.String}("user"=>"RAO...tjN", "token"=>"NzU...Wnp", "message"=>"Hello!")), Base.IOBuffer(), io = open("./post_data.jpg", "r"); Base.close(io)，AbstractString、AbstractVector{UInt8}，AbstractDict、AbstractString、AbstractVector{UInt8} IO;
        proxy = proxy,  # 當需要通過代理服務器僞裝發送請求時，代理服務器的網址 URL 值字符串，pass request through a proxy given as a url; alternatively, the , , , , and environment variables are also detected/used; if set, they will be used automatically when making requests.http_proxyHTTP_PROXYhttps_proxyHTTPS_PROXYno_proxy;;
        # version=v"1.1",
        # parent = Core.nothing,
        # context = HTTP.Context(),
        # cookies = Base.Dict{Core.String, Core.String}(
        #     cookie_key => cookie_value  # "Session_ID" => "request_Key->username:password";  # "session_id" => "cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
        # ),  # ::Union{Bool, Dict{<:AbstractString, <:AbstractString}} = true, 請求 Cookie 值，預設爲：cookies = false 值，enable cookies, or alternatively, pass a of name-value pairs to manually pass cookies in the request "Cookie" headerDict{AbstractString, AbstractString};
        cookiejar = cookiejar,  # ::HTTP.CookieJar = HTTP.COOKIEJAR: threadsafe cookie jar struct for keeping track of cookies per host; a global cookie jar is used by default;
        Basicbasicauth = Basicbasicauth,  # true,  # 設置從請求網址 URL 中解析截取請求的賬號和密碼，Basic authentication is detected automatically from the provided url's (in the form userinfoscheme://user:password@host) and adds the 「Authorization:」 header; this can be disabled by passing Basicbasicauth = false;
        response_stream = response_stream,  # Core.nothing,  # Base.IOBuffer(),  # 設置接收到的響應值類型爲二進制字節流 IO 對象，a writeable stream or any -like type for which is defined. The response body will be written to this stream instead of returned as a .IOIOTwrite(T, AbstractVector{UInt8})Base.Vector{UInt8};
        connect_timeout = connect_timeout,  # 服務器鏈接超時，單位：（秒），close the connection after this many seconds if it is still attempting to connect. Use to disable.connect_timeout = 0;
        readtimeout = readtimeout,  # 服務器響應數據讀取超時，單位：（秒），abort a request after this many seconds. Will trigger retries if applicable. Use to disable.readtimeout = 0;
        query = query,  # Core.nothing,  # Base.Dict{Core.String, Core.String}("ID" => "23"),  # 請求查詢 key => value 字典，a or of key => values to be included in the urlPairDict;
        # verbose = 0,  # 設置請求和響應的詳細記錄日志，set to or for increasingly verbose logging of the request and response process 12;
        # pool = Core.nothing,  # an object to use for managing the reuse of connections between requests. By default, a global pool is used, which is shared across all requests. To create a pool for a specific set of requests, use HTTP.Poolpool = HTTP.Pool(max::Int)max, where controls the maximum number of concurrent connections allowed to be used for requests at a given time.;
        status_exception = false,  # ::Core.Bool，若爲 true 值，則設置當響應狀態碼 status >= 300 時將抛出錯誤中止運行，throw for response status >= 300.HTTP.StatusError;
        # canonicalize_headers = false,  # 以規範的「key-value」形式重寫請求頭，rewrite request and response headers in Canonical-Camel-Dash-Format;
        detect_content_type = false,  # 如果和請求正文不是表單，將對其進行檢查，並將「Content-Type:」標頭設置為檢測到的內容類型，if true and the request body is not a form or IO, it will be inspected and the "Content-Type" header will be set to the detected content type;
        decompress = Core.nothing,  # 默認情況下，如果回應將「內容編碼」標頭設置為：“gzip”，則解壓縮回應正文。如果為 true，則解壓縮回應正文，而不考慮標頭。如果為 false，請不要解壓縮回應正文，by default, decompress the response body if the response has a "Content-Encoding" header set to "gzip". If decompress=true, decompress the response body regardless of header Content-Encoding. If decompress=false, do not decompress the response body;
        # observelayers = false,  # if true, enables the to wrap each client-side "layer" to track the amount of time spent in each layer as a request is processed. This can be useful for debugging performance issues. Note that when retries or redirects happen, the time spent in each layer is cumulative, as noted by the observelayer[layer]_countRequest.contextHTTP.get(...).request.context. The metrics are stored in the dictionary, and can be accessed like true HTTP;
        # retry = true,  # 設置當發生錯誤時，是否將重試發送請求，retry idempotent requests in case of error;
        # retries = 4, # 重試發送請求的次數，number of times to retry;
        # retry_non_idempotent = true,  # 設置當請求類型爲 POST 時，如果發生錯誤，是否仍然重試發送請求，retry non-idempotent requests too. e.g. POST;
        # retry_delays = ExponentialBackOff(n = retries),  # 自定義延時等待對象，每次重試請求之間的間隔延時等待時長，provide a custom object to control the delay between retries.ExponentialBackOff;
        # retry_check = (argument) -> begin argument; end,  # 提供一個自定義函數來控制是否應嘗試重試，(s, ex, req, resp, resp_body) -> Bool, provide a custom function to control whether a retry should be attempted. The function should accept 5 arguments: the delay state, exception, request, response (an object if a request was successfully made, otherwise ), and response body (which may be if there is no response yet, otherwise a ), and return if a retry should be attempted.HTTP.Responsenothingresp_bodynothingVector{UInt8}true;
        # redirect = true,  # 遵循響應狀態值爲 3xx 時重定向回應，即會對重定向位置重新發出其他請求，follow 3xx redirect responses; i.e. additional requests will be made to the redirected location;
        # redirect_limit = 3,  # 重定向的最大次數，maximum number of times a redirect will be followed;
        # redirect_method = Core.nothing,  # 用於重定向請求的方法;默認情況下，將使用 GET，只有帶有 307/308 的回應才會使用相同的原始請求方法，the method to use for the redirected request; by default, GET will be used, only responses with 307/308 will use the same original request method. Pass to pass the same method as the orginal request though note that some servers may not respond/accept the same method. It's also valid to pass the exact method to use as a string, like .redirect_method=:sameredirect_method="PUT";
        # forwardheaders = true,  # 在重定向時轉發原始標頭，forward original headers on redirect;
        # require_ssl_verification = NetworkOptions.verify_host(host),  # pass to the mbed TLS library. "... peer must present a valid certificate, handshake is aborted if verification failed."MBEDTLS_SSL_VERIFY_REQUIRED
        # sslconfig = SSLConfig(require_ssl_verification),
        # socket_type_tls = MbedTLS.SSLContext,  # the type of socket to use for TLS connections. Defaults to . Also supported is passing . To change the global default, set .MbedTLS.SSLContextsocket_type_tls = OpenSSL.SSLStreamHTTP.SOCKET_TYPE_TLS[] = OpenSSL.SSLStream
        logerrors = false,  # 設定是否保存記錄錯誤日志，if true, HTTP.StatusError, HTTP.TimeoutError, HTTP.IOError, HTTP.ConnectError and @error will be logged via as they happen, regardless of whether the request is then retried or not. Useful for debugging or monitoring requests where there's worry of certain errors happening but ignored because of retries.
        logtag = Core.nothing  # if provided, will be used as the tag for error logging. Useful for debugging or monitoring requests;
    );
    # println(http_response.request);
    # println(http_response.status);  # ::Int16 例如：401 或 200;
    # # println(http_response.headers);  # ::Base.Vector{Pair{Core.String, Core.String}} 例如：[“伺服器” => “Apache”， “內容類型” => “text/html”];
    # response_headers_Authenticate::Core.String = Base.string(HTTP.header(http_response, "Www-Authenticate"));
    # println("Www-Authenticate: " * response_headers_Authenticate);
    # response_headers_Cookie::Core.String = Base.string(HTTP.header(http_response, "Set-Cookie"));
    # println("Set-Cookie: " * response_headers_Cookie);
    # # println(Core.String(http_response.body));  # ::Base.Vector{UInt8} or ::Core.String or ::Base.IOBuffer();
    # response_body_String::Core.String = "";
    # response_body_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}();
    # response_body_String = Base.string(Core.String(http_response.body));  # ::Base.Vector{UInt8} or ::Core.String or ::Base.IOBuffer();
    # response_body_Dict = JSONparse(response_body_String);  # 自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
    # # response_body_Dict = JSON.parse(response_body_String);  # 第三方 JSON 庫中的 JSON.parse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
    # # # 通過函數 HTTP.isjson(content) 進行判斷是否爲 JSON 檢測;
    # # println(HTTP.isjson(http_response.body)[1]);
    # # if HTTP.isjson(http_response.body)[1]
    # #     # response_body_Dict = http_response.body;  # ::Base.Vector{UInt8} or ::Core.String or ::Base.IOBuffer();
    # #     response_body_String = Base.string(Core.String(http_response.body));  # ::Base.Vector{UInt8} or ::Core.String or ::Base.IOBuffer();
    # #     response_body_Dict = JSONparse(response_body_String);  # 自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
    # #     # response_body_Dict = JSON.parse(response_body_String);  # 第三方 JSON 庫中的 JSON.parse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
    # # else
    # #     response_body_String = Base.string(Core.String(http_response.body));  # ::Base.Vector{UInt8} or ::Core.String or ::Base.IOBuffer();
    # #     response_body_Dict = JSONparse(response_body_String);  # 自定義的 JSONparse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
    # #     # response_body_Dict = JSON.parse(response_body_String);  # 第三方 JSON 庫中的 JSON.parse() 函數，將 JSON 字符串轉換爲 Julia 的字典對象;
    # # end
    # println(response_body_String);
    # println(response_body_Dict);

    # 讀取服務器端返回的響應數據，獲取服務器端返回的響應頭數據;
    response_head = Base.Dict{Core.String, Core.String}();
    response_head = http_response.headers;  # ::Base.Vector{ Pair{Core.String, Core.String} } 例如：[“伺服器” => “Apache”， “內容類型” => “text/html”];

    # 讀取服務器端返回的響應數據，獲取服務器端返回的響應體數據;
    response_body::Core.String = "";  # Core.Array{Core.Any, 1}();
    response_body = Base.string(Core.String(http_response.body));  # ::Base.Vector{Core.UInt8} or ::Core.String or ::Base.IOBuffer();

    # 解析響應頭中的 "set-Cookie" 參數值，用以獲取服務器端發送的響應賬號和密碼進行權限驗證;
    response_Cookie::Core.String = "";  # Base.string(HTTP.header(http_response, "Set-Cookie"));  # 解析獲取客戶端請求頭中的 "set-Cookie" 參數;
    response_Cookie_name::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數;
    response_Cookie_value::Core.String = "";  # 解析獲取客戶端請求頭中的 "cookie" 參數;
    # Base.haskey(::Dict, "key") -> Bool 判斷字典中某個關鍵字（key）是否存在？
    # Base.isa("aaa", Core.String) -> Bool 判斷變量類型是否爲字符串？
    # HTTP.hasheader(::Message, "key") -> Bool 判斷請求標頭的某個關鍵字（key）是否存在（不區分大小寫），Does header value for key exist (case-insensitive)？
    # println(HTTP.hasheader(http_response, "Set-Cookie"));
    if HTTP.hasheader(http_response, "Set-Cookie")
        response_Cookie = Base.string(HTTP.header(http_response, "Set-Cookie"));  # 解析獲取客戶端請求頭中的 "set-Cookie" 參數;
        # response_Cookie = Core.String(Base64.base64decode(Base.string(HTTP.header(http_response, "Set-Cookie"))));  # 讀取客戶端發送的請求頭中的 Set-Cookie 參數值，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
        # response_head["Set-Cookie"] = Base64.base64encode(response_Cookie; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
    end
    # println(Base.typeof(response_Cookie));
    # println("response Header Set-Cookie: [ " * response_Cookie * " ].");

    # 判斷服務器發送的響應頭中 Set-Cookie 參數值中是否包含";"分隔符號，是否包含"="符號，如果包含"="符號，則首先使用"="符號分割 Set-Cookie 參數值字符串，否則直接使用 Set-Cookie 參數值字符串;
    cookieArray = Core.Array{Core.Any, 1}();  # 使用";"分隔符號分割 Cookie 多組值中的每一組值，依次保存到數組中，聲明一個任意類型的空 1 維數組;
    if Base.isa(response_Cookie, Core.String) && Base.string(response_Cookie) !== ""
        # Base.length(response_Cookie) > 0
        if Base.occursin(";", response_Cookie)
            # cookieArray = Core.Array{Core.Any, 1}();  # 聲明一個任意類型的空 1 維數組;
            # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
            # 函數 Base.split(response_Cookie, ';') 表示用等號字符';'分割字符串為數組;
            for x in Base.split(response_Cookie, ';')
                temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                Base.push!(cookieArray, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
            end
        else
            Base.push!(cookieArray, Base.string(response_Cookie));  # Base.convert(Core.String, response_Cookie) 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量，使用 Base.push! 函數在數組末尾追加推入新元素;
        end
    end
    # println(cookieArray);
    if Base.length(cookieArray) > 0
        # cookieArray = Base.join(Base.deleteat!(Base.deepcopy(cookieArray), 1), ";");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
        for j = 1:Base.length(cookieArray)
            if Base.isa(cookieArray[j], Core.String) && Base.occursin("=", cookieArray[j])

                cookie_session_id_Array = Core.Array{Core.Any, 1}();  # 指定從 Cookie 多組值中提取 session_id 的值，聲明一個任意類型的空 1 維數組;
                # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
                # 函數 Base.split(cookieArray[j], '=') 表示用等號字符'='分割字符串為數組;
                for x in Base.split(cookieArray[j], '=')
                    temp = Base.strip(x);  # Base.strip(str) 去除字符串首尾兩端的空格;
                    temp = Base.convert(Core.String, temp);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
                    Base.push!(cookie_session_id_Array, temp);  # 使用 Base.push! 函數在數組末尾追加推入新元素;
                end

                # Base.convert(Core.String, cookie_session_id_Array[1]);  # "Session_ID=request_Key->username:password";
                if Base.length(cookie_session_id_Array) > 0 && Base.isa(cookie_session_id_Array[1], Core.String) && Base.string(cookie_session_id_Array[1]) === "session_id"
                    # cookie_session_id_Value = Base.join(Base.deleteat!(Base.deepcopy(cookie_session_id_Array), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                    # println("request Headers Cookie: ", cookie_session_id_Array[1] * "=" * Core.String(Base64.base64decode(Base.join(Base.deleteat!(Base.deepcopy(cookie_session_id_Array), 1), "="))));  # 打印請求頭中的使用函數 Base64.base64decode() 解密之後的用戶 "Cookie"，# 需要事先加載原生的 Base64 模組：using Base64 模組;;
                    # request_Cookie_name = Base.convert(Core.String, cookie_session_id_Array[1]);  # "Session_ID=request_Key->username:password";
                    # request_Cookie_value = Core.String(Base64.base64decode(cookie_session_id_Value));  # "Session_ID=request_Key->username:password"，讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                    # request_head["cookie"] = request_Cookie_name * "=" * Base64.base64encode(request_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
                    # "Session_ID=request_Key->username:password" -> "session_id=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
                    if Base.length(cookie_session_id_Array) > 1
        
                        cookie_session_id_Value = "";
                        # cookie_session_id_Array = Base.join(Base.deleteat!(Base.deepcopy(cookie_session_id_Array), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
                        for j = 2:Base.length(cookie_session_id_Array)
                            if j === 2
                                cookie_session_id_Value = cookie_session_id_Value * cookie_session_id_Array[j];  # 使用星號*拼接字符串;
                            else
                                cookie_session_id_Value = cookie_session_id_Value * "=" * cookie_session_id_Array[j];
                            end
                        end
        
                        # try
                        #     eval(:(
                        #         begin
                        #             Sys.eval("global " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # Sys.eval("local " * ARGSIArray[1] * " = " * ARGSValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
                        #             # println($ARGSIArray[1]);
                        #         end
                        #     ));
                        # catch err
                        #     println(err);
                        # end
        
                        # println("response Headers Set-Cookie: ", cookie_session_id_Array[1] * "=" * Core.String(Base64.base64decode(cookie_session_id_Value)));  # 打印請求頭中的使用函數 Base64.base64decode() 解密之後的用戶 "Set-Cookie"，# 需要事先加載原生的 Base64 模組：using Base64 模組;;
                        response_Cookie_name = Base.convert(Core.String, Base.strip(cookie_session_id_Array[1]))
                        response_Cookie_value = Core.String(Base64.base64decode(cookie_session_id_Value));  # 讀取客戶端發送的請求驗證賬號和密碼，並是使用 str(<object byets>, encoding="utf-8") 將字節流數據轉換爲字符串類型，需要事先加載原生的 Base64 模組：using Base64 模組;
                        # Cookie = response_Cookie_name * "=" * Base64.base64encode(response_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
                        # println("response Set-Cookie " * response_Cookie_name * ": ", response_Cookie_value);
                    end

                    break;
                end
            end
        end
    end
    # println("[ " * response_Cookie_name * " ] : " * "[ " * response_Cookie_value * " ].");
    # println("Request Cookie: [ " * Cookie * " ].");

    # 解析響應頭中的 "Www-Authenticate" 參數值，用以獲取服務器端發送的響應賬號和密碼進行權限驗證;
    response_Authorization::Core.String = "";  # Base.string(HTTP.header(http_response, "Www-Authenticate"));  # 解析獲取服務器響應頭中的賬號密碼 "Www-Authenticate" 參數;
    # println(HTTP.hasheader(http_response, "Www-Authenticate"));
    if HTTP.hasheader(http_response, "Www-Authenticate")
        response_Authorization = Base.string(HTTP.header(http_response, "Www-Authenticate"));  # 解析獲取服務器響應頭中的賬號密碼 "Www-Authenticate" 參數;
    end
    # println(Base.typeof(response_Authorization));
    # println(response_Authorization);

    response_Referrer::Core.String = "";  # Base.string(HTTP.header(http_response, "Referrer"));  # 請求的來源網頁 URL 網址 "http://username:password@127.0.0.1:8081/index?a=1&b=2&c=3#a1";
    # println(HTTP.hasheader(http_response, "Referrer"));
    if HTTP.hasheader(http_response, "Referrer")
        response_Referrer = Base.string(HTTP.header(http_response, "Referrer"));  # 解析獲取客戶端請求頭中的 "Referrer" 參數;
    end
    # println(response_Referrer);

    response_ContentType::Core.String = "";  # Base.string(HTTP.header(http_response, "Content-Type"));  # 響應數據類型 "text/plain, text/html; charset=utf-8";
    # println(HTTP.hasheader(http_response, "Content-Type"));
    if HTTP.hasheader(http_response, "Content-Type")
        response_ContentType = Base.string(HTTP.header(http_response, "Content-Type"));  # 解析獲取客戶端請求頭中的 "Content-Type" 參數;
    end
    # println(response_ContentType);

    response_ContentLength::Core.String = "";  # Base.string(HTTP.header(http_response, "Content-Length"));  # 響應數據大小 "text/plain, text/html; charset=utf-8";
    # println(HTTP.hasheader(http_response, "Content-Length"));
    if HTTP.hasheader(http_response, "Content-Length")
        response_ContentLength = Base.string(HTTP.header(http_response, "Content-Length"));  # 解析獲取客戶端請求頭中的 "Content-Length" 參數;
    end
    # println(response_ContentLength);

    request_Key::Core.String = "";  # 判斷如果服務器端發送的響應的賬號密碼來源，如果響應頭 response.headers["set-Cookie"] 參數不爲空則使用 response.headers["set-Cookie"] 的參數值作爲服務器端的賬號密碼，如果響應頭 response.headers["set-Cookie"] 參數為空但 response.headers["Www-Authenticate"] 參數不爲空則使用 response.headers["Www-Authenticate"] 的參數值，作爲解析服務器端返回的響應值中賬號密碼的來源;
    request_Nikename::Core.String = "";  # 提取賬號密碼;
    request_Password::Core.String = "";  # 提取賬號密碼;
    # 判斷如果服務器端發送的響應的賬號密碼來源，如果響應頭 response.headers["Cookie"] 參數不爲空則使用 response.headers["Cookie"] 的參數值作爲服務器端的賬號密碼，如果響應頭 response.headers["Cookie"] 參數為空但 response.headers["Authorization"] 參數不爲空則使用 response.headers["Authorization"] 的參數值，作爲解析服務器端返回的響應值中賬號密碼的來源;
    # request_Key::Core.String = "";
    if response_Cookie !== "" && response_Cookie_value !== ""
        if Base.occursin("->", response_Cookie_value)
            request_Key = Base.convert(Core.String, Base.strip(Base.split(response_Cookie_value, "->")[2]));
        end
    elseif response_Authorization !== ""
        if Base.occursin("->", response_Authorization)
            request_Key = Base.convert(Core.String, Base.strip(Base.split(response_Authorization, "->")[2]));
        end
    end
    # println("response Key: [ " * request_Key * " ].");

    # 提取賬號密碼;
    # request_Nikename::Core.String = "";
    # request_Password::Core.String = "";
    if request_Key !== "" && Base.occursin(":", request_Key)

        KeyArray = Core.Array{Core.Any, 1}();  # 聲明一個聯合類型的空1維數組;
        # ARGSIArray = Core.Array{Core.Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}();  # 聲明一個聯合類型的空1維數組;
        # 函數 Base.split(request_Key, ':') 表示用等號字符'='分割字符串為數組;
        for x in Base.split(request_Key, ':')
            x = Base.convert(Core.String, x);  # 使用 Base.convert() 函數將子字符串(SubString)型轉換為字符串(String)型變量;
            Base.push!(KeyArray, Base.strip(x));  # 使用 Base.push! 函數在數組末尾追加推入新元素，Base.strip(str) 去除字符串首尾兩端的空格;
        end

        if Core.Int64(Base.length(KeyArray)) === Core.Int64(1)
            request_Nikename = KeyArray[1];
        end

        if Base.length(KeyArray) > 1

            KeyValue = "";
            # KeyValue = Base.join(Base.deleteat!(Base.deepcopy(KeyArray), 1), "=");  # 使用 Base.deepcopy() 標注數組深拷貝傳值複製，這樣在使用 Base.deleteat!(ARGSIArray, 1) 函數刪除第一個元素時候就不會改變原數組 ARGSIArray，否則為淺拷貝傳址複製，使用 deleteat!(ARGSIArray, 1) 刪除第一個元素的時候會影響原數組 ARGSIArray 的值，然後將數組從第二個元素起直至末尾拼接為一個字符串;
            for j = 2:Base.length(KeyArray)
                if j === 2
                    KeyValue = KeyValue * KeyArray[j];  # 使用星號*拼接字符串;
                else
                    KeyValue = KeyValue * ":" * KeyArray[j];
                end
            end

            # try
            #     eval(:(
            #         begin
            #             Sys.eval("global " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
            #             # Sys.eval("local " * KeyArray[1] * " = " * KeyValue);  # 使用 eval(:()) 函數執行字符串代碼語句;
            #             # println($KeyArray[1]);
            #         end
            #     ));
            # catch err
            #     println(err);
            # end

            request_Nikename = KeyArray[1];
            request_Password = KeyValue;
            # println("response Nikename: [ " * KeyArray[1] * " ], response Password: [ " * KeyValue * " ].");
        end
    else
        request_Nikename = request_Key;
        # request_Password = "";
    end
    # println("response Nikename: [ " * request_Nikename * " ], response Password: [ " * request_Password * " ].");

    if Base.string(http_response.status) === "401"

        # Cookie = response_Cookie_name * "=" * Base64.base64encode(response_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
        # Authorization = request_Key;

        Cookie_2::Core.String = "";  # 拼接從服務器返回的 Cookie 參數;
        if response_Cookie_name === ""
            Cookie_2 = Base64.base64encode(response_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
        else
            Cookie_2 = response_Cookie_name * "=" * Base64.base64encode(response_Cookie_value; context=nothing);  # 編碼，需要事先加載原生的 Base64 模組：using Base64 模組;
        end
        # println(Cookie_2);

        Base.write(Base.stdout, "服務器返回響應狀態碼「 status = 401 」要求身份驗證.\n");
        Base.write(Base.stdout, "「 nikename:password 」 ->  ");
        request_Key_line_String = Base.readline(Base.stdin, keep=false);
        # request_Key_line_String = Base.strip(request_Key_line_String);  # 使用 Base.strip(str) 去除字符串首尾兩端的空格;
        # request_Key_line_String = Base.convert(Core.String, request_Key_line_String);  # 使用 Base.convert(Core.String,str) 將變量解析為字符串類型;
        # println(request_Key_line_String);

        result = http_Client(
            host,  # ::Core.String,  # "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
            port;  # ::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String};  # 0 ~ 65535，監聽埠號（端口）;
            IPVersion = IPVersion,  # "IPv6"、"IPv4";
            postData = postData,  # ::Core.Union{Core.String, Base.Dict} = "",  # Base.Dict{Core.String, Core.Any}("Client_say" => "Julia-1.6.2 Sockets.connect."),  # postData::Core.Union{Core.String, Base.Dict{Core.Any, Core.Any}}，"{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"time\":\"" * Base.string(now_date) * "\"}";
            proxy = proxy,  # ::Core.String = Core.nothing,  # 當需要通過代理服務器僞裝發送請求時，代理服務器的網址 URL 值字符串，pass request through a proxy given as a url; alternatively, the , , , , and environment variables are also detected/used; if set, they will be used automatically when making requests.http_proxyHTTP_PROXYhttps_proxyHTTPS_PROXYno_proxy;
            requestPath = requestPath,  # ::Core.String = "/",
            requestProtocol = requestProtocol,  # ::Core.String = "HTTP",
            query = query,  # ::Base.Dict{Core.String, Core.String} = Core.nothing,  # Base.Dict{Core.String, Core.String}(),  # Base.Dict{Core.String, Core.String}("ID" => "23"),  # 請求查詢 key => value 字典，a or of key => values to be included in the urlPairDict;
            URL = URL,  # ::Core.String = "",  # Base.string(http_Client.requestProtocol) * "://" * Base.convert(Core.String, Base.strip((Base.split(Base.string(http_Client.Authorization), ' ')[2]))) * "@" * Base.string(http_Client.host) * ":" * Base.string(http_Client.port) * Base.string(http_Client.requestPath),  # 請求網址 URL "http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1;
            requestMethod = requestMethod,  # ::Core.String = "GET",  # "POST",  # "GET"; # 請求方法;
            # time_out = time_out,  # ::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
            readtimeout = readtimeout,  # ::Core.Int = Core.Int(0),  # 服務器響應數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
            connect_timeout = connect_timeout,  # ::Core.Int = Core.Int(30),  # 服務器鏈接超時，單位：（秒），close the connection after this many seconds if it is still attempting to connect. Use to disable.connect_timeout = 0;
            Authorization = request_Key_line_String,  # ::Core.String = ":",  # "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
            Basicbasicauth = Basicbasicauth,  # ::Core.Bool = true,  # 設置從請求網址 URL 中解析截取請求的賬號和密碼，Basic authentication is detected automatically from the provided url's (in the form userinfoscheme://user:password@host) and adds the 「Authorization:」 header; this can be disabled by passing Basicbasicauth = false;
            Cookie = Cookie_2,  # ::Core.String = "",  # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
            Referrer = Referrer,  # ::Core.String = http_Client.URL,  # 請求的來源網頁 URL "http://username:password@127.0.0.1:8081/index?a=1&b=2&c=3#a1";
            requestFrom = requestFrom,  # ::Core.String = "user@email.com",
            # do_Function = do_Function,  # (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Response";
            # session = session,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => http_Server.key),  # 保存網站的 Session 數據;
            # number_Worker_threads = number_Worker_threads,  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.UInt8(0),  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
            # time_sleep = time_sleep,  # ::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
            # isConcurrencyHierarchy = isConcurrencyHierarchy,  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
            # worker_queues_Dict = worker_queues_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
            # total_worker_called_number = total_worker_called_number,  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}(),  # 記錄每個綫程纍加的被調用運算的總次數;
            response_stream = response_stream,  # Core.nothing,  # Base.IOBuffer(),  # 設置接收到的響應值類型爲二進制字節流 IO 對象，a writeable stream or any -like type for which is defined. The response body will be written to this stream instead of returned as a .IOIOTwrite(T, AbstractVector{UInt8})Base.Vector{UInt8};
            cookiejar = cookiejar  # ::HTTP.CookieJar = HTTP.CookieJar()  # Cookie Persistence; # HTTP.Cookies.setcookies!(mycookiejar, http_response.message.url, http_response.message.headers);  # HTTP.Cookies.setcookies!(jar::CookieJar, url::URI, headers::Headers);  # HTTP.Cookies.getcookies!(mycookiejar, http_response.message.url);  # HTTP.Cookies.getcookies!(jar::CookieJar, url::URI);
        );

        return result;
    end

    if Base.string(http_response.status) === "200"

        # Base.close(client);

        return ["success", Base.string(http_response.status), response_body];

        # # 無并發，就在當前主進程（Master）中，處理輸入任務隊列;
        # if Core.Int8(number_Worker_threads) <= Core.Int8(0)

        #     # 記錄每個協程（Task）纍加的被調用運算的總次數;
        #     # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        #     # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
        #     if Base.haskey(total_worker_called_number, Base.string(Base.Threads.threadid()))
        #         # global total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid())]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
        #         total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(total_worker_called_number[Base.string(Base.Threads.threadid())]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
        #     else
        #         # global total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
        #         total_worker_called_number[Base.string(Base.Threads.threadid())] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
        #     end

        #     result = "";
        #     try
        #         result = do_Function(response_body);
        #         # Base.write(Base.stdout, response_body_String);
        #     catch err

        #         # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
        #         if Core.isa(err, Core.InterruptException)

        #             print("\n");
        #             # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
        #             # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
        #             println("[ Ctrl ] + [ c ] received, will be stop the TCP Client.");

        #             # # 打印進程被調用數目;
        #             # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

        #             #     if isConcurrencyHierarchy === "Multi-Processes"

        #             #         # Base.haskey(collection, key) -> Bool
        #             #         # workNum = "worker";
        #             #         for k in Base.keys(total_worker_called_number)
        #             #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
        #             #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
        #             #         end
        #             #         # println(workNum);

        #             #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

        #             #         # Base.haskey(collection, key) -> Bool
        #             #         # workNum = "worker";
        #             #         for k in Base.keys(total_worker_called_number)
        #             #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
        #             #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
        #             #         end
        #             #         # println(workNum);

        #             #     end

        #             #     total_worker_called_number = Core.nothing;
        #             # end

        #             # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
        #             # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

        #             #     # Base.haskey(collection, key) -> Bool
        #             #     # for k in Base.keys(worker_queues_Dict)
        #             #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
        #             #     # end

        #             #     worker_queues_Dict = Core.nothing;
        #             # end

        #             println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        #             println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

        #             # Base.exit(0);
        #             return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, stop the TCP Client."];

        #         else

        #             # Base.write(stderr, err);
        #             # Base.write(Base.stdout, err, "\n");
        #             println("自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
        #             println(err);
        #             # println(err.msg);
        #             # println(Base.typeof(err));
        #             # Base.close(client);  # 中斷當前的這個鏈接;
        #             # Base.sleep(time_sleep);
        #             return ["error", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), Base.string(err)];
        #         end
        #     end
        #     return ["success", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), result];
        #     # println(result);
        # end

        # # 開啓并發，在子進程（Worker）中，處理輸入任務隊列;
        # if Core.Int8(number_Worker_threads) > Core.Int8(0)

        #     if isConcurrencyHierarchy === "Tasks"
        #         result = "";
        #         try
        #             # 創建一個子協程（worker task）;
        #             f() = do_Function(response_body);
        #             workerTask = Core.Task(f);  # 創建一個協程（任務）task;
        #             workerTask.sticky = false;

        #             Base.schedule(workerTask);  # 用 Base.schedule(t::Task, [val]; error=false) 函數把未啓動的協程(Task)加入等待執行的隊列並啓動，隨後會自動返回 done 狀態，表示已經執行完畢;
        #             # Base.wait(workerTask);  # 阻塞主進程後面的代碼執行，直到該子協程 workerTask 運行完畢;
        #             # 用 istaskstarted(taskname) 和 istaskdone(taskname) 查看 Task 是否已經啓動和結束。Task 有五個狀態：runnable（可被啓動）, waiting（阻塞等待中）, queued（正被調度中）, done（執行結束）, failed（執行異常結束）。Julia 内部有一個調度器，負責維護 task 運行隊列;

        #             # 讀出子協程(task)返回的結果;
        #             result = Base.fetch(workerTask);

        #             # 記錄每個協程（Task）纍加的被調用運算的總次數;
        #             # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        #             # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
        #             if Base.haskey(total_worker_called_number, Base.string(workerTask[1]))
        #                 # global total_worker_called_number[Base.string(workerTask[1])] = Core.UInt64(total_worker_called_number[Base.string(workerTask[1])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
        #                 total_worker_called_number[Base.string(workerTask[1])] = Core.UInt64(total_worker_called_number[Base.string(workerTask[1])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
        #             else
        #                 # global total_worker_called_number[Base.string(workerTask[1])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
        #                 total_worker_called_number[Base.string(workerTask[1])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
        #             end
        #             # if Base.haskey(total_worker_called_number, Base.string(result_Dict["taskID"]))
        #             #     # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
        #             #     total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(total_worker_called_number[Base.string(result_Dict["taskID"])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
        #             # else
        #             #     # global total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
        #             #     total_worker_called_number[Base.string(result_Dict["taskID"])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
        #             # end

        #         catch err

        #             # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
        #             if Core.isa(err, Core.InterruptException)

        #                 print("\n");
        #                 # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
        #                 # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
        #                 println("[ Ctrl ] + [ c ] received, will be stop the TCP Client.");

        #                 # # 打印進程被調用數目;
        #                 # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

        #                 #     if isConcurrencyHierarchy === "Multi-Processes"

        #                 #         # Base.haskey(collection, key) -> Bool
        #                 #         # workNum = "worker";
        #                 #         for k in Base.keys(total_worker_called_number)
        #                 #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
        #                 #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
        #                 #         end
        #                 #         # println(workNum);

        #                 #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

        #                 #         # Base.haskey(collection, key) -> Bool
        #                 #         # workNum = "worker";
        #                 #         for k in Base.keys(total_worker_called_number)
        #                 #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
        #                 #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
        #                 #         end
        #                 #         # println(workNum);

        #                 #     end

        #                 #     total_worker_called_number = Core.nothing;
        #                 # end

        #                 # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
        #                 # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

        #                 #     # Base.haskey(collection, key) -> Bool
        #                 #     # for k in Base.keys(worker_queues_Dict)
        #                 #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
        #                 #     # end

        #                 #     worker_queues_Dict = Core.nothing;
        #                 # end

        #                 println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        #                 println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

        #                 # Base.exit(0);
        #                 return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, stop the TCP Client."];

        #             else

        #                 # Base.write(stderr, err);
        #                 # Base.write(Base.stdout, err, "\n");
        #                 println("多協程並發（multi-task）時，工作協程（worker-task）中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
        #                 println(err);
        #                 # println(err.msg);
        #                 # println(Base.typeof(err));
        #                 # Base.close(client);  # 中斷當前的這個鏈接;
        #                 # Base.sleep(time_sleep);
        #                 return ["error", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), Base.string(err)];
        #             end
        #         end
        #         return ["success", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), result];
        #         # println(result);
        #     end

        #     # 需要注意，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
        #     if isConcurrencyHierarchy === "Multi-Threading"
        #         result = "";
        #         try
        #             # 創建一個子綫程（worker thread）;
        #             # 需要注意，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
        #             # workerThread = Base.Threads.@spawn begin
        #             #     do_Function(response_body);
        #             # end
        #             workerThread = Base.Threads.@spawn do_Function(response_body);;
        #             # r = Base.fetch(workerThread);  # 等待讀取子綫程運行完畢後的返回值，阻塞後面的代碼執行;
        #             # Base.wait(workerThread);  # 阻塞主進程後面的代碼執行，直到該子綫程 workerThread 運行完畢;

        #             # 讀出子協程(task)返回的結果;
        #             result = Base.fetch(workerThread);

        #             # 記錄每個協程（Task）纍加的被調用運算的總次數;
        #             # 使用 Base.objectid(Base.current_task()) 或 Base.Threads.threadid() 或 Distributed.myid() 方法返回當前協程(task)\綫程(thread)\進程(process) ID 號，注意，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        #             # 使用 Base.haskey(collection, key) 方法確定字典中是否有給定映射 key;
        #             if Base.haskey(total_worker_called_number, Base.string(workerThread[1]))
        #                 # global total_worker_called_number[Base.string(workerThread[1])] = Core.UInt64(total_worker_called_number[Base.string(workerThread[1])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
        #                 total_worker_called_number[Base.string(workerThread[1])] = Core.UInt64(total_worker_called_number[Base.string(workerThread[1])]) + Core.UInt64(1);  # 每被調用一次，就在相應子協程（Task）號下加 1 ;
        #             else
        #                 # global total_worker_called_number[Base.string(workerThread[1])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
        #                 total_worker_called_number[Base.string(workerThread[1])] = Core.UInt64(1);  # 第一次被調用賦值 1 ;
        #             end

        #         catch err

        #             # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
        #             if Core.isa(err, Core.InterruptException)

        #                 print("\n");
        #                 # println("接收到鍵盤 [ Ctrl ] + [ c ] 信號 (sigint)「" * Base.string(err) * "」進程被終止.");
        #                 # Core.InterruptException 表示用戶中斷執行，通常是輸入：[ Ctrl ] + [ c ];
        #                 println("[ Ctrl ] + [ c ] received, will be stop the TCP Client.");

        #                 # # 打印進程被調用數目;
        #                 # if Base.@isdefined(total_worker_called_number) && Base.typeof(total_worker_called_number) <: Base.Dict && Base.length(total_worker_called_number) > 0

        #                 #     if isConcurrencyHierarchy === "Multi-Processes"

        #                 #         # Base.haskey(collection, key) -> Bool
        #                 #         # workNum = "worker";
        #                 #         for k in Base.keys(total_worker_called_number)
        #                 #             println("worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
        #                 #             # global workNum = workNum * " worker process-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
        #                 #         end
        #                 #         # println(workNum);

        #                 #     elseif isConcurrencyHierarchy === "Multi-Threading" || isConcurrencyHierarchy === "Tasks"

        #                 #         # Base.haskey(collection, key) -> Bool
        #                 #         # workNum = "worker";
        #                 #         for k in Base.keys(total_worker_called_number)
        #                 #             println("worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]");
        #                 #             # global workNum = workNum * " worker thread-" * Base.string(k) * " [ " * Base.string(total_worker_called_number[k]) * " ]";
        #                 #         end
        #                 #         # println(workNum);

        #                 #     end

        #                 #     total_worker_called_number = Core.nothing;
        #                 # end

        #                 # # 清空用於保存創建的子進程的字典變量 worker_queues_Dict;
        #                 # if Base.@isdefined(worker_queues_Dict) && Base.typeof(worker_queues_Dict) <: Base.Dict && Base.length(worker_queues_Dict) > 0

        #                 #     # Base.haskey(collection, key) -> Bool
        #                 #     # for k in Base.keys(worker_queues_Dict)
        #                 #     #     println("process/thread/task-" * Base.string(k), worker_queues_Dict[k]);
        #                 #     # end

        #                 #     worker_queues_Dict = Core.nothing;
        #                 # end

        #                 println("主進程: process-" * Base.string(Distributed.myid()) * " , 主執行緒（綫程）: thread-" * Base.string(Base.Threads.threadid()) * " , 調度任務（協程）: task-" * Base.string(Base.objectid(Base.current_task())) * " 正在關閉 ...");  # 當使用 Distributed.myid() 時，需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        #                 println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;

        #                 # Base.exit(0);
        #                 return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, stop the TCP Client."];

        #             else

        #                 # Base.write(stderr, err);
        #                 # Base.write(Base.stdout, err, "\n");
        #                 println("多綫程並發（multi-task）時，工作綫程（worker-thread）中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
        #                 println(err);
        #                 # println(err.msg);
        #                 # println(Base.typeof(err));
        #                 # Base.close(client);  # 中斷當前的這個鏈接;
        #                 # Base.sleep(time_sleep);
        #                 return ["error", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), Base.string(err)];
        #             end
        #         end
        #         return ["success", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), result];
        #         # println(result);
        #     end

        #     # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        #     if isConcurrencyHierarchy === "Multi-Processes"

        #         # try
        #         #     # Base.Threads.@spawn
        #         #     # Create and run a Task on any available thread. To wait for the task to finish, call wait on the result of this macro, or call fetch to wait and then obtain its return value.
        #         #     # Values can be interpolated into @spawn via $, which copies the value directly into the constructed underlying closure. This allows you to insert the value of a variable, isolating the asynchronous code from changes to the variable's value in the current task.
        #         #     # 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        #         #     wp = Base.Threads.@spawn funcTask(
        #         #         # worker_data_Dict,
        #         #         do_Function,
        #         #         main_to_sub_channel,
        #         #         sub_to_main_channel,
        #         #         control_number_Queues_channel
        #         #     );
        #         #     # r = Base.fetch(wp);
        #         # catch err

        #         #     # 使用 Core.isa(err, Core.InterruptException) 函數判斷 err 的類型是否爲 Core.InterruptException，如果為 Core.InterruptException 則表示接收到了鍵盤輸入的 [Ctrl] + [c] 信號，則中止 while true ... end 循環，退出函數;
        #         #     if Core.isa(err, Core.InterruptException)
        #         #         println("Main process-" * Base.string(Distributed.myid()) * " Main thread-" * Base.string(Base.Threads.threadid()) * " Dispatch task-" * Base.string(Base.objectid(Base.current_task())) * " being exit ...");  # Distributed.myid() 需要事先加載原生的支持多進程標準模組 using Distributed 模組;
        #         #         # Base.exit(0);
        #         #         return ["error", "[ Ctrl ] + [ c ]", "[ Ctrl ] + [ c ] received, stop the TCP Client."];
        #         #     else

        #         #         # Base.write(stderr, err);
        #         #         # Base.write(Base.stdout, err, "\n");
        #         #         println("多進程並發（multi-task）時，工作進程（worker-process）中，自定義具體執行處理數據功能的函數「 do_Function() 」運行錯誤.");
        #         #         println(err);
        #         #         # println(err.msg);
        #         #         # println(Base.typeof(err));
        #         #         # Base.close(client);  # 中斷當前的這個鏈接;
        #         #         # Base.sleep(time_sleep);
        #         #         return ["error", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), Base.string(err)];
        #         #     end
        #         # end
        #         # return ["success", "do_Function ∈ " * Base.string(Core.typeof(do_Function)), result];
        #         # # println(result);
        #     end
        # end
    end
end


# # 使用 Julia 語言的第三方擴展包「HTTP」製作的，媒介服務器函數客戶端（前端） http_Client() 使用説明;
# # using HTTP;  # 導入第三方擴展包「HTTP」，用於創建 HTTP server 服務器，需要在控制臺先安裝第三方擴展包「HTTP」：julia> using Pkg; Pkg.add("HTTP") 成功之後才能使用;
# # using JSON;  # 導入第三方擴展包「JSON」，用於轉換JSON字符串為字典 Base.Dict 對象，需要在控制臺先安裝第三方擴展包「JSON」：julia> using Pkg; Pkg.add("JSON") 成功之後才能使用;
# webPath = Base.string(Base.Filesystem.abspath("."));  # 服務器運行的本地硬盤根目錄，可以使用函數：上一層路徑下的temp路徑 Base.Filesystem.joinpath(Base.Filesystem.abspath(".."), "Intermediary")，當前目錄：Base.Filesystem.abspath(".") 或 Base.Filesystem.pwd()，當前路徑 Base.@__DIR__;
# host = Sockets.IPv6("::1"); # ::Core.String = "127.0.0.1", # "0.0.0.0" or "localhost"; 監聽主機域名 Host domain name;
# IPVersion = "IPv6";  # "IPv6"、"IPv4";
# port = Core.UInt64(10001);  # ::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String} = Core.UInt8(8000),  # 0 ~ 65535， 監聽埠號（端口）;
# proxy = Core.nothing;  # ::Core.String = Core.nothing,  # 當需要通過代理服務器僞裝發送請求時，代理服務器的網址 URL 值字符串，pass request through a proxy given as a url; alternatively, the , , , , and environment variables are also detected/used; if set, they will be used automatically when making requests.http_proxyHTTP_PROXYhttps_proxyHTTPS_PROXYno_proxy;
# URL = "";  # "http://username:password@[fe80::e458:959e:cf12:695%25]:10001/index.html?a=1&b=2&c=3#a1";  # http://username:password@127.0.0.1:8081/index.html?a=1&b=2&c=3#a1
# requestPath = "/";
# requestMethod = "POST";  # "POST",  # "GET"; # 請求方法;
# requestProtocol = "HTTP";  # Base.Unicode.lowercase(requestProtocol);  # 轉小寫字母;
# Referrer = URL;  # ::Core.String = http_Client.URL,  # 請求的來源網頁 URL "http://username:password@127.0.0.1:8081/index?a=1&b=2&c=3#a1";
# # time_out = Core.Float16(0);  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
# Authorization = "username:password";  # 自定義的訪問網站簡單驗證用戶名和密碼 "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
# Basicbasicauth = true;  # ::Core.Bool = true,  # 設置從請求網址 URL 中解析截取請求的賬號和密碼，Basic authentication is detected automatically from the provided url's (in the form userinfoscheme://user:password@host) and adds the 「Authorization:」 header; this can be disabled by passing Basicbasicauth = false;
# Cookie_name = "session_id";
# Cookie_value = "request_Key->username:password";
# # Cookie = Cookie_name * "=" * Cookie_value;  # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
# Cookie = Cookie_name * "=" * Base64.base64encode(Cookie_value; context=nothing);  # "Session_ID=request_Key->username:password"，將漢字做Base64轉碼Base64.base64encode()，需要事先加載原生的 Base64 模組：using Base64 模組;
# # println(Core.String(Base64.base64decode(Cookie_value)));
# # println("Request Cook: ", Cookie);
# query = Base.Dict{Core.String, Core.String}();  # ::Base.Dict{Core.String, Core.String} = Core.nothing,  # Base.Dict{Core.String, Core.String}(),  # Base.Dict{Core.String, Core.String}("ID" => "23", "IP" => "24"),  # 請求查詢 key => value 字典，a or of key => values to be included in the urlPairDict;
# requestFrom = "user@email.com";
# # do_Function = do_Response;  # (argument) -> begin argument; end; 匿名函數對象，用於接收執行對根目錄(/)的 POST 請求處理功能的函數 "do_Response";
# # session = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => key);  # 保存網站的 Session 數據;
# # number_Worker_threads = Core.UInt8(Base.Sys.CPU_THREADS);  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Base.Sys.CPU_THREADS,  # Core.UInt8(0)，創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
# # time_sleep = Core.Float16(0);  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
# readtimeout = Core.Int(0);  # 服務器響應數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
# connect_timeout = Core.Int(0);  # 服務器鏈接超時，單位：（秒），close the connection after this many seconds if it is still attempting to connect. Use to disable.connect_timeout = 0;
# # isConcurrencyHierarchy = "Tasks";  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
# # print("isConcurrencyHierarchy: ", isConcurrencyHierarchy, "\n");
# # 當 isConcurrencyHierarchy = "Multi-Threading" 時，必須在啓動之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程;
# # 即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl
# # 即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl
# # println(Base.Threads.nthreads()); # 查看當前可用的綫程數目;
# # println(Base.Threads.threadid()); # 查看當前綫程 ID 號;
# # http_Server = http_Server;
# # worker_queues_Dict::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
# response_stream::Core.Union{Base.IOStream, Base.IOBuffer, Core.Array{Core.UInt8, 1}, Base.Vector{UInt8}, Core.Nothing, Core.Bool, Core.Int64} = Core.nothing;  # Base.IOBuffer(),  # 設置接收到的響應值類型爲二進制字節流 IO 對象，a writeable stream or any -like type for which is defined. The response body will be written to this stream instead of returned as a .IOIOTwrite(T, AbstractVector{UInt8})Base.Vector{UInt8};
# cookiejar = mycookiejar;  # ::HTTP.CookieJar = HTTP.CookieJar()  # Cookie Persistence; # HTTP.Cookies.setcookies!(mycookiejar, http_response.message.url, http_response.message.headers);  # HTTP.Cookies.setcookies!(jar::CookieJar, url::URI, headers::Headers);  # HTTP.Cookies.getcookies!(mycookiejar, http_response.message.url);  # HTTP.Cookies.getcookies!(jar::CookieJar, url::URI);

# # total_worker_called_number = Base.Dict{Core.String, Core.UInt64}();  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}()  # 記錄每個綫程纍加的被調用運算的總次數;
# postData = Base.Dict{Core.String, Core.Any}("Client_say" => "Julia-1.9.3 HTTP.request().");  # ::Core.Union{Core.String, Base.Dict}，postData::Core.Union{Core.String, Base.Dict{Core.Any, Core.Any}}，"{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"time\":\"" * Base.string(now_date) * "\"}";

# # a = Array{Union{Core.Bool, Core.Float64, Core.Int64, Core.String},1}(Core.nothing, 3);
# a = http_Client(
#     host,  # ::Core.String,  # "127.0.0.1" or "localhost"; 監聽主機域名 Host domain name;
#     port;  # ::Core.Union{Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8, Core.String};  # 0 ~ 65535，監聽埠號（端口）;
#     IPVersion = IPVersion,  # "IPv6"、"IPv4";
#     postData = postData,  # ::Core.Union{Core.String, Base.Dict} = "",  # Base.Dict{Core.String, Core.Any}("Client_say" => "Julia-1.6.2 Sockets.connect."),  # postData::Core.Union{Core.String, Base.Dict{Core.Any, Core.Any}}，"{\"Client_say\":\"" * "No request Headers Authorization and Cookie received." * "\",\"time\":\"" * Base.string(now_date) * "\"}";
#     proxy = proxy,  # ::Core.String = Core.nothing,  # 當需要通過代理服務器僞裝發送請求時，代理服務器的網址 URL 值字符串，pass request through a proxy given as a url; alternatively, the , , , , and environment variables are also detected/used; if set, they will be used automatically when making requests.http_proxyHTTP_PROXYhttps_proxyHTTPS_PROXYno_proxy;
#     requestPath = requestPath,  # ::Core.String = "/",
#     requestProtocol = requestProtocol,  # ::Core.String = "HTTP",
#     query = query,  # ::Base.Dict{Core.String, Core.String} = Core.nothing,  # Base.Dict{Core.String, Core.String}(),  # Base.Dict{Core.String, Core.String}("ID" => "23"),  # 請求查詢 key => value 字典，a or of key => values to be included in the urlPairDict;
#     URL = URL,  # ::Core.String = "",  # Base.string(http_Client.requestProtocol) * "://" * Base.convert(Core.String, Base.strip((Base.split(Base.string(http_Client.Authorization), ' ')[2]))) * "@" * Base.string(http_Client.host) * ":" * Base.string(http_Client.port) * Base.string(http_Client.requestPath),  # 請求網址 URL "http://username:password@127.0.0.1:8081/index?a=1&b=2&c=3#a1";
#     requestMethod = requestMethod,  # ::Core.String = "GET",  # "POST",  # "GET"; # 請求方法;
#     # time_out = time_out,  # ::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
#     readtimeout = readtimeout,  # ::Core.Int = Core.Int(0),  # 服務器響應數據讀取超時，單位：（秒），close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable;
#     connect_timeout = connect_timeout,  # ::Core.Int = Core.Int(30),  # 服務器鏈接超時，單位：（秒），close the connection after this many seconds if it is still attempting to connect. Use to disable.connect_timeout = 0;
#     Authorization = Authorization,  # ::Core.String = ":",  # "Basic username:password" -> "Basic dXNlcm5hbWU6cGFzc3dvcmQ=";
#     Basicbasicauth = Basicbasicauth,  # ::Core.Bool = true,  # 設置從請求網址 URL 中解析截取請求的賬號和密碼，Basic authentication is detected automatically from the provided url's (in the form userinfoscheme://user:password@host) and adds the 「Authorization:」 header; this can be disabled by passing Basicbasicauth = false;
#     Cookie = Cookie,  # ::Core.String = "",  # "Session_ID=request_Key->username:password" -> "Session_ID=cmVxdWVzdF9LZXktPnVzZXJuYW1lOnBhc3N3b3Jk";
#     Referrer = Referrer,  # ::Core.String = http_Client.URL,  # 請求的來源網頁 URL "http://username:password@127.0.0.1:8081/index?a=1&b=2&c=3#a1";
#     requestFrom = requestFrom,  # ::Core.String = "user@email.com",
#     # do_Function = do_Function,  # (argument) -> begin argument; end,  # 匿名函數對象，用於接收執行對根目錄(/)的 GET 請求處理功能的函數 "do_Response";
#     # session = session,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}("request_Key->username:password" => http_Server.key),  # 保存網站的 Session 數據;
#     # number_Worker_threads = number_Worker_threads,  # ::Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.UInt8(0),  # 創建子進程 worker 數目等於物理 CPU 數目，使用 Base.Sys.CPU_THREADS 常量獲取本機 CPU 數目，自定義函數檢查輸入合規性 CheckString(number_Worker_threads, 'arabic_numerals');
#     # time_sleep = time_sleep,  # ::Core.Union{Core.Float64, Core.Float32, Core.Float16, Core.Int, Core.Int128, Core.Int64, Core.Int32, Core.Int16, Core.Int8, Core.UInt, Core.UInt128, Core.UInt64, Core.UInt32, Core.UInt16, Core.UInt8} = Core.Float16(0),  # 監聽文檔輪詢時使用 sleep(time_sleep) 函數延遲時長，單位秒;
#     # isConcurrencyHierarchy = isConcurrencyHierarchy,  # ::Core.String = "Tasks",  # "Tasks" || "Multi-Threading" || "Multi-Processes"，當值為 "Multi-Threading" 時，必須在啓動 Julia 解釋器之前，在控制臺命令行修改環境變量：export JULIA_NUM_THREADS=4(Linux OSX) 或 set JULIA_NUM_THREADS=4(Windows) 來設置啓動 4 個綫程，即 Windows 系統啓動方式：C:\> set JULIA_NUM_THREADS=4 C:/Julia/bin/julia.exe ./Interface.jl，即 Linux 系統啓動方式：root@localhost:~# export JULIA_NUM_THREADS=4 /usr/Julia/bin/julia ./Interface.jl;
#     # worker_queues_Dict = worker_queues_Dict,  # ::Base.Dict{Core.String, Core.Any} = Base.Dict{Core.String, Core.Any}(),  # 記錄每個綫程纍加的被調用運算的總次數;
#     # total_worker_called_number = total_worker_called_number,  # ::Base.Dict{Core.String, Core.UInt64} = Base.Dict{Core.String, Core.UInt64}(),  # 記錄每個綫程纍加的被調用運算的總次數;
#     response_stream = response_stream,  # Core.nothing,  # Base.IOBuffer(),  # 設置接收到的響應值類型爲二進制字節流 IO 對象，a writeable stream or any -like type for which is defined. The response body will be written to this stream instead of returned as a .IOIOTwrite(T, AbstractVector{UInt8})Base.Vector{UInt8};
#     cookiejar = cookiejar  # ::HTTP.CookieJar = HTTP.CookieJar()  # Cookie Persistence; # HTTP.Cookies.setcookies!(mycookiejar, http_response.message.url, http_response.message.headers);  # HTTP.Cookies.setcookies!(jar::CookieJar, url::URI, headers::Headers);  # HTTP.Cookies.getcookies!(mycookiejar, http_response.message.url);  # HTTP.Cookies.getcookies!(jar::CookieJar, url::URI);
# );
# # println(typeof(a))
# println(a[1])
# println(a[2])
# println(a[3])
